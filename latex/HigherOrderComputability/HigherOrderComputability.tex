% Created 2022-03-21 Mon 13:16
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\graphicspath{{../../books/}}
\input{../preamble.tex}
\newcommand{\ssmile}[1]{\mathord{\stackrel{\smallsmile}{#1}}}
\DeclareMathOperator{\lv}{lv}
\newcommand{\FF}{f\mspace{-7mu}f}
\newcommand{\TT}{t\mspace{-3mu}t}
\newcommand{\IF}{i\mspace{-4mu}f}
\DeclareMathOperator{\Asm}{\mathcal{A}sm}
\DeclareMathOperator{\nMod}{\mathcal{M}od}
\makeindex
\author{John Longley \& Dag Normann}
\date{\today}
\title{Higher Order Computability}
\hypersetup{
 pdfauthor={John Longley \& Dag Normann},
 pdftitle={Higher Order Computability},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.90 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Theory of Computability Models}
\label{sec:orgc1593d0}
\subsection{Computational Structure in Higher-Order Models}
\label{sec:orgcea79a0}
\subsubsection{Combinatory Completeness}
\label{sec:org421566a}
Combinatory completeness can be seen as a syntactic counterpart to the notion of weakly
cartesian closed model. In essence, combinatory completeness asserts that any operation
definable by means of a formal expression over A (constructed using application) is
representable by an element of A itself.

\begin{definition}[]
\label{3.1.16}
\begin{enumerate}
\item A \textbf{partial applicative structure} \(\bA\) consists of
\begin{itemize}
\item an inhabited family \(\abs{\bA}\) of datatypes \(A,B,\dots\) (indexed by some set \(T\))
\item a (right-associative) binary operation \(\Rightarrow\) on \(\abs{\bA}\)
\item for each \(A,B\in\abs{\bA}\), a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\)
\end{itemize}
\item A \textbf{typed partial combinatory algebra} (TPCA) is a partial applicative structure \(\bA\)
satisfying the following conditions
\begin{enumerate}
\item For any \(A,B\in\abs{\bA}\), there exists \(k_{AB}\in A\Rightarrow B\Rightarrow A\) s.t.
\begin{equation*}
\forall a.k\cdot a\downarrow,\quad\forall a,b.k\cdot a\cdot b=a
\end{equation*}
\item For any \(A,B,C\in\abs{\bA}\), there exists \(s_{ABC}\in(A\Rightarrow B\Rightarrow C)\Rightarrow(A\Rightarrow B)\Rightarrow(A\Rightarrow C)\) s.t.
\begin{equation*}
\forall f,g. s\cdot f\cdot g\downarrow,\quad\forall f,g,a.s\cdot f\cdot g\cdot a\simeq(f\cdot a)\cdot(g\cdot a)
\end{equation*}
A \textbf{lax TPCA} is obtained from a TPCA change '\(\simeq\)' to '\(\succeq\)' in the axiom \(s\)
\end{enumerate}
\item If \(\bA^\circ\) denotes a partial applicative structure, a \textbf{partial applicative
substructure} \(\bA^\sharp\) of \(\bA^\circ\) consists of a subset \(A^\sharp\subseteq A\) for each \(A\in\abs{\bA^\circ}\) s.t.
\begin{itemize}
\item if \(f\in(A\Rightarrow B)^\sharp\), \(a\in A^\sharp\) and \(f\cdot a\downarrow\) in \(\bA^\circ\), then \(f\cdot a\in B^\sharp\)
\end{itemize}

such a pair \((\bA^\circ;\bA^\sharp)\) is called a \textbf{relative partial applicative structure}
\item A \textbf{relative TPCA} is a relative partial applicative structure \((\bA^\circ,\bA^\sharp)\) s.t. there exist
elements \(k_{AB}, s_{ABC}\) in \(\bA^\sharp\) witnessing that \(\bA^\circ\) is a TPCA
\end{enumerate}
\end{definition}

\begin{definition}[]
Suppose \(\bA\) is a relative partial applicative structure over \(\sfT\)
\begin{enumerate}
\item The set of well-typed \textbf{applicative expressions} \(e:\sigma\) over \(\bA\) is defined inductively as
follows
\begin{itemize}
\item for each \(\sigma\in\sfT\), we have an unlimited supply of variables \(x^\sigma:\sigma\)
\item for each \(\sigma\in\sfT\) and \(a\in\bA^\sharp(\sigma)\), we have a \textbf{constant} symbol \(c_a:\sigma\) (we shall often
write \(c_a\) simply as \(a\))
\item If \(e:\sigma\to\tau\) and \(e':\sigma\) are applicative expressions, then \(ee'\) is an applicative
expression of type \(\tau\).
\end{itemize}

We write \(V(e)\) for the set of variables appearing in \(e\)

\item A \textbf{valuation} in \(\bA\) is a function \(v\) assigning to certain variables \(x^\sigma\) an
element \(v(x^\sigma)\in\bA^\circ(\sigma)\). Given an applicative expression \(e\) and a valuation \(v\)
covering \(V(e)\), the value \(\llb{e}_v\), when defined, is given inductively by
\begin{equation*}
\llb{x^\sigma}_v=v(x),\quad\llb{c_a}_v=a,\quad\llb{ee'}_\nu\simeq\llb{e}_v\cdot\llb{e'}_v
\end{equation*}
Note that if \(e:\tau\) and \(\llb{e}_v\) is defined then \(\llb{e}_v\in\bA^\circ(\tau)\).
\end{enumerate}
\end{definition}

Note that for any \(v\) with \(\ran(v)\in\bA^\sharp\), we can prove \(\llb{e:\tau}_v\in\bA^\sharp(\tau)\) by induction:
\begin{enumerate}
\item If \(e\) is of the form \(x^\tau\)
\item If \(e\) is of the form \(c_a\) where \(a\in\bA^\sharp(\tau)\)
\item If \(e\) is of the form \(e'e''\) where \(e':\sigma\to\tau\) and \(e'':\sigma\).

\(\llb{e}_v=\llb{e'}_v\cdot\llb{e''}_v\) where \(\llb{e'}_v\in\bA^\sharp(\sigma\to\tau)\) and \(\llb{e''}_v\in\bA^\sharp(\sigma)\).
Since \(\bA^\sharp\) is a substructure of \(\bA^\circ\), if \(\llb{e'}_v\cdot\llb{e''}_v\downarrow\), then \(\llb{e}\in\bA^\sharp(\tau)\)
\end{enumerate}

\begin{definition}[]
Let \(\bA\) be a relative partial applicative structure. We say \(\bA\) is \textbf{lax combinatory complete}
if for every applicative expression \(e:\tau\) over \(\bA\) and every variable \(x^\sigma\), there is an
applicative expression \(\lambda^*x^\sigma.e\) with \(V(\lambda^*x^\sigma.e)=V(e)-\{x^\sigma\}\) s.t. for any valuation \(v\)
covering \(V(\lambda^*x^\sigma.e)\) and any \(a\in\bA^\circ(\sigma)\) we have
\begin{equation*}
\llb{\lambda^*x^\sigma.e}_v\downarrow,\quad\llb{\lambda^*x^\sigma.e}_v\cdot a\succeq\llb{e}_{v,x\mapsto a}
\end{equation*}
We say \(\bA\) is \textbf{strictly combinatory complete} if this holds with '\(\simeq\)' in place of '\(\succeq\)'
\end{definition}

\begin{theorem}[]
\label{3.3.3}
A (relative) partial applicative structure \(\bA\) is a lax (relative) TPCA iff it is lax
combinatory complete
\end{theorem}

\begin{proof}
If \(\bA\) is lax combinatory complete, then for any \(\rho\), \(\sigma\), \(\tau\) we may define
\begin{align*}
k_{\sigma\tau}&=\llb{\lambda^*x^\sigma.(\lambda^*y^\tau.x)}_\emptyset\\
s_{\rho\sigma\tau}&=\llb{\lambda^*x^{\rho\to\sigma\to\tau}.(\lambda^*y^{\rho\to\sigma}.(\lambda^*z^\rho.xz(yz)))}_\emptyset
\end{align*}

Conversely, if \(\bA\) is a lax TPCA, then given any suitable choice of elements \(k\) and \(s\)
for \(\bA\), we may define \(\lambda^*x^\sigma.e\) by induction on the structure of \(e\):
\begin{align*}
\lambda^*x^\sigma.x&=s_{\sigma(\sigma\to\sigma)}k_{\sigma(\sigma\to\sigma)}k_{\sigma\sigma}&&\\
\lambda^*x^\sigma.a&=k_{\tau\sigma}a&&\text{for each }a\in\bA^\sharp(\tau)\\
\lambda^*x^\sigma.ee'&=s_{\sigma\tau\tau'}(\lambda^*x^\sigma.e)(\lambda^*x^\sigma.e')&&\text{if }e:\tau\to\tau',e':\tau\text{ and }ee'\text{ contains }x
\end{align*}
\end{proof}

The same argument shows that \(\bA\) is a strict TPCA iff it is strictly combinatory complete

we often tacitly suppose that a TPCA \(\bA\) comes equipped with some choice of k and s drawn from A♯,
and in this case we shall use the notation \(\lambda^*x.e\) for the applicative expression given by the
above proof. Since all the constants appearing in e are drawn from \(A^\sharp\), the same will be true for
\(\lambda^*x.e\).


In TPCAs constructed as syntactic models for untyped or typed \(\lambda\)-calculi (as in Example 3.1.6 or
Section 3.2.3), the value of \(\lambda^*x.e\) coincides with \(\lambda x.e\). However, the notational distinction is worth
retaining, since the term \(\lambda^*x.e\) as defined above is not syntactically identical
to \(\lambda x.e\).

More generally, we may consider terms of the \(\lambda\)-calculus as \textbf{meta-expressions} for applicative
expressions. Specifically any such \(\lambda\)-term \(M\) can be regarded as denoting an applicative
expression \(M^\dagger\) as follows:
\begin{equation*}
x^\dag=x,\quad c_a^\dag=c_a,\quad (MN)^\dag=M^\dag N^\dag,\quad(\lambda x.M)^\dag=\lambda^*x.(M^\dag)
\end{equation*}

Some caution is needed here, however, because \(\beta\)-equivalent meta-expressions
do not always have the same meaning
\begin{examplle}[]
Consider the two meta-expressions \((\lambda x.(\lambda y.y)x)\) and \(\lambda x.x\). Although these are
\(\beta\)-equivalent, the first expands to \(s(ki)i\) and the second to \(i\), where \(i\equiv skk\).
\end{examplle}

The moral here is that \(\beta\)-reductions are not valid underneath \(\lambda^*\)-abstractions: in this case,
the reduction \((\lambda^*y.y)x\rightsquigarrow x\) is not valid underneath \(\lambda^*\). However at
least for the definition of \(\lambda^*\) given above, \(\beta\)-reductions at top level are valid.

\begin{proposition}[]
\label{3.5.5}
\begin{enumerate}
\item If \(M\) is a meta-expression, \(x\) is a variable and \(a\) is a constant or variable,
then \(\llb{((\lambda x.M)a)^\dag}_v\succeq\llb{M[x\mapsto a]^\dag}\)
\item If \(M,N\) are meta-expressions, \(x\notin FV(N)\), no free occurrence of \(x\) in \(M\) occurs
under a \(\lambda\), and \(\llb{N^\dag}_v\downarrow\), then \(\llb{((\lambda x.M)N)^\dag}_v\succeq\llb{M[x\mapsto N]^\dag}_v\)
\end{enumerate}
\end{proposition}

\begin{proof}
Longley's PhD thesis
\end{proof}

From now on, we will not need to distinguish formally between meta-expressions and the
applicative expressions they denote. For the remainder of this chapter we shall use the \(\lambda^*\)
notation for such (meta-)expressions, retaining the asterisk as a reminder that the usual rules
of \(\lambda\)-calculus are not always valid.
\subsubsection{Pairing}
\label{sec:org2ab65e8}
\begin{definition}[]
\begin{enumerate}
\item A \textbf{type world} is simply a set \(\sfT\) of \textbf{type names} \(\sigma\), optionally endowed with any or
all of the following:
\begin{enumerate}
\item a \textbf{fixing map}, assigning a set \(\sfT[\sigma]\) to certain type names \(\sigma\in\sfT\)
\item a \textbf{product structure}, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\times\tau\)
\item an \textbf{arrow structure}, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\to\tau\)
\end{enumerate}
\item A \textbf{computability model over} a type world \(\sfT\) is a computability model \(\bC\) with index
set \(\sfT\) (so that \(\abs{\bC}=\{\bC(\sigma)\mid\sigma\in\sfT\}\)) subject to the following conventions
\begin{enumerate}
\item If \(\sfT\) has a fixing map, then \(\bC(\sigma)=T[\sigma]\) whenever \(\sfT(\sigma)\) is defined
\item If \(\sfT\) has a product structure, then \(\bC\) has weak products and for any \(\sigma,\tau\in\sfT\)
we have \(\bC(\sigma\times\tau)=\bC(\sigma)\bowtie\bC(\tau)\)
\item If \(\sfT\) has an arrow structure, then \(\bC\) is a higher-order model and for
any \(\sigma,\tau\in\sfT\) we have \(\bC(\sigma\to\tau)=\bC(\sigma)\Rightarrow\bC(\tau)\)
\item If \(\sfT\) has both a product and an arrow structure, then \(\bC\) is weakly cartesian closed
\end{enumerate}
\end{enumerate}
\end{definition}

\begin{theorem}[]
There is a canonical bijection between higher-order models and relative TPCAs
\end{theorem}

Let \(\bA\) be a relative TPCA (which is combinatory complete) over a type world \(\sfT\) with arrow structure, and suppose
that \(\bA\) (considered as a higher-order model) has weak products, inducing a product
structure \(\times\) on \(\sfT\). This means that for any \(\sigma,\tau\in\sfT\) there are elements
\begin{equation*}
fst\in\bA^\sharp((\sigma\times\tau)\to\sigma),\quad snd\in\bA^\sharp((\sigma\times\tau)\to\tau)
\end{equation*}
And for each \(\sigma,\tau\in\sfT\) a \textbf{paring} operation
\begin{equation*}
pair\in\bA^\sharp(\sigma\to\tau\to(\sigma\times\tau))
\end{equation*}
s.t.
\begin{equation*}
\forall a\in\bA^\circ(\sigma),b\in\bA^\circ(\tau).\;fst\cdot(pair\cdot a\cdot b)=a\wedge snd\cdot(pair\cdot a\cdot b)=b
\end{equation*}

\begin{proposition}[]
A higher-order model with weak products has pairing iff it is weakly cartesian closed
\end{proposition}

\begin{lemma}[\ref{3.1.14}]
Suppose \(m,n>0\). Given
\begin{gather*}
f_j\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j)^\sharp,\quad(j=0,\dots,n-1),\\
g\in(B_0\Rightarrow\dots\Rightarrow B_{n-1}\Rightarrow C)^\sharp
\end{gather*}
there exists \(h\in (A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow C)^\sharp\) s.t.
\begin{equation*}
\forall a_0,\dots,a_{m-1}.h\cdot a_0\cdot\dots\cdot a_{m-1}\simeq g\cdot(f_0\cdot a_0\cdot\dots\cdot a_{m-1})\cdot\dots\cdot(f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
\end{equation*}
\end{lemma}

\begin{proof}
The binary partial functions representable in \(\bA^\sharp((\rho\times\sigma)\to\tau)\) are exactly those representable
in \(\bA^\sharp(\rho\to\sigma\to\tau)\)

Given \(f\in\bA^\sharp((\rho\times\sigma)\to\tau)\), by Proposition \ref{3.1.14}, we have \(h\in\bA^\sharp(\rho\to\sigma\to\tau)\) where
\begin{equation*}
\forall a,b.\; h\cdot a\cdot b\simeq f\cdot(pair\;\cdot a\cdot b)
\end{equation*}

Given \(f\in\bA^\sharp(\rho\to\sigma\to\tau)\), by the same Proposition, we have \(h\in\bA^\sharp((\rho\times\sigma)\to\tau)\) where
\begin{equation*}
\forall a,b.\; h\cdot c\simeq f\cdot(fst\cdot c)\cdot(snd\cdot c)
\end{equation*}
\end{proof}

Henceforth we shall generally work with pair in preference to the ‘external’ pairing of
operations, and will write \(pair\cdot a\cdot b\) when there is no
danger of confusion.

In untyped models, pairing is automatic
 \begin{equation*}
pair=\lambda^*xyz.zxy,\quad fst=\lambda^*p.p(\lambda^*xy.x),\quad snd=\lambda^*p.p(\lambda^*xy.y)
 \end{equation*}
\subsubsection{Booleans}
\label{sec:orgb74cd22}
\begin{definition}[]
A model \(\bA\) has \textbf{booleans} if for some type \(\ttB\) there exist elements
\begin{align*}
\TT,\FF&\in\bA^\sharp(\ttB)\\
\IF_\sigma&\in\bA(\ttB,\sigma,\sigma\to\sigma)\text{ for each }\sigma
\end{align*}
s.t. for all \(x,y\in\bA^\circ(\sigma)\) we have
\begin{equation*}
\IF_\sigma\cdot\TT\cdot x\cdot y=x,\quad\IF_\sigma\cdot\FF\cdot x\cdot y=y
\end{equation*}
Note that \(\TT,\FF\) need not be the sole element of \(\bA^\sharp(\bB)\)
\end{definition}

Alternatively, we may define a notion of having booleans in the setting of computability
model \(\bC\) with weak products: replace \(\IF_\sigma\) with \(\IF'_\sigma\in\bC[\B\times\sigma\times\sigma,\sigma]\). In a TPCA with
products and pairing the two definitions coincide

In untyped models, the existence of booleans is automatic: \(\TT=\lambda^*xy.x\), \(\FF=\lambda^*xy.y\)
and \(\IF=\lambda^*zxy.zxy\)

Obviously, the value of an expression \(\IF_\sigma\cdot b\cdot e\cdot e'\) cannot be defined unless the values of
both \(e\) and \(e'\) are defined. However, there is a useful trick that allows us to build conditional
expressions whose definedness requires only that the chosen branch of the conditional is
defined. This trick is specific to the higher-order setting, and is known as \textbf{strong definition
by cases}:

\begin{proposition}[]
Suppose \(\bA\) has booleans as above. Given applicative expressions \(e,e':\sigma\) there is an
applicative expression \((e\mid e'):\ttB\to\sigma\) s.t. for any valuation \(v\) covering \(V(e)\)
and \(V(e')\) we have
\begin{equation*}
\llb{(e\mid e')}_v\downarrow,\quad\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v,\quad
\llb{(e\mid e')\cdot\FF}_v\succeq\llb{e'}_v
\end{equation*}
\end{proposition}

\begin{proof}
Let \(\rho\) be any type s.t. \(\bA^\circ(\rho)\) is inhabited by some element \(a\), and define
\begin{equation*}
(e\mid e')=\lambda^*z^{\ttB}\cdot(\IF_\sigma z(\lambda^*r^\rho.e)(\lambda^*r^\rho.e')c_a)
\end{equation*}
where \(z,r\) are fresh variables

\(\llb{(e\mid e')}_v\downarrow\)  since by lax combinatory completeness

\(\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v\) by \ref{3.5.5}
\end{proof}

The expressions \(\lambda^*r.e\), \(\lambda^*r.e'\) in the above proof are known as \textbf{suspensions} or \textbf{thunks}: the idea is
that \(\llb{\lambda^*r.e}_v\) is guaranteed to be defined, but the actual evaluation of \(e_v\) (which may be
undefined) is ‘suspended’ until the argument \(c_a\) is supplied.
\subsubsection{Numerals}
\label{sec:orga33a799}
\begin{definition}[]
A model \(\bA\) has \textbf{numerals} if for some type \(\ttN\) there exist
\begin{align*}
\hat{0},\hat{1},\hat{2},\dots&\in\bA^\sharp(\ttN)\\
suc&\in\bA^\sharp(\ttN\to\ttN)
\end{align*}
and for any \(x\in\bA^\sharp(\sigma)\) and \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) an element
\begin{equation*}
Rec_\sigma(x,f)\in\bA^\sharp(\ttN\to\sigma)
\end{equation*}
s.t. for all \(x\in\bA^\sharp(\sigma)\), \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
\begin{align*}
suc\cdot\hatn&=\what{n+1}\\
Rec_\sigma(x,f)\cdot\hat{0}&=x\\
Rec_\sigma(x,f)\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(Rec_\sigma(x,f)\cdot\hatn)
\end{align*}
\end{definition}

The above definition has the advantage that it naturally adapts to the setting of a
computability model C with products: just replace the types of \(f\) and \(Rec_\sigma(x,f)\) above
with \(\bC[\ttN\times\sigma,\sigma]\) and \(\bC[\ttN,\sigma]\) respectively.

\begin{proposition}[]
A model \(\bA\) has numerals iff it has elements \(\hatn\), \(suc\) as above and
\begin{equation*}
rec_\sigma\in\bA^\sharp(\sigma\to(\ttN\to\sigma\to\sigma)\to\ttN\to\sigma)\quad\text{for each }\sigma
\end{equation*}
s.t. for all \(x\in\bA^\circ(\sigma)\), \(f\in\bA^\circ(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
\begin{align*}
suc\cdot\hatn&=\what{n+1}\\
rec_\sigma\cdot x\cdot f\cdot\hat{0}&=x\\
rec_\sigma\cdot x\cdot f\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(rec_\sigma\cdot x\cdot f\cdot\hatn)
\end{align*}
\end{proposition}

\begin{proof}
\(\Leftarrow\): Let \(Rec_\sigma(x,f)=rec_\sigma\cdot x\cdot f\)

\(\Rightarrow\): define
\begin{equation*}
rec_\sigma=Rec_{\sigma\to(\ttN\to\sigma\to\sigma)\to\sigma}(\lambda^*xf.x,\lambda^*nr.\lambda^*xf.fn(rxf))
\end{equation*}
?
\end{proof}

\begin{exercise}
Show that \(\bA\) has numerals, then \(\bA\) has booleans
\end{exercise}

\begin{proposition}[]
\label{3.3.13}
Every untyped model has numerals
\end{proposition}

\begin{proof}
Using the encodings for pairings and booleans given above, we may define the \textbf{Curry
numerals} \(\hatn\) in any untyped models as follows:
\begin{equation*}
\hat{0}=\la\TT,\TT\ra,\quad\what{n+1}=\la\FF,\hatn\ra
\end{equation*}
and \(suc=\lambda^*x.\la\FF,x\ra\). We also have elements for the zero testing and predecessor operations:
take \(iszero=fst\) and \(pre=\lambda^*x.\IF(iszero\;x)\hat{0}(snd\;x)\)
\end{proof}

In any model with numerals, a rich class of functions \(\N^r\to\N\) is representable. For example, the
(first-order) primitive recursive functions on \(\N\)

\begin{proposition}[]
\label{3.3.14}
For any primitive recursive \(f:\N^r\to\N\) there is an applicative expression \(e_f:\N^{(r)}\to\N\)
(involving constants 0, \(suc\), \(rec_{\ttN}\)) s.t. in any model \((\bA^\circ;\bA^\sharp)\) with numerals
we have \(\llb{e_f}_v\in\bA^\sharp\) (where \(v\) is the obvious valuation of the constants) and
\begin{equation*}
\forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\hatn_{r-1}=\hatm
\end{equation*}
\end{proposition}

\begin{proof}

\end{proof}
\subsubsection{Recursion and Minimization}
\label{sec:org951130a}
\begin{definition}[]
\begin{enumerate}
\item A total model \(\bA\) \textbf{has general recursion}, or \textbf{has fixed points}, if for every
element \(f\in\bA^\sharp(\rho\to\rho)\) there is an element \(Fix_\rho(f)\in\bA^\sharp(\rho)\) s.t. \(Fix_\rho(f)=f\cdot Fix_\rho(f)\)
\item An arbitrary model \(\bA\) \textbf{has guarded recursion}, or \textbf{guarded fixed points}, if for every
element \(f\in\bA^\sharp(\rho\to\rho)\) where \(\rho=\sigma\to\tau\) there is an element \(GFix_\rho(f)\in\bA^\sharp(\rho)\)
s.t. \(GFix_\rho(f)\cdot x\succeq f\cdot GFix_\rho(f)\cdot x\) for all \(x\in\bA^\circ(\sigma)\)
\end{enumerate}
\end{definition}

\begin{proposition}[]
\begin{enumerate}
\item A total model \(\bA\) has general recursion iff for every type \(\rho\) there is an
element \(Y_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) we have
\begin{equation*}
Y_\rho\cdot f=f\cdot(Y_\rho\cdot f)
\end{equation*}
\item \(\bA\) has guarded recursion iff for every type \(\rho=\sigma\to\tau\) there is an
element \(Z_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) and \(x\in\bA^\circ(\sigma)\) we have
\begin{equation*}
Z_\rho\cdot f\downarrow,\quad Z_\rho\cdot f\cdot x\succeq f\cdot(Z_\rho\cdot f)\cdot x
\end{equation*}
\end{enumerate}
\end{proposition}

\begin{proof}
Define
\begin{equation*}
Y_\rho=Fix_{(\rho\to\rho)\to\rho}(\lambda^*y.\lambda^*f.f(yf)),\quad Z_\rho=GFix_{(\rho\to\rho)\to\rho}(\lambda^*z.\lambda^*fx.f(zf)x)
\end{equation*}
\end{proof}

Not all models of interest possess such recursion operators. Clearly, if \(\bA\) is a \textbf{total} model
with \(\bA(\ttN)=\N\) a type of numerals as above, then \(\bA\) cannot have general or even guarded
recursion: if \(\rho=\ttN\to\ttN\)  and \(f=\lambda^*gx.suc(gx)\) then we would
have \(Z\cdot f\cdot\hatn=suc\cdot Z\cdot f\cdot\hatn\), which is impossible. However, many models
with \(\bA(\ttN)=\N_\bot\) will have general recursion

Any \textbf{untyped} total model has general recursion, since we may take
\begin{equation*}
W=\lambda^*wf.f(wwf),\quad Y=WW
\end{equation*}
(This element \(Y\) is known as the \textbf{Turing fixed point combinator}). Likewise, every untyped
model, total or not, has guarded recursion, since we may take
\begin{equation*}
V=\lambda^*vfx.f(vvf)x,\quad Z=VV
\end{equation*}

Note in passing that Kleene’s \textbf{second recursion theorem} from classical computability theory is
tantamount to the existence of a guarded recursion operator in \(K_1\)

We can now prove \ref{3.3.13}. In any untyped model, let \(Z\) be a guarded recursion operator,
define
\begin{equation*}
R=\lambda^*rxfm.\IF(iszero\;m)(kx)(\lambda^*y.f(pre\;m))(rxf(pre\; m)\hat{0})
\end{equation*}
and take \(rec=\lambda^*xfm.(ZR)xfmi\).

\begin{definition}[]
A model \(\bA\) with numerals \textbf{has minimization} if it contains an
element \(min\in\bA^\sharp((\ttN\to\ttN)\to\ttN)\) s.t. whenever \(\hatg\in\bA^\circ(\ttN\to\ttN)\) represents some
total \(g:\N\to\N\) and \(m\) is the least number s.t. \(g(m)=0\), we have \(min\cdot\hatg=\hatm\)
\end{definition}

\begin{proposition}[]
\label{3.3.19}
There is an applicative expression Min involving constants \(\hat{0}\), suc, iszero, if
and \(Z\) s.t. in any model with numerals and guarded recursion, \(\llb{Min}_v\) is a
minimization operator
\end{proposition}

\begin{proof}
Take \(Min=Z(\lambda^*M.\lambda^*g.\IF(iszero(g\;\hat{0}))\hat{0}(M(\lambda^*n.g(suc\;n))))\)
\end{proof}

\begin{proposition}[]
For any partial computable \(f:\N^r\rhu\N\) there is an applicative
expression \(e_f:\ttN^{(r)}\to\ttN\) (involving constants 0, suc, \(rec_{\ttN}\), min) s.t. in any
model \(\bA\) with numerals and minimization we have \(\llb{e_f}_v\in\bA^\sharp\) (with the obvious
valuation \(v\)) and
\begin{equation*}
\forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\dots\cdot\hatn_{r-1}=\hatm
\end{equation*}
\end{proposition}

\begin{proof}
Since our definition of minimization refers only to total functions \(g:\N\to\N\), we appeal to the
\emph{Kleene normal form} theorem: there are primitive recursive functions \(T:\N^{r+2}\to\N\) and \(U:\N\to\N\)
such that any partial computable \(f\) has an ‘index’ \(e\in\N\) such
that \(f(\barn)\simeq U(\mu y.T(e,\barn,y)=0)\)
for all \(\barn\). Using this, the result follows easily from Propositions \ref{3.3.14} and \ref{3.3.19}.
\end{proof}
\subsubsection{The Category of Assemblies}
\label{sec:org8d0cc38}
\begin{definition}[]
Let \(\bC\) be a lax computability model over \(T\). The \textbf{category of assemblies over} \(\bC\),
written \(\Asm(\bC)\) is defined as follows:
\begin{itemize}
\item Objects \(X\) are triples \((\abs{X},\rho_X,\Vdash_X)\) where \(\abs{X}\) is a set, \(\rho_X\in T\)
names some type, and \(\Vdash_X\subseteq\bC(\rho_X)\times\abs{X}\) is a relation
s.t. \(\forall x\in\abs{X}.\exists a\in\bC(\rho_X).a\Vdash_Xx\) (The formula \(a\Vdash_Xx\) may be read as '\(a\)
\textbf{realizes} \(x\)')
\item A morphism \(f:X\to Y\) is a function \(f:\abs{X}\to\abs{Y}\) that is \textbf{tracked} by
some \(\barf\in\bC[\rho_X,\rho_Y]\), in the sense that for any \(x\in\abs{X}\) and \(a\in\bC(\rho_X)\) we have
\begin{equation*}
a\Vdash_Xx\Rightarrow\barf(a)\Vdash_Yf(x)
\end{equation*}
\end{itemize}


An assembly \(X\) is called \textbf{modest} if \(a\Vdash_Xx\wedge a\Vdash_Xx'\) implies \(x=x'\). We
write \(\nMod(\bC)\) for the full subcategory of \(\Asm(\bC)\) consisting of modest assemblies
\end{definition}

Intuitively, we regard an assembly \(X\) as an ``abstract datatype'' for which we have a concrete
implementation on the ``machine'' \(\bC\). The underlying set \(\abs{X}\) is the set of values of
the abstract type, and for each \(x\in\abs{X}\), the elements \(a\Vdash_Xx\) are the possible
machine representations of this abstract value. (Note that an abstract value \(x\) may have many
possible machine representations \(a\).) The morphisms \(f:X\to Y\) may then be regarded as the
``computable mappings'' between such datatypes

In the case that \(\bC\) is a lax TPCA \(\bA\), we may also denote the above
categories \(\Asm(\bA)\), \(\nMod(\bA)\), or by \(\Asm(\bA^\circ;\bA^\sharp)\), \(\nMod(\bA^\circ;\bA^\sharp)\). Note that
realizers for elements \(x\in\abs{X}\) may be arbitrary elements of \(\bA^\circ(\rho_X)\), whereas a
morphism \(f:X\to Y\) must be tracked by an element of \(\bA^\sharp(\rho_X\to\rho_Y)\)

Viewed in this way, all the datatypes we shall typically wish to consider in fact live in the
subcategory \(\nMod(\bC)\): an abstract data value is uniquely determined by any of its machine
representations. Note also that if \(Y\) is modest, a morphism \(f:X\to Y\) is completely determined by
any \(\barf\) that tracks it.

\begin{definition}[]
Let the category \(\bC\) have binary products. An \textbf{exponential} of objects \(B\) and \(C\) consists
of an object \(C^B\) and an arrow \(\epsilon:C^B\times B\to C\) s.t. for any object \(A\) and
arrow \(f:A\times B\to C\) there is a unique arrow \(\tilf:A\to C^B\) s.t. \(\epsilon\circ(\tilf\times 1_B)=f\)
\begin{center}\begin{tikzcd}
C^B\\
A\ar[u,"\tilf"']
\end{tikzcd}\hspace{1cm}\begin{tikzcd}
C^B\times B\ar[r,"\epsilon"]&C\\
A\times B\ar[u,"\tilf\times 1_B"]\ar[ur,"f"']
\end{tikzcd}\end{center}
\end{definition}


\begin{theorem}[]
\label{3.3.22}
Let \(\bC\) be a lax computability model
\begin{enumerate}
\item If \(\bC\) has a weak terminal, then \(\Asm(\bC)\) has a terminal object 1
\item If \(\bC\) has weak products, then \(\Asm(\bC)\) has binary cartesian products
\item If \(\bC\) weakly cartesian closed, then \(\Asm(\bC)\) is cartesian closed
\item If \(\bC\) has a weak terminal and booleans, \(\Asm(\bC)\) has the coproduct \(1+1\)
\item If \(\bC\) has a weak terminal and numerals, \(\Asm(\bC)\) has a natural number object
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item If \((I,i)\) is a weak terminal, define \(1=(\{i\},I,\Vdash_1=\{(i,i)\})\). Then for any \(X\in\Asm(\bC)\),
\(f=\Lambda x.i\) is the unique morphism where \(\barf=\Lambda x.i\).
\setcounter{enumi}{1}
\item If \(X\) and \(Y\) are assemblies and \(\rho\) is a weak product of \(\rho_X\) and \(\rho_Y\), define
the assembly \(X\times Y\) by
\begin{equation*}
\abs{X\times Y}=\abs{X}\times\abs{Y},\quad\rho_{X\times Y}=\rho,\quad a\Vdash_{X\times Y}(x,y)\text{ iff }
\pi_X(a)\Vdash_Xx\wedge\pi_Y(a)\Vdash_Yy
\end{equation*}
\item If \(X\) and \(Y\) are assemblies, let us say an element \(t\in\bC(\rho_X\to\rho_Y)\) \textbf{tracks} a
function \(f:\abs{X}\to\abs{Y}\) if
\begin{equation*}
\forall x\in\abs{X},a\in\bC(\rho_X).\;a\Vdash_Xx\Rightarrow t\cdot_{XY}a\Vdash_Yf(x)
\end{equation*}
Now define the assembly \(Y^X\) as follows:
\begin{align*}
\abs{Y^X}&=\{f:\abs{X}\to\abs{Y}\mid f\text{ is tracked by some }t\in\bC(\rho_X\to\rho_Y)\}\\
\rho_{Y^X}&=\rho_X\to\rho_Y\\
t\Vdash_{Y^X}f&\Leftrightarrow t\text{ tracks }f
\end{align*}
\end{enumerate}
\end{proof}

Theorem \ref{3.2.22} also holds with \(\nMod(\bC)\), and the
inclusion \(\nMod(\bC)\hookrightarrow\Asm(\bC)\) preserves all the relevant structure
\end{document}
