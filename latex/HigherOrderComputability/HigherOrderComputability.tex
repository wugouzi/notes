% Created 2022-03-21 Mon 13:16
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\graphicspath{{../../books/}}
\input{../preamble.tex}
\newcommand{\ssmile}[1]{\mathord{\stackrel{\smallsmile}{#1}}}
\DeclareMathOperator{\lv}{lv}
\newcommand{\FF}{f\mspace{-7mu}f}
\newcommand{\TT}{t\mspace{-3mu}t}
\newcommand{\IF}{i\mspace{-4mu}f}
\DeclareMathOperator{\Asm}{\mathcal{A}sm}
\DeclareMathOperator{\nMod}{\mathcal{M}od}
\makeindex
\author{John Longley \& Dag Normann}
\date{\today}
\title{Higher Order Computability}
\hypersetup{
 pdfauthor={John Longley \& Dag Normann},
 pdftitle={Higher Order Computability},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.0.90 (Org mode 9.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Theory of Computability Models}
\label{sec:orgc1593d0}
\subsection{Computational Structure in Higher-Order Models}
\label{sec:orgcea79a0}
\subsubsection{Combinatory Completeness}
\label{sec:org421566a}
Combinatory completeness can be seen as a syntactic counterpart to the notion of weakly
cartesian closed model. In essence, combinatory completeness asserts that any operation
definable by means of a formal expression over A (constructed using application) is
representable by an element of A itself.

\begin{definition}[]
\label{3.1.16}
\begin{enumerate}
\item A \textbf{partial applicative structure} \(\bA\) consists of
\begin{itemize}
\item an inhabited family \(\abs{\bA}\) of datatypes \(A,B,\dots\) (indexed by some set \(T\))
\item a (right-associative) binary operation \(\Rightarrow\) on \(\abs{\bA}\)
\item for each \(A,B\in\abs{\bA}\), a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\)
\end{itemize}
\item A \textbf{typed partial combinatory algebra} (TPCA) is a partial applicative structure \(\bA\)
satisfying the following conditions
\begin{enumerate}
\item For any \(A,B\in\abs{\bA}\), there exists \(k_{AB}\in A\Rightarrow B\Rightarrow A\) s.t.
\begin{equation*}
\forall a.k\cdot a\downarrow,\quad\forall a,b.k\cdot a\cdot b=a
\end{equation*}
\item For any \(A,B,C\in\abs{\bA}\), there exists \(s_{ABC}\in(A\Rightarrow B\Rightarrow C)\Rightarrow(A\Rightarrow B)\Rightarrow(A\Rightarrow C)\) s.t.
\begin{equation*}
\forall f,g. s\cdot f\cdot g\downarrow,\quad\forall f,g,a.s\cdot f\cdot g\cdot a\simeq(f\cdot a)\cdot(g\cdot a)
\end{equation*}
A \textbf{lax TPCA} is obtained from a TPCA change '\(\simeq\)' to '\(\succeq\)' in the axiom \(s\)
\end{enumerate}
\item If \(\bA^\circ\) denotes a partial applicative structure, a \textbf{partial applicative
substructure} \(\bA^\sharp\) of \(\bA^\circ\) consists of a subset \(A^\sharp\subseteq A\) for each \(A\in\abs{\bA^\circ}\) s.t.
\begin{itemize}
\item if \(f\in(A\Rightarrow B)^\sharp\), \(a\in A^\sharp\) and \(f\cdot a\downarrow\) in \(\bA^\circ\), then \(f\cdot a\in B^\sharp\)
\end{itemize}

such a pair \((\bA^\circ;\bA^\sharp)\) is called a \textbf{relative partial applicative structure}
\item A \textbf{relative TPCA} is a relative partial applicative structure \((\bA^\circ,\bA^\sharp)\) s.t. there exist
elements \(k_{AB}, s_{ABC}\) in \(\bA^\sharp\) witnessing that \(\bA^\circ\) is a TPCA
\end{enumerate}
\end{definition}

\begin{definition}[]
Suppose \(\bA\) is a relative partial applicative structure over \(\sfT\)
\begin{enumerate}
\item The set of well-typed \textbf{applicative expressions} \(e:\sigma\) over \(\bA\) is defined inductively as
follows
\begin{itemize}
\item for each \(\sigma\in\sfT\), we have an unlimited supply of variables \(x^\sigma:\sigma\)
\item for each \(\sigma\in\sfT\) and \(a\in\bA^\sharp(\sigma)\), we have a \textbf{constant} symbol \(c_a:\sigma\) (we shall often
write \(c_a\) simply as \(a\))
\item If \(e:\sigma\to\tau\) and \(e':\sigma\) are applicative expressions, then \(ee'\) is an applicative
expression of type \(\tau\).
\end{itemize}

We write \(V(e)\) for the set of variables appearing in \(e\)

\item A \textbf{valuation} in \(\bA\) is a function \(v\) assigning to certain variables \(x^\sigma\) an
element \(v(x^\sigma)\in\bA^\circ(\sigma)\). Given an applicative expression \(e\) and a valuation \(v\)
covering \(V(e)\), the value \(\llb{e}_v\), when defined, is given inductively by
\begin{equation*}
\llb{x^\sigma}_v=v(x),\quad\llb{c_a}_v=a,\quad\llb{ee'}_\nu\simeq\llb{e}_v\cdot\llb{e'}_v
\end{equation*}
Note that if \(e:\tau\) and \(\llb{e}_v\) is defined then \(\llb{e}_v\in\bA^\circ(\tau)\).
\end{enumerate}
\end{definition}

Note that for any \(v\) with \(\ran(v)\in\bA^\sharp\), we can prove \(\llb{e:\tau}_v\in\bA^\sharp(\tau)\) by induction:
\begin{enumerate}
\item If \(e\) is of the form \(x^\tau\)
\item If \(e\) is of the form \(c_a\) where \(a\in\bA^\sharp(\tau)\)
\item If \(e\) is of the form \(e'e''\) where \(e':\sigma\to\tau\) and \(e'':\sigma\).

\(\llb{e}_v=\llb{e'}_v\cdot\llb{e''}_v\) where \(\llb{e'}_v\in\bA^\sharp(\sigma\to\tau)\) and \(\llb{e''}_v\in\bA^\sharp(\sigma)\).
Since \(\bA^\sharp\) is a substructure of \(\bA^\circ\), if \(\llb{e'}_v\cdot\llb{e''}_v\downarrow\), then \(\llb{e}\in\bA^\sharp(\tau)\)
\end{enumerate}

\begin{definition}[]
Let \(\bA\) be a relative partial applicative structure. We say \(\bA\) is \textbf{lax combinatory complete}
if for every applicative expression \(e:\tau\) over \(\bA\) and every variable \(x^\sigma\), there is an
applicative expression \(\lambda^*x^\sigma.e\) with \(V(\lambda^*x^\sigma.e)=V(e)-\{x^\sigma\}\) s.t. for any valuation \(v\)
covering \(V(\lambda^*x^\sigma.e)\) and any \(a\in\bA^\circ(\sigma)\) we have
\begin{equation*}
\llb{\lambda^*x^\sigma.e}_v\downarrow,\quad\llb{\lambda^*x^\sigma.e}_v\cdot a\succeq\llb{e}_{v,x\mapsto a}
\end{equation*}
We say \(\bA\) is \textbf{strictly combinatory complete} if this holds with '\(\simeq\)' in place of '\(\succeq\)'
\end{definition}

\begin{theorem}[]
\label{3.3.3}
A (relative) partial applicative structure \(\bA\) is a lax (relative) TPCA iff it is lax
combinatory complete
\end{theorem}

\begin{proof}
If \(\bA\) is lax combinatory complete, then for any \(\rho\), \(\sigma\), \(\tau\) we may define
\begin{align*}
k_{\sigma\tau}&=\llb{\lambda^*x^\sigma.(\lambda^*y^\tau.x)}_\emptyset\\
s_{\rho\sigma\tau}&=\llb{\lambda^*x^{\rho\to\sigma\to\tau}.(\lambda^*y^{\rho\to\sigma}.(\lambda^*z^\rho.xz(yz)))}_\emptyset
\end{align*}

Conversely, if \(\bA\) is a lax TPCA, then given any suitable choice of elements \(k\) and \(s\)
for \(\bA\), we may define \(\lambda^*x^\sigma.e\) by induction on the structure of \(e\):
\begin{align*}
\lambda^*x^\sigma.x&=s_{\sigma(\sigma\to\sigma)}k_{\sigma(\sigma\to\sigma)}k_{\sigma\sigma}&&\\
\lambda^*x^\sigma.a&=k_{\tau\sigma}a&&\text{for each }a\in\bA^\sharp(\tau)\\
\lambda^*x^\sigma.ee'&=s_{\sigma\tau\tau'}(\lambda^*x^\sigma.e)(\lambda^*x^\sigma.e')&&\text{if }e:\tau\to\tau',e':\tau\text{ and }ee'\text{ contains }x
\end{align*}
\end{proof}

The same argument shows that \(\bA\) is a strict TPCA iff it is strictly combinatory complete

we often tacitly suppose that a TPCA \(\bA\) comes equipped with some choice of k and s drawn from Aâ™¯,
and in this case we shall use the notation \(\lambda^*x.e\) for the applicative expression given by the
above proof. Since all the constants appearing in e are drawn from \(A^\sharp\), the same will be true for
\(\lambda^*x.e\).


In TPCAs constructed as syntactic models for untyped or typed \(\lambda\)-calculi (as in Example 3.1.6 or
Section 3.2.3), the value of \(\lambda^*x.e\) coincides with \(\lambda x.e\). However, the notational distinction is worth
retaining, since the term \(\lambda^*x.e\) as defined above is not syntactically identical
to \(\lambda x.e\).

More generally, we may consider terms of the \(\lambda\)-calculus as \textbf{meta-expressions} for applicative
expressions. Specifically any such \(\lambda\)-term \(M\) can be regarded as denoting an applicative
expression \(M^\dagger\) as follows:
\begin{equation*}
x^\dag=x,\quad c_a^\dag=c_a,\quad (MN)^\dag=M^\dag N^\dag,\quad(\lambda x.M)^\dag=\lambda^*x.(M^\dag)
\end{equation*}

Some caution is needed here, however, because \(\beta\)-equivalent meta-expressions
do not always have the same meaning
\begin{examplle}[]
Consider the two meta-expressions \((\lambda x.(\lambda y.y)x)\) and \(\lambda x.x\). Although these are
\(\beta\)-equivalent, the first expands to \(s(ki)i\) and the second to \(i\), where \(i\equiv skk\).
\end{examplle}

The moral here is that \(\beta\)-reductions are not valid underneath \(\lambda^*\)-abstractions: in this case,
the reduction \((\lambda^*y.y)x\rightsquigarrow x\) is not valid underneath \(\lambda^*\). However at
least for the definition of \(\lambda^*\) given above, \(\beta\)-reductions at top level are valid.

\begin{proposition}[]
\label{3.5.5}
\begin{enumerate}
\item If \(M\) is a meta-expression, \(x\) is a variable and \(a\) is a constant or variable,
then \(\llb{((\lambda x.M)a)^\dag}_v\succeq\llb{M[x\mapsto a]^\dag}\)
\item If \(M,N\) are meta-expressions, \(x\notin FV(N)\), no free occurrence of \(x\) in \(M\) occurs
under a \(\lambda\), and \(\llb{N^\dag}_v\downarrow\), then \(\llb{((\lambda x.M)N)^\dag}_v\succeq\llb{M[x\mapsto N]^\dag}_v\)
\end{enumerate}
\end{proposition}

\begin{proof}
Longley's PhD thesis
\end{proof}

From now on, we will not need to distinguish formally between meta-expressions and the
applicative expressions they denote. For the remainder of this chapter we shall use the \(\lambda^*\)
notation for such (meta-)expressions, retaining the asterisk as a reminder that the usual rules
of \(\lambda\)-calculus are not always valid.
\subsubsection{Pairing}
\label{sec:org2ab65e8}
\begin{definition}[]
\begin{enumerate}
\item A \textbf{type world} is simply a set \(\sfT\) of \textbf{type names} \(\sigma\), optionally endowed with any or
all of the following:
\begin{enumerate}
\item a \textbf{fixing map}, assigning a set \(\sfT[\sigma]\) to certain type names \(\sigma\in\sfT\)
\item a \textbf{product structure}, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\times\tau\)
\item an \textbf{arrow structure}, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\to\tau\)
\end{enumerate}
\item A \textbf{computability model over} a type world \(\sfT\) is a computability model \(\bC\) with index
set \(\sfT\) (so that \(\abs{\bC}=\{\bC(\sigma)\mid\sigma\in\sfT\}\)) subject to the following conventions
\begin{enumerate}
\item If \(\sfT\) has a fixing map, then \(\bC(\sigma)=T[\sigma]\) whenever \(\sfT(\sigma)\) is defined
\item If \(\sfT\) has a product structure, then \(\bC\) has weak products and for any \(\sigma,\tau\in\sfT\)
we have \(\bC(\sigma\times\tau)=\bC(\sigma)\bowtie\bC(\tau)\)
\item If \(\sfT\) has an arrow structure, then \(\bC\) is a higher-order model and for
any \(\sigma,\tau\in\sfT\) we have \(\bC(\sigma\to\tau)=\bC(\sigma)\Rightarrow\bC(\tau)\)
\item If \(\sfT\) has both a product and an arrow structure, then \(\bC\) is weakly cartesian closed
\end{enumerate}
\end{enumerate}
\end{definition}

\begin{theorem}[]
There is a canonical bijection between higher-order models and relative TPCAs
\end{theorem}

Let \(\bA\) be a relative TPCA (which is combinatory complete) over a type world \(\sfT\) with arrow structure, and suppose
that \(\bA\) (considered as a higher-order model) has weak products, inducing a product
structure \(\times\) on \(\sfT\). This means that for any \(\sigma,\tau\in\sfT\) there are elements
\begin{equation*}
fst\in\bA^\sharp((\sigma\times\tau)\to\sigma),\quad snd\in\bA^\sharp((\sigma\times\tau)\to\tau)
\end{equation*}
And for each \(\sigma,\tau\in\sfT\) a \textbf{paring} operation
\begin{equation*}
pair\in\bA^\sharp(\sigma\to\tau\to(\sigma\times\tau))
\end{equation*}
s.t.
\begin{equation*}
\forall a\in\bA^\circ(\sigma),b\in\bA^\circ(\tau).\;fst\cdot(pair\cdot a\cdot b)=a\wedge snd\cdot(pair\cdot a\cdot b)=b
\end{equation*}

\begin{proposition}[]
A higher-order model with weak products has pairing iff it is weakly cartesian closed
\end{proposition}

\begin{lemma}[\ref{3.1.14}]
Suppose \(m,n>0\). Given
\begin{gather*}
f_j\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j)^\sharp,\quad(j=0,\dots,n-1),\\
g\in(B_0\Rightarrow\dots\Rightarrow B_{n-1}\Rightarrow C)^\sharp
\end{gather*}
there exists \(h\in (A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow C)^\sharp\) s.t.
\begin{equation*}
\forall a_0,\dots,a_{m-1}.h\cdot a_0\cdot\dots\cdot a_{m-1}\simeq g\cdot(f_0\cdot a_0\cdot\dots\cdot a_{m-1})\cdot\dots\cdot(f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
\end{equation*}
\end{lemma}

\begin{proof}
The binary partial functions representable in \(\bA^\sharp((\rho\times\sigma)\to\tau)\) are exactly those representable
in \(\bA^\sharp(\rho\to\sigma\to\tau)\)

Given \(f\in\bA^\sharp((\rho\times\sigma)\to\tau)\), by Proposition \ref{3.1.14}, we have \(h\in\bA^\sharp(\rho\to\sigma\to\tau)\) where
\begin{equation*}
\forall a,b.\; h\cdot a\cdot b\simeq f\cdot(pair\;\cdot a\cdot b)
\end{equation*}

Given \(f\in\bA^\sharp(\rho\to\sigma\to\tau)\), by the same Proposition, we have \(h\in\bA^\sharp((\rho\times\sigma)\to\tau)\) where
\begin{equation*}
\forall a,b.\; h\cdot c\simeq f\cdot(fst\cdot c)\cdot(snd\cdot c)
\end{equation*}
\end{proof}

Henceforth we shall generally work with pair in preference to the â€˜externalâ€™ pairing of
operations, and will write \(pair\cdot a\cdot b\) when there is no
danger of confusion.

In untyped models, pairing is automatic
 \begin{equation*}
pair=\lambda^*xyz.zxy,\quad fst=\lambda^*p.p(\lambda^*xy.x),\quad snd=\lambda^*p.p(\lambda^*xy.y)
 \end{equation*}
\subsubsection{Booleans}
\label{sec:orgb74cd22}
\begin{definition}[]
A model \(\bA\) has \textbf{booleans} if for some type \(\ttB\) there exist elements
\begin{align*}
\TT,\FF&\in\bA^\sharp(\ttB)\\
\IF_\sigma&\in\bA(\ttB,\sigma,\sigma\to\sigma)\text{ for each }\sigma
\end{align*}
s.t. for all \(x,y\in\bA^\circ(\sigma)\) we have
\begin{equation*}
\IF_\sigma\cdot\TT\cdot x\cdot y=x,\quad\IF_\sigma\cdot\FF\cdot x\cdot y=y
\end{equation*}
Note that \(\TT,\FF\) need not be the sole element of \(\bA^\sharp(\bB)\)
\end{definition}

Alternatively, we may define a notion of having booleans in the setting of computability
model \(\bC\) with weak products: replace \(\IF_\sigma\) with \(\IF'_\sigma\in\bC[\B\times\sigma\times\sigma,\sigma]\). In a TPCA with
products and pairing the two definitions coincide

In untyped models, the existence of booleans is automatic: \(\TT=\lambda^*xy.x\), \(\FF=\lambda^*xy.y\)
and \(\IF=\lambda^*zxy.zxy\)

Obviously, the value of an expression \(\IF_\sigma\cdot b\cdot e\cdot e'\) cannot be defined unless the values of
both \(e\) and \(e'\) are defined. However, there is a useful trick that allows us to build conditional
expressions whose definedness requires only that the chosen branch of the conditional is
defined. This trick is specific to the higher-order setting, and is known as \textbf{strong definition
by cases}:

\begin{proposition}[]
Suppose \(\bA\) has booleans as above. Given applicative expressions \(e,e':\sigma\) there is an
applicative expression \((e\mid e'):\ttB\to\sigma\) s.t. for any valuation \(v\) covering \(V(e)\)
and \(V(e')\) we have
\begin{equation*}
\llb{(e\mid e')}_v\downarrow,\quad\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v,\quad
\llb{(e\mid e')\cdot\FF}_v\succeq\llb{e'}_v
\end{equation*}
\end{proposition}

\begin{proof}
Let \(\rho\) be any type s.t. \(\bA^\circ(\rho)\) is inhabited by some element \(a\), and define
\begin{equation*}
(e\mid e')=\lambda^*z^{\ttB}\cdot(\IF_\sigma z(\lambda^*r^\rho.e)(\lambda^*r^\rho.e')c_a)
\end{equation*}
where \(z,r\) are fresh variables

\(\llb{(e\mid e')}_v\downarrow\)  since by lax combinatory completeness

\(\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v\) by \ref{3.5.5}
\end{proof}

The expressions \(\lambda^*r.e\), \(\lambda^*r.e'\) in the above proof are known as \textbf{suspensions} or \textbf{thunks}: the idea is
that \(\llb{\lambda^*r.e}_v\) is guaranteed to be defined, but the actual evaluation of \(e_v\) (which may be
undefined) is â€˜suspendedâ€™ until the argument \(c_a\) is supplied.
\subsubsection{Numerals}
\label{sec:orga33a799}
\begin{definition}[]
A model \(\bA\) has \textbf{numerals} if for some type \(\ttN\) there exist
\begin{align*}
\hat{0},\hat{1},\hat{2},\dots&\in\bA^\sharp(\ttN)\\
suc&\in\bA^\sharp(\ttN\to\ttN)
\end{align*}
and for any \(x\in\bA^\sharp(\sigma)\) and \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) an element
\begin{equation*}
Rec_\sigma(x,f)\in\bA^\sharp(\ttN\to\sigma)
\end{equation*}
s.t. for all \(x\in\bA^\sharp(\sigma)\), \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
\begin{align*}
suc\cdot\hatn&=\what{n+1}\\
Rec_\sigma(x,f)\cdot\hat{0}&=x\\
Rec_\sigma(x,f)\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(Rec_\sigma(x,f)\cdot\hatn)
\end{align*}
\end{definition}

The above definition has the advantage that it naturally adapts to the setting of a
computability model C with products: just replace the types of \(f\) and \(Rec_\sigma(x,f)\) above
with \(\bC[\ttN\times\sigma,\sigma]\) and \(\bC[\ttN,\sigma]\) respectively.

\begin{proposition}[]
A model \(\bA\) has numerals iff it has elements \(\hatn\), \(suc\) as above and
\begin{equation*}
rec_\sigma\in\bA^\sharp(\sigma\to(\ttN\to\sigma\to\sigma)\to\ttN\to\sigma)\quad\text{for each }\sigma
\end{equation*}
s.t. for all \(x\in\bA^\circ(\sigma)\), \(f\in\bA^\circ(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
\begin{align*}
suc\cdot\hatn&=\what{n+1}\\
rec_\sigma\cdot x\cdot f\cdot\hat{0}&=x\\
rec_\sigma\cdot x\cdot f\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(rec_\sigma\cdot x\cdot f\cdot\hatn)
\end{align*}
\end{proposition}

\begin{proof}
\(\Leftarrow\): Let \(Rec_\sigma(x,f)=rec_\sigma\cdot x\cdot f\)

\(\Rightarrow\): define
\begin{equation*}
rec_\sigma=Rec_{\sigma\to(\ttN\to\sigma\to\sigma)\to\sigma}(\lambda^*xf.x,\lambda^*nr.\lambda^*xf.fn(rxf))
\end{equation*}
?
\end{proof}

\begin{exercise}
Show that \(\bA\) has numerals, then \(\bA\) has booleans
\end{exercise}

\begin{proposition}[]
\label{3.3.13}
Every untyped model has numerals
\end{proposition}

\begin{proof}
Using the encodings for pairings and booleans given above, we may define the \textbf{Curry
numerals} \(\hatn\) in any untyped models as follows:
\begin{equation*}
\hat{0}=\la\TT,\TT\ra,\quad\what{n+1}=\la\FF,\hatn\ra
\end{equation*}
and \(suc=\lambda^*x.\la\FF,x\ra\). We also have elements for the zero testing and predecessor operations:
take \(iszero=fst\) and \(pre=\lambda^*x.\IF(iszero\;x)\hat{0}(snd\;x)\)
\end{proof}

In any model with numerals, a rich class of functions \(\N^r\to\N\) is representable. For example, the
(first-order) primitive recursive functions on \(\N\)

\begin{proposition}[]
\label{3.3.14}
For any primitive recursive \(f:\N^r\to\N\) there is an applicative expression \(e_f:\N^{(r)}\to\N\)
(involving constants 0, \(suc\), \(rec_{\ttN}\)) s.t. in any model \((\bA^\circ;\bA^\sharp)\) with numerals
we have \(\llb{e_f}_v\in\bA^\sharp\) (where \(v\) is the obvious valuation of the constants) and
\begin{equation*}
\forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\hatn_{r-1}=\hatm
\end{equation*}
\end{proposition}

\begin{proof}

\end{proof}
\subsubsection{Recursion and Minimization}
\label{sec:org951130a}
\begin{definition}[]
\begin{enumerate}
\item A total model \(\bA\) \textbf{has general recursion}, or \textbf{has fixed points}, if for every
element \(f\in\bA^\sharp(\rho\to\rho)\) there is an element \(Fix_\rho(f)\in\bA^\sharp(\rho)\) s.t. \(Fix_\rho(f)=f\cdot Fix_\rho(f)\)
\item An arbitrary model \(\bA\) \textbf{has guarded recursion}, or \textbf{guarded fixed points}, if for every
element \(f\in\bA^\sharp(\rho\to\rho)\) where \(\rho=\sigma\to\tau\) there is an element \(GFix_\rho(f)\in\bA^\sharp(\rho)\)
s.t. \(GFix_\rho(f)\cdot x\succeq f\cdot GFix_\rho(f)\cdot x\) for all \(x\in\bA^\circ(\sigma)\)
\end{enumerate}
\end{definition}

\begin{proposition}[]
\begin{enumerate}
\item A total model \(\bA\) has general recursion iff for every type \(\rho\) there is an
element \(Y_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) we have
\begin{equation*}
Y_\rho\cdot f=f\cdot(Y_\rho\cdot f)
\end{equation*}
\item \(\bA\) has guarded recursion iff for every type \(\rho=\sigma\to\tau\) there is an
element \(Z_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) and \(x\in\bA^\circ(\sigma)\) we have
\begin{equation*}
Z_\rho\cdot f\downarrow,\quad Z_\rho\cdot f\cdot x\succeq f\cdot(Z_\rho\cdot f)\cdot x
\end{equation*}
\end{enumerate}
\end{proposition}

\begin{proof}
Define
\begin{equation*}
Y_\rho=Fix_{(\rho\to\rho)\to\rho}(\lambda^*y.\lambda^*f.f(yf)),\quad Z_\rho=GFix_{(\rho\to\rho)\to\rho}(\lambda^*z.\lambda^*fx.f(zf)x)
\end{equation*}
\end{proof}

Not all models of interest possess such recursion operators. Clearly, if \(\bA\) is a \textbf{total} model
with \(\bA(\ttN)=\N\) a type of numerals as above, then \(\bA\) cannot have general or even guarded
recursion: if \(\rho=\ttN\to\ttN\)  and \(f=\lambda^*gx.suc(gx)\) then we would
have \(Z\cdot f\cdot\hatn=suc\cdot Z\cdot f\cdot\hatn\), which is impossible. However, many models
with \(\bA(\ttN)=\N_\bot\) will have general recursion

Any \textbf{untyped} total model has general recursion, since we may take
\begin{equation*}
W=\lambda^*wf.f(wwf),\quad Y=WW
\end{equation*}
(This element \(Y\) is known as the \textbf{Turing fixed point combinator}). Likewise, every untyped
model, total or not, has guarded recursion, since we may take
\begin{equation*}
V=\lambda^*vfx.f(vvf)x,\quad Z=VV
\end{equation*}

Note in passing that Kleeneâ€™s \textbf{second recursion theorem} from classical computability theory is
tantamount to the existence of a guarded recursion operator in \(K_1\)

We can now prove \ref{3.3.13}. In any untyped model, let \(Z\) be a guarded recursion operator,
define
\begin{equation*}
R=\lambda^*rxfm.\IF(iszero\;m)(kx)(\lambda^*y.f(pre\;m))(rxf(pre\; m)\hat{0})
\end{equation*}
and take \(rec=\lambda^*xfm.(ZR)xfmi\).

\begin{definition}[]
A model \(\bA\) with numerals \textbf{has minimization} if it contains an
element \(min\in\bA^\sharp((\ttN\to\ttN)\to\ttN)\) s.t. whenever \(\hatg\in\bA^\circ(\ttN\to\ttN)\) represents some
total \(g:\N\to\N\) and \(m\) is the least number s.t. \(g(m)=0\), we have \(min\cdot\hatg=\hatm\)
\end{definition}

\begin{proposition}[]
\label{3.3.19}
There is an applicative expression Min involving constants \(\hat{0}\), suc, iszero, if
and \(Z\) s.t. in any model with numerals and guarded recursion, \(\llb{Min}_v\) is a
minimization operator
\end{proposition}

\begin{proof}
Take \(Min=Z(\lambda^*M.\lambda^*g.\IF(iszero(g\;\hat{0}))\hat{0}(M(\lambda^*n.g(suc\;n))))\)
\end{proof}

\begin{proposition}[]
For any partial computable \(f:\N^r\rhu\N\) there is an applicative
expression \(e_f:\ttN^{(r)}\to\ttN\) (involving constants 0, suc, \(rec_{\ttN}\), min) s.t. in any
model \(\bA\) with numerals and minimization we have \(\llb{e_f}_v\in\bA^\sharp\) (with the obvious
valuation \(v\)) and
\begin{equation*}
\forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\dots\cdot\hatn_{r-1}=\hatm
\end{equation*}
\end{proposition}

\begin{proof}
Since our definition of minimization refers only to total functions \(g:\N\to\N\), we appeal to the
\emph{Kleene normal form} theorem: there are primitive recursive functions \(T:\N^{r+2}\to\N\) and \(U:\N\to\N\)
such that any partial computable \(f\) has an â€˜indexâ€™ \(e\in\N\) such
that \(f(\barn)\simeq U(\mu y.T(e,\barn,y)=0)\)
for all \(\barn\). Using this, the result follows easily from Propositions \ref{3.3.14} and \ref{3.3.19}.
\end{proof}
\subsubsection{The Category of Assemblies}
\label{sec:org8d0cc38}
\begin{definition}[]
Let \(\bC\) be a lax computability model over \(T\). The \textbf{category of assemblies over} \(\bC\),
written \(\Asm(\bC)\) is defined as follows:
\begin{itemize}
\item Objects \(X\) are triples \((\abs{X},\rho_X,\Vdash_X)\) where \(\abs{X}\) is a set, \(\rho_X\in T\)
names some type, and \(\Vdash_X\subseteq\bC(\rho_X)\times\abs{X}\) is a relation
s.t. \(\forall x\in\abs{X}.\exists a\in\bC(\rho_X).a\Vdash_Xx\) (The formula \(a\Vdash_Xx\) may be read as '\(a\)
\textbf{realizes} \(x\)')
\item A morphism \(f:X\to Y\) is a function \(f:\abs{X}\to\abs{Y}\) that is \textbf{tracked} by
some \(\barf\in\bC[\rho_X,\rho_Y]\), in the sense that for any \(x\in\abs{X}\) and \(a\in\bC(\rho_X)\) we have
\begin{equation*}
a\Vdash_Xx\Rightarrow\barf(a)\Vdash_Yf(x)
\end{equation*}
\end{itemize}


An assembly \(X\) is called \textbf{modest} if \(a\Vdash_Xx\wedge a\Vdash_Xx'\) implies \(x=x'\). We
write \(\nMod(\bC)\) for the full subcategory of \(\Asm(\bC)\) consisting of modest assemblies
\end{definition}

Intuitively, we regard an assembly \(X\) as an ``abstract datatype'' for which we have a concrete
implementation on the ``machine'' \(\bC\). The underlying set \(\abs{X}\) is the set of values of
the abstract type, and for each \(x\in\abs{X}\), the elements \(a\Vdash_Xx\) are the possible
machine representations of this abstract value. (Note that an abstract value \(x\) may have many
possible machine representations \(a\).) The morphisms \(f:X\to Y\) may then be regarded as the
``computable mappings'' between such datatypes

In the case that \(\bC\) is a lax TPCA \(\bA\), we may also denote the above
categories \(\Asm(\bA)\), \(\nMod(\bA)\), or by \(\Asm(\bA^\circ;\bA^\sharp)\), \(\nMod(\bA^\circ;\bA^\sharp)\). Note that
realizers for elements \(x\in\abs{X}\) may be arbitrary elements of \(\bA^\circ(\rho_X)\), whereas a
morphism \(f:X\to Y\) must be tracked by an element of \(\bA^\sharp(\rho_X\to\rho_Y)\)

Viewed in this way, all the datatypes we shall typically wish to consider in fact live in the
subcategory \(\nMod(\bC)\): an abstract data value is uniquely determined by any of its machine
representations. Note also that if \(Y\) is modest, a morphism \(f:X\to Y\) is completely determined by
any \(\barf\) that tracks it.

\begin{definition}[]
Let the category \(\bC\) have binary products. An \textbf{exponential} of objects \(B\) and \(C\) consists
of an object \(C^B\) and an arrow \(\epsilon:C^B\times B\to C\) s.t. for any object \(A\) and
arrow \(f:A\times B\to C\) there is a unique arrow \(\tilf:A\to C^B\) s.t. \(\epsilon\circ(\tilf\times 1_B)=f\)
\begin{center}\begin{tikzcd}
C^B\\
A\ar[u,"\tilf"']
\end{tikzcd}\hspace{1cm}\begin{tikzcd}
C^B\times B\ar[r,"\epsilon"]&C\\
A\times B\ar[u,"\tilf\times 1_B"]\ar[ur,"f"']
\end{tikzcd}\end{center}
\end{definition}


\begin{theorem}[]
\label{3.3.22}
Let \(\bC\) be a lax computability model
\begin{enumerate}
\item If \(\bC\) has a weak terminal, then \(\Asm(\bC)\) has a terminal object 1
\item If \(\bC\) has weak products, then \(\Asm(\bC)\) has binary cartesian products
\item If \(\bC\) weakly cartesian closed, then \(\Asm(\bC)\) is cartesian closed
\item If \(\bC\) has a weak terminal and booleans, \(\Asm(\bC)\) has the coproduct \(1+1\)
\item If \(\bC\) has a weak terminal and numerals, \(\Asm(\bC)\) has a natural number object
\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item If \((I,i)\) is a weak terminal, define \(1=(\{i\},I,\Vdash_1=\{(i,i)\})\). Then for any \(X\in\Asm(\bC)\),
\(f=\Lambda x.i\) is the unique morphism where \(\barf=\Lambda x.i\).
\setcounter{enumi}{1}
\item If \(X\) and \(Y\) are assemblies and \(\rho\) is a weak product of \(\rho_X\) and \(\rho_Y\), define
the assembly \(X\times Y\) by
\begin{equation*}
\abs{X\times Y}=\abs{X}\times\abs{Y},\quad\rho_{X\times Y}=\rho,\quad a\Vdash_{X\times Y}(x,y)\text{ iff }
\pi_X(a)\Vdash_Xx\wedge\pi_Y(a)\Vdash_Yy
\end{equation*}
\item If \(X\) and \(Y\) are assemblies, let us say an element \(t\in\bC(\rho_X\to\rho_Y)\) \textbf{tracks} a
function \(f:\abs{X}\to\abs{Y}\) if
\begin{equation*}
\forall x\in\abs{X},a\in\bC(\rho_X).\;a\Vdash_Xx\Rightarrow t\cdot_{XY}a\Vdash_Yf(x)
\end{equation*}
Now define the assembly \(Y^X\) as follows:
\begin{align*}
\abs{Y^X}&=\{f:\abs{X}\to\abs{Y}\mid f\text{ is tracked by some }t\in\bC(\rho_X\to\rho_Y)\}\\
\rho_{Y^X}&=\rho_X\to\rho_Y\\
t\Vdash_{Y^X}f&\Leftrightarrow t\text{ tracks }f
\end{align*}
\end{enumerate}
\end{proof}

Theorem \ref{3.2.22} also holds with \(\nMod(\bC)\), and the
inclusion \(\nMod(\bC)\hookrightarrow\Asm(\bC)\) preserves all the relevant structure
\end{document}
