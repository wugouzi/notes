<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-01-17 五 21:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Basic Proof Theory</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="A. S. Troelstra and H. Schwichtenberg" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Basic Proof Theory</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6ba2a79">1. Introduction</a>
<ul>
<li><a href="#org1b57cdf">1.1. Preliminaries</a>
<ul>
<li><a href="#org67818a9">1.1.1. Subformulas</a></li>
<li><a href="#org2d84886">1.1.2. Contexts and Formula Occurrences</a></li>
</ul>
</li>
<li><a href="#org771fc66">1.2. Simple type theories</a></li>
<li><a href="#org53a9edd">1.3. Three Types of Formalism</a>
<ul>
<li><a href="#org366f68d">1.3.1. The BHK-interpretation</a></li>
<li><a href="#orgda581c6">1.3.2. A natural deduction system for minimal implication logic</a></li>
<li><a href="#orgce44d2c">1.3.3. Formulas-as-types</a></li>
<li><a href="#orge736fb5">1.3.4. Gentzen systems</a></li>
<li><a href="#org474a6a6">1.3.5. Semantical motivation of Gentzen systems</a></li>
<li><a href="#org3789168">1.3.6. A Hilbert system</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgea1b05c">2. N-systems and H-systems</a>
<ul>
<li><a href="#orgdf7510b">2.1. Natural Deduction Systems</a>
<ul>
<li><a href="#org8a71b0c">2.1.1. Natural deductions in sequent style</a></li>
<li><a href="#orgef2c6a3">2.1.2. The Complete Discharge Convention</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6ba2a79" class="outline-2">
<h2 id="org6ba2a79"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1b57cdf" class="outline-3">
<h3 id="org1b57cdf"><span class="section-number-3">1.1</span> Preliminaries</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org67818a9" class="outline-4">
<h4 id="org67818a9"><span class="section-number-4">1.1.1</span> Subformulas</h4>
<div class="outline-text-4" id="text-1-1-1">
<div class="definition">
<p>
The notion of <b>positive</b>, <b>negative</b>, <b>strictly positive</b> subformula are defined
in a similar style
</p>
<ol class="org-ol">
<li>\(A\) is a positive and a strictly positive subformula of itself</li>
<li>if \(B\wedge C\) or \(B\vee C\) is a positive [negative, strictly positive]
subformula of \(A\), then so are \(B,C\)</li>
<li>if \(\forall xB\) or \(\exists xB\) is a positive [negative, strictly
positive] subformula of \(A\), then so is \(B[x/t]\) for any \(t\) free for \(x\)
in \(B\)</li>
<li>if \(B\to C\) is a positive [negative] subformula of \(A\), then \(B\) is a
negative [positive] subformula of \(A\), and \(C\) is a positive [negative]
subformula of \(A\)</li>
<li>if \(B\to C\) is a strictly positive subformula of \(A\) then so is \(C\)</li>
</ol>


<p>
A strictly positive subformula of \(A\) is called a <b>strictly positive part
(s.p.p.)</b> of \(A\)
</p>

</div>
</div>
</div>
<div id="outline-container-org2d84886" class="outline-4">
<h4 id="org2d84886"><span class="section-number-4">1.1.2</span> Contexts and Formula Occurrences</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Formula occurrences (f.o.'s) will play an even more important role than the
formulas themselves. An f.o. is nothing but a formula with a position in
another structure (prooftree, sequent, a larger formula etc.).
</p>

<p>
A <b>context</b> is nothing but a formula with an occurrences of a special
propositional variable. Alternatively, a context is sometimes described as a
formula with a hole in it. 
</p>

<div class="definition">
<p>
We define <b>positive</b> (\(\calp\)) and <b>negative (formula-)contexts</b> (\(\caln\))
simultaneously by an induction definition. The symbol "\(*\)" functions as a
special proposition lett, a <b>placeholder</b>
</p>
<ol class="org-ol">
<li>\(*\in\calp\)</li>
</ol>


<p>
and if \(B^+\in \calp,B^{\minus}\in\caln\) and \(A\) is any formula, then
</p>
<ol class="org-ol">
<li value="2">\(A\wedge B^+,B^+\wedge A,A\vee B^+,B^+\vee A,A\to B^+,B^{\minus}\to A,
       \forall xB^+,\exists xB^+\in\calp\)</li>

<li>\(A\wedge B^-,B^-\wedge A,A\vee B^-,B^-\vee A,A\to B^-,B^+\to A,
       \forall xB^-,\exists xB^-\in\caln\)</li>
</ol>


<p>
The set of <b>formula contexts</b> is the union of \(\calp\) and \(\caln\). Note that a
context contains always only a single occurrence of \(*\).
</p>

<p>
For arbitrary contexts we sometimes write \(F[*],G[*],\dots\) THen
\(F[A],G[A],\dots\) are the formulas obtained by replacing \(*\) by \(A\)
</p>

<p>
The <b>strictly positive</b> contexts \(\cals\calp\) are defined by
</p>
<ol class="org-ol">
<li value="4">\(*\in\cals\calp\); and if \(B\in\cals\calp\), then</li>
<li>\(A\wedge B,B\wedge A,A\vee B,B\vee A,A\to B,\forall xB,\exists
       xB\in\cals\calp\)</li>
</ol>


<p>
An alternative definition
</p>
\begin{align*}
&\calp=*\mid A\wedge\calp\mid\calp\wedge A\mid A\vee\calp\mid\calp\vee A\mid 
A\to\calp\mid\caln\to A\mid\forall x\calp\mid\exists x\calp\\
&\caln=A\wedge\caln\mid\caln\wedge A\mid A\vee\caln\mid\caln\vee A\mid A\to\caln
\mid\calp\to A\mid\forall x\caln\mid \exists x\caln\\
&\cals\calp=*\mid A\wedge\cals\calp\mid\cals\calp\wedge A\mid
A\vee\cals\calp\mid\cals\calp\vee A\mid A\to\cals\calp
\mid\forall x\cals\calp\mid\exists x\cals\calp
\end{align*}

<p>
A <b>formula occurence</b> (<b>f.o.</b> for short) in a formula \(B\) is a literal
subformula \(A\) together with a context indicating the place where \(A\) occurs.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org771fc66" class="outline-3">
<h3 id="org771fc66"><span class="section-number-3">1.2</span> Simple type theories</h3>
<div class="outline-text-3" id="text-1-2">
<div class="definition">
<p>
the set of \tf{simple types} \(\calt_\to\) is constructed from a countable set
of \tf{type variables} \(P_0,P_1,\dots\) by means of a type-forming operation
(\tf{function-type constructor}) \(\to\)
</p>
<ol class="org-ol">
<li>type variables belong to \(\calt_\to\)</li>
<li>if \(A,B\in\calt_\to\), then \((A\to B)\in\calt_\rightarrow\)</li>
</ol>


<p>
A type of the form \(A\to B\) is called a \tf{function type}
</p>

</div>

<div class="definition">
<p>
All terms appear with a type; for terms of type \(A\) we use \(t^A,s^A,r^A\). The
terms are generated by the following three clauses
</p>
<ol class="org-ol">
<li>For each \(A\in T_\to\) there is a countably infinite supply of variables of
type \(A\); for arbitrary variables of type \(A\) we use
\(u^A,v^A,w^A,x^A,y^A,z^A\)</li>
<li>if \(t^{A\to B},s^A\) are terms, then \(\app(t^{A\to B},s^A)^B\) is a term of
type \(B\)</li>
<li>if \(t^B\) is a term of type \(B\) and \(x^A\) a variable of type \(A\), then
\((\lambda x^A.t^B)^{A\to B}\)</li>
</ol>

</div>
<p>
For \(\app(t^{A\to B},s^A)^B\) we usually write simply \((t^{A\to B}s^A)^B\)
</p>
<div class="definition">
<p>
The set \(\fv(t)\) of variables free in \(t\) is specified by
</p>
\begin{alignat*}{2}
&\fv(x^A)&&:=x^A\\
&\fv(ts)&&:=\fv(t)\cup\fv(s)\\
&\fv(\lambda x.t)&&:=\fv(t)\backslash\{x\}
\end{alignat*}

</div>


<div class="definition">
<p>
The operation of substitution of a term \(s\) for a variable \(x\) in a term \(t\)
(notation \(t[x/s]\)) may be defined by recursion on the complexity of \(t\), as
follows
</p>
\begin{alignat*}{2}
&x[x/s]&&:=s\\
&y[x/s]&&:=y\text{ for } y\not\equiv x\\
&(t_1t_2)[x/s]&&:=t_1[x/s]t_2[x/s]\\
&(\lambda x.t)[x/s]&&:=\lambda x.t\\
&(\lambda y.t)[x/s]&&=\lambda y.t[x/s]\text{ for } y\not\equiv x; \text{
w.l.o.g. } y\not\in\fv(s)
\end{alignat*}

</div>

<div class="lemma">
<p>
If \(x\not\equiv y, x\not\in\fv(t_2)\), then
</p>
\begin{equation*}
t[x/t_1][y/t_2]\equiv t[y/t_2][x/t_1[y/t_2]]
\end{equation*}

</div>

<div class="definition">
<p>
Let \(\mathsf{T}\) be a set of terms, and let conv be a binary relation on
\(\mathsf{T}\), written in infix notation: \(t\) conv \(s\). If \(t\) conv \(s\), we
say that \(t\) \tf{converts to} \(s\); \(t\) is called a \tf{redex} or
\tf{convertible} term and \(s\) the \tf{conversum} of \(t\). The replacement of a
redex by its conversum is called a \tf{conversion}. We write \(t\succ_1 s\)
(\(t\) \tf{reduces in one step to } \(s\)) if \(s\) is obtained from \(t\) by
replacement of a redex \(t'\) of \(t\) by a conversum \(t''\) of \(t'\). The relation
\(\succ\) (\tf{properly reduces to}) is the transitive closure of \(\succ_1\) and
\(\succeq\) (\tf{reduces to}) is the reflexive and transitive closure of
\(\succ_1\). The relation \(\succeq\) is said to be the notion of reduction
\tf{generated} by cont.
</p>

<p>
With the notion of reduction generated by cony we associate a relation on
\(\mathsf{T}\) called <b>conversion equality</b>: \(t=_{\conv}s\) (\(t\) is equal by
conversion to \(s\)) if there 
is a sequence \(t_0,\dots,t_n\) with \(t_0\equiv t,t_n\equiv s\), and \(t_i\preceq
   t_{i+1}\) or \(t_i\succeq t_{i+1}\) for each
\(i, 0\le i < n\). The subscript "conv" is usually omitted when clear from the
context
</p>

<p>
A term \(t\) is in <b>normal form</b>, or \(t\) is <b>normal</b>, if \(t\) does not contain a redex. \(t\)
<b>has a normal form</b> if there is a normal \(s\) such that \(t\succeq s\).
</p>

<p>
A <b>reduction sequence</b> is a (finite or infinite) sequence of pairs
\((t_0,\delta_0),(t_1,\delta_1),\dots\) 
with \(\delta_i\) an (occurrence of a) redex in \(t_i\) and \(t_i\succ t_{i+1}\) by
conversion 
of \(\delta_i\), for all \(i\). This may be written as
</p>
\begin{equation*}
t_0\overset{\delta_0}{\succ}_1 t_1\overset{\delta_1}{\succ}_1 t_2
\overset{\delta_2}{\succ}_1\dots
\end{equation*}
<p>
We often omit the \(\delta_i\), simply writing \(t_0\succ_1 t_1\succ_1 t_2\)
</p>

<p>
Finite reduction sequences are partially ordered under the initial part
relation ("sequence &sigma; is an initial part of sequence &tau;"); the collection of
finite 
reduction sequences starting from a term \(g\) forms a tree, the <b>reduction tree</b>
of \(t\). The branches of this tree may be identified with the collection of all
infinite and all terminating finite reduction sequences.
</p>


<p>
A term is <b>strongly normalizing</b> (is SN) if its reduction tree is finite
</p>

</div>

<p>
&beta;-conversion:
</p>
\begin{equation*}
(\lambda x^A.t^B) s^A\e\cont_\beta\e t^B[x^A/s^A]
\end{equation*}
<p>
&eta;-conversion:
</p>
\begin{equation*}
\lambda x^A.tx\e\cont_\eta\e  t\quad(x\not\in\fv(t))
\end{equation*}
<p>
&beta;&eta;-conversion \(\cont_{\beta\eta}\) is \(\cont_\beta\cup\cont_\eta\)
</p>

<div class="definition">
<p>
A relation \(R\) is said to be <b>confluent</b>, or to have the <b>Church-Rosser property</b>
(CR), if whenever \(t_0 Rt_1\) and \(t_0Rt_2\), then there is a \(t_3\) s.t.
\(t_1Rt_3\) and \(t_2Rt_3\). A relation \(R\) is said to be <b>weakly confluent</b> or to
have the <b>weak Church-Rosser property</b> if whenever \(t_0Rt_1,t_0Rt_2\) there is a
\(t_3\) s.t. \(t_1R^*t_3\) and \(t_2R^* t_3\) where \(R^*\) is the reflexive and
transitive closure of \(T\)
</p>

</div>

<div class="theorem">
<p>
For a confluent reduction relation \(\succeq\) the normal forms of terms are
unique. Furthermore, if \(\succeq\) is a confluent reduction relation we have
\(t=t'\) iff there is a term \(t''\) s.t. \(t\succ t''\) and \(t'\succ t''\)
</p>

</div>

<div class="theorem">
<p>
Let \(\succeq\) be the transitive and reflexive closure of \(\succ_1\), and let
\(\succ_1\) be weakly confluent. Then the normal form w.r.t. \(\succ_1\) of a
strongly normalizing \(t\) is unique. Moreover, if all terms are strongly
normalizing w.r.t. \(\succ_1\) then the relation \(\succeq\) is confluent.
</p>

</div>

<div class="proof">
<p>
Assume WCR, and let write \(s\in UN\) to indicate that \(s\) has a unique normal
form. Assume \(t\in SN, t\not\in UN\). Then there are two reduction sequences
\(t\succ_1 t_1'\dots\succ_1 t'\) and \(t\succ_1 T_1''\succ_1\dots\succ_1 t''\) with
\(t'\not\equiv t''\). Then either \(t'_1=t''_1\) or \(t'_1\neq t_1''\)
</p>

<p>
In the first case we can take \(t_1:=t_1'=t_1''\). In the second case, by WCR
we can find a \(t^*\) s.t. \(t^*\prec t_1',t_1''\); \(t\in SN\) hence \(t^*\succ
   t'''\) for some normal \(t'''\). Since \(t'\neq t'''\) or \(t''\neq t'''\), either
\(t_1'\not\in UN\) or \(t_1''\not\in UN\); so take \(t_1:=t_1'\) if \(t'\neq t'''\),
\(t_1:=t_1''\) otherwise.
</p>

<p>
Hence we can always find a \(t_1\prec t\) with \(t_1\not\in UN\) and get an
infinite sequence contradicting the SN of \(t\)
</p>

</div>

<div class="definition">
<p>
The <b>simple typed lambda calculus</b> \(\blambda_{\bto}\) is the calculus of
&beta;-reduction and &beta;-equality on the set of terms of \(\blambda_{\bto}\).
\(\blambda_{\bto}\) has the term system as described with the following axioms and
rules for \(\prec\) (\(\prec_\beta\)) and \(=\) (is \(=_\beta\))
</p>
\begin{align*}
&t\succeq t\quad(\lambda x^A.t^B)s^A\succeq t^B[x^A/s^A]\\
&\frac{t\succeq s}{rt\succeq rs}\quad
\frac{t\succ s}{tr\succ sr}\quad
\frac{t\succeq s}{\lambda x.t\succeq\lambda x.s}\quad
\frac{t\succeq s\quad s\succeq r}{t\succeq r}\\
&\frac{t\succeq s}{t=s}\quad\frac{t=s}{s=t}\quad
\frac{t=s\quad s=r}{t=r}
\end{align*}
<p>
The <b>extensional simple typed lambda calculus</b> \(\blambda\boldeta_\to\) is the
calculus of &beta;&eta;-reduction and &beta;&eta;-equality and the ser of terms
of \(\blambda_{\bto}\); in addition there is the axiom
</p>
\begin{equation*}
\lambda x.tx\succeq t\quad(x\not\in\fv(t))
\end{equation*}

</div>

<div class="lemma">
<p>
For \(\succeq\) either \(\succeq_\beta\) or \(\succ_{\beta\eta}\) we have
</p>
\begin{equation*}
\text{if } s\succeq s' \text{ then } s[y/s'']\succeq s'[y/s'']
\end{equation*}

</div>
<div class="proof">
<p>
By induction on the depth of a proof of \(s\succeq s'\). It suffices to check
the crucial basis step, where \(s\) is \((\lambda x.t)t'\) and \(s'\) is \(t[x/t']\).
</p>
\begin{equation*}
(\lambda x.t)t'[y/s'']=(\lambda x.(t[y/s''])t'[y/s''])=
t[y/s''][x/t'[y/s'']]=t[x/t'][y/s'']
\end{equation*}

</div>

<div class="proposition">
<p>
\(\succ_{\beta,1}\) and \(\succ_{\beta\eta,1}\) are weakly confluent
</p>

</div>
<div class="proof">
<p>
If the conversions leading from \(t\) to \(t'\) and \(t\) to \(t''\) concern disjoint
redexes, then \(t'''\) is simply obtained by converting both redexes
</p>

<p>
If \(t\equiv\dots(\lambda x.s)s'\dots\), \(t'\equiv\dots s[x/s']\dots\) and
\(t''\equiv\dots(\lambda x.s)s''\dots\), \(s'\succ_1 s''\), then \(t'''\equiv\dots
   s[x/s'']\dots\) and \(t'\succeq t'''\)  
in as many steps as there are occurrences of \(x\) in \(s\), hence <i>weak</i>
</p>

<p>
If \(t\equiv\dots(\lambda x.s)s'\dots\), \(t'\equiv\dots s[x/s']\dots\) and
\(t''\equiv\dots(\lambda x.s'')s'\dots\), \(s\succ_1 s''\), then \(t'''\equiv\dots
   s''[x/s']\dots\)
</p>

<p>
If \(t\equiv\dots(\lambda x.sx)s'\), \(t'=\dots (sx)[x/s']\dots\),
\(t''\equal\dots ss'\dots\)
</p>

</div>

<div class="theorem">
<p>
The terms of \(\blambda_{\bto},\blambda\boldeta_{\bto}\) are SN for \(\succeq_\beta\) and
\(\succeq_{\beta\eta}\) respectively, then hence the &beta;- and
&beta;&eta;-normal forms are unique
</p>

</div>

<p>
From the preceding theorem it follows that the reduction relations are
confluent. This can also be proved directly, without relying on strong
normalization, by the following method, due to W. W. Tait and P. Martin-Löf
(see Barendregt [1984, 3.2]) which also applies to the untyped lambda calculus.
The idea is to prove confluence for a relation \(\succeq_p\) which intuitively
corresponds to conversion of a finite set of redexes such that in case of
nesting the 
inner redexes are converted before the outer ones.
</p>
<div class="definition">
<p>
\(\succeq_p\) on \(\blambda_{\bto}\) is generated by the axiom and rules
</p>
\begin{alignat*}{2}
&(\text{id})x\succeq_p x\\
&(\lambda\text{mon})\frac{t\succeq_p t'}{\lambda x.t\succeq_p \lambda x.t'}&&
(\text{appmon})\frac{t\succeq_p t'\quad s\succeq_p s'}{ts\succeq_p t's'}\\
&(\beta\text{par})\frac{t\succeq_p t'\quad s\succeq_ps'}{(\lambda x.t)s\succeq_pt'[x/s']}
&&(\eta\text{par})\frac{t\succeq_p t'}{\lambda x.tx\succeq_pt'}
(x\not\in\fv(t))
\end{alignat*}

</div>

<div class="lemma">
<p>
If \(t\succ_p t',s\succ_p s'\), then \(t[x/s]\succ_p t'[x/s']\)
</p>

</div>

<div class="proof">
<p>
By induction on \(t\). Assume, w.l.o.g., \(x\not\in\fv(s)\)
</p>

<ol class="org-ol">
<li><p>
\(t\equiv(\lambda y.t_1)t_2\), then
</p>
\begin{align*}
&t\succeq_p t_1'[y/t_2']\\
&t[x/s]\equiv(\lambda y.t_1[x/s])t_2[x/s]\succeq_p
t_1'[x/s'][y/t_2'[x/s']]\equiv
t_1'[y/t_2'][x/s']
\end{align*}</li>
<li>\(t\equiv\lambda x.t_1x\)</li>
</ol>

</div>

<div class="lemma">
<p>
\(\succeq_p\) is confluent
</p>

</div>

<div class="proof">
<p>
Induction on \(t\)
</p>

</div>

<div class="theorem">
<p>
&beta;- and &beta;&eta;-reduction are confluent
</p>

</div>
<div class="proof">
<p>
The reflexive closure of \(\succ_1\) for &beta;&eta;-reduction is contained in
\(\succeq_p\), and \(\succeq\) is therefore the transitive closure of
\(\succeq_p\). Write \(t\succeq_{p,n}t'\) if there is a chain
\(t\equiv t_0\succeq_p t_1\succeq_p\dots\succeq_pt_n\equiv t'\). Then we show
by induction on \(n+m\) using the preceding lemma, that if
\(t\succeq_{p,n}t',t\succeq_{p,m}t''\) then there is a \(t'''\) s.t.
\(t'\succeq_{p,m}t''',t''\succeq_{p,n}t'''\) 
</p>
\begin{center}
\begin{tikzcd}
t \arrow[r,"\alpha-1"] \arrow[rd,"n+m+1-\alpha"{left}]&
t_0' \arrow[r,"1"] \arrow[rd,"n+m+1-\alpha"]&
t' \arrow[rd]\\
&t'' \arrow[r,"\alpha-1"] &
t_0''' \arrow[r]&t'''
\end{tikzcd}
\end{center}

</div>

<div class="definition">
<p>
The terms are inductive defined as in the case of \(\blambda_{\bto}\), but now with
the clauses
</p>
<ol class="org-ol">
<li>For each \(A\in\calt_\to\) there is a countably infinite supply of variables
of type \(A\); for arbitrary variables of type \(A\) we use
\(u^A,v^A,w^A,x^A,y^A,z^A\)</li>
<li><p>
for each \(A,B,C\in\calt\) there are constant terms
</p>
\begin{align*}
&\bk^{A,B}\in A\to(B\to A)\\
&\bs^{A,B,C}\in (A\to(B\to C))\to((A\to B)\to(A\to C))
\end{align*}</li>
<li>if \(t^{A,B},s^A\) are terms, then so is \(t^{A,B}s\)</li>
</ol>


<p>
\(\fv(\bk)=\fv(\bs)=\emptyset\)
</p>

</div>

<div class="definition">
<p>
The <b>weak reduction</b> relation \(\succeq_w\) on the terms of \(\cl_\to\) is
generated by a conversion relation \(\cont_w\) consisting of the following
pairs
</p>
\begin{equation*}
\bk^{A,B}x^Ay^B\e\cont_w\e x,\quad\bs^{A,B,C}x^{A\to(B\to C)}y^{A\to B}z^A
\e\cont_w\e xz(yz)
\end{equation*}

<p>
In otherwords, \(\cl_\to\) is the term system defined above with the following
axioms and rules for \(\succeq_w\) and \(=_w\)
</p>
\begin{alignat*}{3}
&t\succeq t&&\bk xy\succeq x\quad&&\bs xyz\succeq xz(yz)\\
&\frac{t\succeq s}{rt\succeq rs}\quad&&\frac{t\succeq s}{tr\succeq sr}&&
\frac{t\succeq s\quad s\succeq r}{t\succeq r}\\
&\frac{t\succeq s}{t=s}&&\frac{t=s}{s=t}&&\frac{t=s\quad s=r}{t=r}
\end{alignat*}

</div>

<div class="theorem">
<p>
The weak reduction relation in \(\cl_\to\), is confluent and
strongly normalizing, so normal forms are unique.
</p>

</div>

<div class="theorem">
<p>
To each term \(t\) in \(\cl_\to\), there is another term \(\lambda^*x^A.t\) such
that
</p>
<ol class="org-ol">
<li>\(x^A\not\in\fv(\lambda^*x^A.t)\)</li>
<li>\((\lambda^*x^A.t)s^A\succ_wt[x^A/s^A]\)</li>
</ol>

</div>
<div class="proof">
\begin{align*}
&\lambda^*x^A.x:=\bs^{A,A\to A,A}\bk^{A,A\to A}\bk^{A,A}\\
&\lambda^*x^A.y^B:=\bk^{B,A}y^B\text{ for }y\not\equiv x\\
&\lambda^*x^A.t_1^{B\to C}t_2^B:=\bs^{A,B,C}(\lambda^*x.t_1)(\lambda^*x.t_2)
\end{align*}

</div>

<div class="corollary">
<p>
\(\cl_\to\) is <b>combinatorially complete</b>, i.e. for every applicative
combination \(t\) of \(\bk,\bs\) and variables \(x_1,x_2,\dots x_n\) there is a
closed term \(s\) s.t. in \(\cl_\to\vdash sx_1\dots x_n=_w t\), in fact even
\(\cl_\to\vdash sx_1\dots x_n\succeq_w t\)
</p>

</div>

<div class="remark">
<p>
Note that: it's not true that if \(t=t'\) then \(\lambda^*x.t=\lambda^*x.t'\). 
\(\bk x\bk=x\) but \(\lambda^*x.\bk x\bk=\bs(\bs(\bk\bk)(\bs\bk\bk))(\bk\bk)\),
\(\lambda^*x.x=\bs\bk\bk\)
</p>

</div>

<div class="definition">
<p>
The <b>Church numerals</b> of type \(A\) are &beta;-normal terms \(\bar{n}_A\) of type 
\((A\to A)\to(A\to A), n\in\N\), defined by
</p>
\begin{equation*}
\bar{n}_A:=\lambda f^{A\to A}\lambda x^A.f^n(x)
\end{equation*}
<p>
where \(f^0(x):=x,f^{n+1}(x):=f(f^n(x))\). \(N_A=\{\bar{n}_A\}\)
</p>

</div>
<p>
N.B. If we want to use &beta;&eta;-normal terms, we must use \(\lambda f^{A\to
   A}.f\) instead of \(\lambda fx.fx\) for \(\bar{1}_A\)
</p>

<div class="definition">
<p>
A function ff\(f:\N^k\to\N\) is said to be <b>A-representable</b> if there is a term \(F\)
of \(\blambda_{\bto}\) s.t. (abbreviating \(\bar{n}_A\) as \(\bar{n}\))
</p>
\begin{equation*}
F\bar{n}_1\dots\bar{n}_k=\bar{f(n_1,\dots,n_k)}
\end{equation*}
<p>
for all \(n_1,\dots,n_k\in\N,\bar{n}_i=(\bar{n}_i)_A\)
</p>

</div>


<div class="definition">
<p>
<b>Polynomials</b>, <b>extended polynomials</b>
</p>
<ol class="org-ol">
<li>The \(n\)-argument <b>projections</b> \(\bp_i^n\) are given by
\(\bp_i^n(x_1,\dots,x_n)=x_i\), the unary constant functions \(\bc_m\) by
\(\bc_m(x)=m\), and \(\sg\), \(\overline{\sg}\) are unary functions which satisfy
\(\sg(S_n)=1\), \(\sg(0)=0\), where \(S\) is the successor function.</li>
<li>The \(n\)-argument function \(f\) is the <b>composition</b> of \(m\)-argument \(g\),
\(n\)-argument \(h_1,\dots,h_m\) if \(f\) satisfies
\(f(\bar{x})=g(h_1(\bar{x}),\dots,h_m(\bar{x}))\)</li>
<li>The <b>polynomials</b> in \(n\) variables are generated from \(\bp_i^n,\bc_m\),
addition and multiplication by closure under composition. The <b>extended
polynomials</b> are generated from \(\bp_i^n,\bc_m,\sg,\bar{sg}\), addition and
multiplication by closure under proposition</li>
</ol>

</div>

<div class="exercise">
<p>
Show that all terms in &beta;-normal form of type \((P\to P)\to(P\to P)\), \(P\) a
propositional variable, are either of the form \(\bar{n}_P\) or of the form
\(\lambda f^{P\to P}.f\)
</p>

</div>
<div class="proof">
<ol class="org-ol">
<li>\(\lambda f^{P\to P}\lambda x^P.t^P\) and \(t\) is in &beta;-normal form.</li>
<li>\(\lambda f^{P\to P}.f\)</li>
</ol>

</div>

<div class="theorem">
<p>
All extended polynomials are representable in \(\blambda_{\bto}\)
</p>

</div>
<div class="proof">
<p>
Abbreviate \(\N_A\) as \(N\).
</p>
\begin{alignat*}{2}
&F_+&&:=\lambda x^Ny^Nf^{A\to A}z^A.xf(yfz)\\
&F_\times&&:=\lambda x^Ny^Nf^{A\to A}.x(yf)\\
&F_{\bp_i^k}&&:=\lambda x_1^N\dots x_k^N.x_i\\
&F_{\bc_n}&&:=\lambda x^N.\overline{n}\\
&F_{\sg}&&:=\lambda x^Nf^{A\to A}z^A.x(\lambda u^A.fz)z\\
&F_{\overline{\sg}}&&:=\lambda x^Nf^{A\to A}z^A.x(\lambda u^A.z)(fz)
\end{alignat*}

</div>
</div>
</div>

<div id="outline-container-org53a9edd" class="outline-3">
<h3 id="org53a9edd"><span class="section-number-3">1.3</span> Three Types of Formalism</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org366f68d" class="outline-4">
<h4 id="org366f68d"><span class="section-number-4">1.3.1</span> The BHK-interpretation</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Minimal logic and intuitionistic logic differ only in the treatment of
negation, or (equivalently) falsehood, and minimal implication logic is the
same  
as intuitionistic implication logic
</p>

<p>
The informal interpretation underlying intuitionistic logic is the
Brouwer-Heyting-Kolmogorov interpretation; this interpretation tells us what
it means to 
prove a compound statement such as \(A\to B\) in terms of what it means to
prove the components \(B\) and \(A\) 
</p>
\begin{align*}
&\text{A construction }p\text{ proves }A\to B\text{ if }p\text{ transforms any
possible proof }q\\
&\text{of }A\text{ into a proof }p(q)\text{ of }B
\end{align*}

<p>
The BHK-interpretation of intuitionistic logic is based on the notion of <b>proof</b>
instead of truth
</p>

<p>
A <b>logical law</b> of implication logic, according to the BHK-interpretation, is a
formula for which we can give a proof, no matter how we interpret the atomic
formulas. A <b>rule</b> is valid for this interpretation if we know how to construct
a proof for the conclusion, given proofs of the premises
</p>

<p>
The following two rules for \(\to\) are obviously valid on the basis of the
BHK-interpretation: 
</p>
<ol class="org-ol">
<li>If, starting from a hypothetical (unspecified) proof \(u\) of \(A\), we can find
a proof \(t(u)\) of B, then we have in fact given a proof of \(A\to B\) (without
the assumption that \(u\) proves \(A\)). This proof may be denoted by
\(\lambda u.t(u)\).</li>
<li>Given a proof \(t\) of \(A\to B\), and a proof \(s\) of A, we can apply \(t\) to \(s\)
to obtain a proof of \(B\). For this proof we may write \(\app(t,s)\) or \(ts\) (\(t\)
applied to \(s\)).</li>
</ol>
</div>
</div>
<div id="outline-container-orgda581c6" class="outline-4">
<h4 id="orgda581c6"><span class="section-number-4">1.3.2</span> A natural deduction system for minimal implication logic</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Characteristic for natural deduction is the use of assumptions which may
be <b>closed</b> at some later step in the deduction.
</p>

<p>
The assumptions in a deduction which are occurrences of the same formula
with the same marker form together an <b>assumption class</b>. The notations
</p>
\begin{alignat*}{4}
&[A]^u\e\e&&A^u\e\e&&\cald'\e\e&&\cald'\\
&\cald&&\cald&&[A]&&A\\
&B&&B&&\cald&&\cald\\
& && &&B&&B
\end{alignat*}
<p>
have the following meaning, from left to right: 
</p>
<ol class="org-ol">
<li>a deduction \(\cald\), with
conclusion \(B\) and a set \([A]\) of open assumptions, consisting of all
occurrences of 
the formula \(A\) at top nodes of the prooftree \(\cald\) with marker \(u\) (note: both \(B\)
and the \([A]\) are part of \(\cald\), and we do not talk about the <b>multiset</b> \([A]^u\) since
we are dealing with formula occurrences);</li>
<li>a deduction \(\cald\), with conclusion
\(B\) and a single assumption of the form \(A\) marked \(u\) occurring at some top
node;</li>
<li>deduction \(\cald\) with a deduction \(\cald'\), with conclusion \(A\), substituted
for the assumptions \([A]^u\) of \(\cald\); (4) the same, but now for a single assumption
occurrence \(A\) in \(\cald\).</li>
<li>the formula \(A\) shown is the conclusion of \(\cald'\)
as well as the formula in an assumption class of \(\cald\).</li>
</ol>


<p>
We now consider a system \(\tonm\) for the minimal theory of implication.
</p>

<p>
A single formula occurrence \(A\) labelled with a marker is a single-node
prooftree, representing a deduction with conclusion A from open assumption
A.
</p>

\begin{center}
\AxiomC{$[A]^u$}
\noLine
\UnaryInfC{$\cald$}
\noLine
\UnaryInfC{$B$}
\RightLabel{${\to}$I$,u$}
\UnaryInfC{$A\to B$}
\DisplayProof
\hspace{1cm}
\AxiomC{$\cald$}
\noLine
\UnaryInfC{$A\to B$}
\AxiomC{$\cald'$}
\noLine
\UnaryInfC{$A$}
\RightLabel{${\to}$E}
\BinaryInfC{$B$}
\DisplayProof
\end{center}

<p>
By application of the rule \({\to}\text{I}\) of <b>implication introduction</b>, a
new prooftree is  
formed from \(\cald\) by adding at the bottom the conclusion \(A\to B\) while <b>closing</b>
the set of open assumptions \(A\) marked by \(u\). All other open assumptions
remain open in the new prooftree
</p>

<p>
The rule \({\to}\text{E}\) of <b>implication elimination</b> (also known as <b>modus
ponens</b>) 
constructs from two deductions \(\cald,\cald'\) with conclusions \(A\to B,A\) a new
combined deduction with conclusion \(B\), which has as open assumptions the
open assumptions of \(\cald\) and \(\cald'\) combined
</p>

<p>
Two occurrences &alpha;,&beta; of the same formula belong to the same 
<b>assumption class</b> if they bear the same label and either are both open or
have both been 
closed at the same inference.
</p>

<p>
It should be noted that in the rule \(\to\)I the "degenerate case", where
\([A]^u\) is empty, is permitted; thus for example the following is a correct
deduction:
</p>
\begin{prooftree}
\AxiomC{$A^u$}
\RightLabel{$v$}
\UnaryInfC{$B\to A$}
\RightLabel{$u$}
\UnaryInfC{$A\to(B\to A)$}
\end{prooftree}
</div>
</div>
<div id="outline-container-orgce44d2c" class="outline-4">
<h4 id="orgce44d2c"><span class="section-number-4">1.3.3</span> Formulas-as-types</h4>
<div class="outline-text-4" id="text-1-3-3">
<ol class="org-ol">
<li>To assumptions \(A\) correspond variables of type \(A\); more precisely,
formulas with the same marker get the same variable.</li>
<li><p>
For the rules \(\to\)I and \(\to\)E the assignment of terms to the
conclusion is shown below
</p>
\begin{center}
\AxiomC{$[u:A]$}
\noLine
\UnaryInfC{$\calc$}
\noLine
\UnaryInfC{$t:B$}
\RightLabel{$u$}
\UnaryInfC{$\lambda u^A.t^B:A\to B$}
\DisplayProof
\hspace{1cm}
\AxiomC{$\cald$}
\noLine
\UnaryInfC{$t:A\to B$}
\AxiomC{$\cald'$}
\noLine
\UnaryInfC{$s:A$}
\BinaryInfC{$(t^{A\to B}s^A):B$}
\DisplayProof
\end{center}</li>
</ol>


<p>
Thus there is a very close relationship between \(\blambda_\bto\) and \(\tonm\)
</p>

<p>
A &beta;-conversion
</p>
\begin{equation*}
(\lambda x^A.t^B)s^A\e\cont_\beta\e t^B[x^A/s^A]
\end{equation*}
<p>
corresponds to a transformation on prooftrees:
</p>
\begin{center}
\AxiomC{$[A]^u$}
\noLine
\UnaryInfC{$\cald$}
\noLine
\UnaryInfC{$B$}
\RightLabel{$u$}
\UnaryInfC{$A\to B$}
\AxiomC{$\cald'$}
\noLine
\UnaryInfC{$A$}
\BinaryInfC{$B$}
\DisplayProof
$\e\mapsto\e$
\alwaysNoLine
\AxiomC{$\cald'$}
\UnaryInfC{$[A]$}
\UnaryInfC{$\cald$}
\UnaryInfC{$B$}
\DisplayProof
\noLine

\end{center}

<p>
A proof without detours is said to be a <b>normal</b> proof. In a normal proof the
left premise of \(\to\)E is never the conclusion of \(\to\)I
</p>
</div>
</div>
<div id="outline-container-orge736fb5" class="outline-4">
<h4 id="orge736fb5"><span class="section-number-4">1.3.4</span> Gentzen systems</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
There are two motivations leading to Gentzen systems, which will be discussed
below. The first one views a Gentzen system as a metacalculus for natural
deduction; this applies in particular to systems for minimal and intuitionistic
logic. The second motivation is semantical: Gentzen systems for classical logic
are obtained by analysing truth conditions for formulas. This also applies to
intuitionistic and minimal logic if we use Kripke semantics instead of classical
semantics.
</p>



<p>
A <b>Gentzen system as a metacalculus</b>. Let us first consider a Gentzen system
obtained as a metacalculus for the system \(\tonm\). Consider the following
four construction steps for prooftrees.
</p>
<ol class="org-ol">
<li>The single-node tree with label \(A\), marker \(u\) is a prooftree</li>
<li>Add at the bottom of a prooftree an application of \(\to\)I, discharging
an assumption class</li>
<li><p>
Given a prooftree \(\cald\) with open assumption class \([B]^u\) and a
prooftree \(\cald_1\) deriving \(A\), replace all occurrences of \(B\) in
\([B]^u\) by
</p>
\begin{prooftree}
\AxiomC{$A\to B^v$}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$A$}
\BinaryInfC{$B$}
\end{prooftree}</li>
<li>Substitute a deduction of \(A\) for the occurrences of an (open) assumption
class \([A]^u\) of another deduction</li>
</ol>


<p>
These construction principles suffice to obtain any prooftree of \(\tonm\).
The closure under \(\to\)E is seen as follows: in order to obtain the tree
</p>
\begin{prooftree}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$A\to B$}
\AxiomC{$\cald_2$}
\noLine
\UnaryInfC{$A$}
\BinaryInfC{$B$}
\end{prooftree}
<p>
we first combine the first and third construction principles to obtain
</p>
\begin{prooftree}
\AxiomC{$A\to B^u$}
\AxiomC{$\cald_2$}
\noLine
\UnaryInfC{$A$}
\BinaryInfC{$B$}
\end{prooftree}
<p>
and then use the fourth principle to obtain the desired tree
</p>


<p>
Let \(\Gamma\Rightarrow A\) express that \(A\) is deducible in \(\tonm\) from
assumptions in &Gamma;. Then the four construction principles correspond to
the following axiom and rules
</p>
\begin{align*}
&\Gamma\cup\{A\}\Rightarrow A\text{ (Axiom)}\\
&
\AxiomC{$\Gamma\cup\{A\}\Rightarrow B$}
\RightLabel{R${\to}$}
\UnaryInfC{$\Gamma\Rightarrow A\to B$}
\DisplayProof
\hspace{1cm}
\AxiomC{$\Gamma\Rightarrow A$}
\AxiomC{$\Delta\cup\{B\}\Rightarrow C$}
\RightLabel{L${\to}$}
\BinaryInfC{$\Gamma\cup\Delta\cup\{A\to B\}\Rightarrow C$}
\DisplayProof
\\
&\AxiomC{$\Gamma\Rightarrow A$}
\AxiomC{$\Delta\cup\{A\}\Rightarrow B$}
\RightLabel{Cut}
\BinaryInfC{$\Gamma\cup\Delta\Rightarrow B$}
\DisplayProof
\end{align*}


<p>
Call the resulting system \(\cals\). Here in the sequents \(\Gamma\Rightarrow
    A\) the &Gamma; is treated as a (finite) set. If we rewrite the system above
with multisets, we get the Genzten system \(\cals'\) described below.
</p>
\begin{alignat*}{2}
&A\Rightarrow A\text{ (Axiom)}&&\\
&\AxiomC{$\Gamma\Rightarrow A$}
\AxiomC{$\Delta,B\Rightarrow C$}
\RightLabel{L$\to$}
\BinaryInfC{$\Gamma,\Delta,A\to B\Rightarrow C$}
\DisplayProof
\quad
&&\AxiomC{$\Gamma,A\Rightarrow B$}
\RightLabel{R$\to$}
\UnaryInfC{$\Gamma\Rightarrow A\to B$}
\DisplayProof\\
&\AxiomC{$\Gamma\Rightarrow A$}
\RightLabel{LW}
\UnaryInfC{$\Gamma,B\Ra A$}
\DisplayProof
&&\AxiomC{$\Gamma,B,B,\Ra A$}
\RightLabel{LC}
\UnaryInfC{$\Gamma,B\Ra A$}
\DisplayProof\\
&\AxiomC{$\Gamma\Ra A$}
\AxiomC{$A,\Delta\Ra B$}
\RightLabel{Cut}
\BinaryInfC{$\Gamma,\Delta\Ra B$}
\DisplayProof
&&
\end{alignat*}



<p>
R\(\to\) and L\(\to\) are called the logical rules, LW, LC and Cut the
structural rules. 
LC is called the rule of (left-) <b>contraction</b>, LW the rule of
(left-) <b>weakening</b>. 
</p>


<p>
It is not hard to convince oneself that, as long as only the principles 1-3
for the construction of prooftrees are applied, the resulting proof will always
be <b>normal</b>. Conversely, it may be proved that all normal prooftrees can be
obtained using construction principles 1-3 only. Thus we see that normal
prooftrees in \(\tonm\) correspond to deduction in the sequent calculus without
Cut; 
</p>

<p>
Deductions in \(\cals\) without the rule Cut have a very nice property, which is
immediately obvious: the <b>subformula property</b>: all formulas occurring in a
deduction of \(\Gamma\Ra A\) are subformulas of the formulas in \(\Gamma,A\).
</p>

<div class="exercise">
<p>
There are other possible choices for the construction principles for
prooftrees. For example, we might replace principle 3 by the following
principle 3':
</p>

<p>
Given a prooftree \(\cald\) with open assumption class \([B]^u\), replace all
occurrences of \(B\) in \([B]^u\) by
</p>
\begin{prooftree}
\AxiomC{$A\to B^v$}
\AxiomC{$A$}
\BinaryInfC{$B$}
\end{prooftree}

</div>
</div>
</div>
<div id="outline-container-org474a6a6" class="outline-4">
<h4 id="org474a6a6"><span class="section-number-4">1.3.5</span> Semantical motivation of Gentzen systems</h4>
<div class="outline-text-4" id="text-1-3-5">
<p>
Here we use sequents \(\Gamma\Ra\Delta\) with \(\Gamma\) and &Delta; finite sets;
the intuitive interpretation is that \(\Gamma\Ra\Delta\) is valid iff
\(\bigwedge\Gamma\to\bigvee\Delta\) is true. Now suppose we want to find out if there is a valuation making all of
\(\Gamma\) true and all of &Delta; false. We can break down this problem by means of two
rules, one for reducing \(A\to B\) on the left, another for reducing \(A\to B\) on
the right:
</p>
\begin{center}
\AxiomC{$\Gamma\Ra A,\Delta$}
\AxiomC{$\Gamma,B\Ra\Delta$}
\RightLabel{L$\to$}
\BinaryInfC{$\Gamma,A\to B\Ra\Delta$}
\DisplayProof
\hspace{0.6cm}
\AxiomC{$\Gamma,A,\Ra B,\Delta$}
\RightLabel{R$\to$}
\UnaryInfC{$\Gamma\Ra A\to B,\Delta$}
\DisplayProof
\end{center}
</div>
</div>
<div id="outline-container-org3789168" class="outline-4">
<h4 id="org3789168"><span class="section-number-4">1.3.6</span> A Hilbert system</h4>
<div class="outline-text-4" id="text-1-3-6">
<p>
The Hilbert system \(\tohm\) for minimal implication logic has as axioms all
formulas of the forms:
</p>
\begin{align*}
&A\to (B\to A)\quad\text{k-axioms}\\
&(A\to(B\to C))\to((A\to B)\to(A\to C))\quad(s-axioms)
\end{align*}

<p>
The corresponding term system for \(\tohm\) is \(\cl_\bto\)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgea1b05c" class="outline-2">
<h2 id="orgea1b05c"><span class="section-number-2">2</span> N-systems and H-systems</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgdf7510b" class="outline-3">
<h3 id="orgdf7510b"><span class="section-number-3">2.1</span> Natural Deduction Systems</h3>
<div class="outline-text-3" id="text-2-1">
<div class="definition">
<p>
Assumptions are formula occurrences always appearing at the top of a branch
and are supposed to be labelled by markers. The set of assumptions of the
same form with the same marker forms an <b>assumption class</b>. Distinct formulas
must have distinct markers. <span class="underline">We permit empty assumption classes</span>.
</p>

<p>
Assumptions may be closed; assumption classes are always closed "en bloc",
that is to say, at each inference, either all assumptions in a class are
closed, or they are left open.
</p>

<p>
Deductions in the system of natural deduction are generated as follows.
</p>

<p>
\noindent <i>Basis</i>. The single-node tree with label \(A\) is a (natural) <b>deduction</b>
from the open assumption \(A\); there are no closed assumptions
</p>

<p>
\noindent <i>Inductive step</i>. Let \(\cald_1,\cald_2,\cald_3\) be deductions. A
(natural) <b>deduction</b> \(\cald\) may be constructed according to one of the rules
below. The class \([A]^u,[B]^v\) 
</p>

<p>
For \(\wedge,\vee,\to,\forall,\exists\) we have <b>introduction rules</b> (<b>I-rules</b>)
and <b>elimination rules</b> (<b>E-rules</b>)
</p>
\begin{gather*}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$A$}
\AxiomC{$\cald_2$}
\noLine
\UnaryInfC{$B$}
\RightLabel{\(\wedge\)I}
\BinaryInfC{$A\wedge B$}
\DisplayProof\hspace{0.7cm}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$A\wedge B$}
\RightLabel{$\wedge\text{E}_{\text{R}}$}
\UnaryInfC{$A$}
\DisplayProof\hspace{0.7cm}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$A\wedge B$}
\RightLabel{$\wedge\text{E}_{\text{L}}$}
\UnaryInfC{$B$}
\DisplayProof\\
\AxiomC{$[A]^u$}
\noLine
\UnaryInfC{$\cald_1$}\noLine\UnaryInfC{$B$}
\RightLabel{$\to\text{I},u$}
\UnaryInfC{$A\to B$}\DisplayProof\hspace{1cm}
\AxiomC{$\cald_1$}
\noLine\UnaryInfC{$A\to B$}
\AxiomC{$\cald$}\noLine\UnaryInfC{$A$}
\RightLabel{$\to$E}\BinaryInfC{$B$}\DisplayProof\\
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$A$}
\RightLabel{$\vee\text{I}_{\text{R}}$}
\UnaryInfC{$A\vee B$}\DisplayProof\quad
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$B$}
\RightLabel{$\vee\text{I}_{\text{L}}$}
\UnaryInfC{$A\vee B$}\DisplayProof\quad
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$A\vee B$}
\AxiomC{$[A]^u$}\noLine\UnaryInfC{$\cald_2$}\noLine
\UnaryInfC{$C$}\AxiomC{$[B]^u$}\noLine\UnaryInfC{$\cald_3$}
\noLine\UnaryInfC{$C$}
\RightLabel{$\vee\text{E},u,v$}
\TrinaryInfC{$C$}\DisplayProof\\
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$A[x/y]$}
\RightLabel{$\forall$I}\UnaryInfC{$\forall xA$}\DisplayProof\quad
\parbox{11em}{In $\forall\text{I},y\equiv x$ or $y\not\in\fv(A)$, and $y$ is
not free in any assumption open in $\cald_1$}\hspace{0.9cm}
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$\forall xA$}
\RightLabel{$\forall$E}\UnaryInfC{$A[x/t]$}\DisplayProof\\
\AxiomC{$\cald_1$}\noLine\UnaryInfC{$A[x/t]$}
\RightLabel{$\exists$I}\UnaryInfC{$\exists xA$}\DisplayProof\hspace{0.9cm}
\AxiomC{$\cald_1$}
\noLine\UnaryInfC{$\exists xA$}\AxiomC{$[A[x/y]]^u$}\noLine
\UnaryInfC{$\cald_2$}\noLine\UnaryInfC{$C$}
\RightLabel{$\exists\text{E},u$}\BinaryInfC{$C$}\DisplayProof\quad
\parbox{11em}{In $\exists\text{I},y\equiv x$ or $y\not\in\fv(A)$, and $y$ is
not free  in $C$ nor in any assumption open in $\cald_2$ except in
$[A[x/y]]^u$}
\end{gather*}

<p>
This completes the description of the rules for the minimal logic \(\Nm\). Note
that \(\bot\) has not been mentioned in any of the above rules, and therefore
it behaves in minimal logic as an arbitrary unprovable propositional
constant.
</p>

<p>
To obtain the intuitionistic and classical system \(\Ni\) and \(\Nc\) we add the 
<b>intuitionistic absurdity rule</b> \(\bot_\text{i}\) and the more general 
<b>classical absurdity rule</b> \(\bot_\text{c}\) respectively:
</p>
\begin{equation*}
\AxiomC{$\cald_1$}
\noLine
\UnaryInfC{$\bot$}\RightLabel{$\bot_\text{i}$}
\UnaryInfC{$A$}\DisplayProof\hspace{1.5cm}
\AxiomC{$[\neg A]^u$}\noLine\UnaryInfC{$\cald_1$}
\noLine\UnaryInfC{$\bot$}\RightLabel{$\bot_{\text{c}},u$}\UnaryInfC{$A$}
\DisplayProof
\end{equation*}

<p>
(\(\bot_{\text{c}}\) is more general than \(\bot_{\text{i}}\) since \([\neg A]^u\)
may be empty). In an E-rule application, the premise containing the occurence
of the logical operator being eliminated is called the <b>major</b> premise. The
other premise(s) are called the <b>minor</b> premise(s). As a standard convention in
displaying prooftrees, we place the major premises of elimination rule
applications in leftmost position.
</p>

<p>
As to individual variables which are considered to be free in deduction, we
stipulate
</p>
<ul class="org-ul">
<li>The deduction consisting of assumption \(A\) only has \(\fv(A)\) as free
variables;</li>
<li>at each rule application, the free individual variables are inherited from
the immediate subdeduction, except that</li>
<li>in an application of \(\exists\)E the occurrences of the free variable
\(y\) in \(\cald_2\) become bound, and in an application of \(\forall\)I the
occurrences of variable \(y\) in \(\cald_1\) become bound, and</li>
<li>in \(\to\)I the vairables in \(\fv(A)\) have to be added in case \([A]^u\) is
empty, in \(\vee\text{I}_\text{R}\) those in \(\fv(B)\) have to be added, and
in \(\vee\text{I}_\text{L}\) those in \(\fv(A)\) have to be added</li>
</ul>


<p>
The individual variable becoming bound in an application &alpha; of
\(\forall\)I or \(\exists\)E is said to be the <b>proper</b> variable of &alpha;. 
</p>


<p>
If \(A\) is among the open assumptions of a dduction \(\cald\) with conclusion
\(B\), then conclusion \(B\) in \(\cald\) is said to <b>depend</b> on \(A\) in \(\cald\). From
now on we regard "assumption of \(\cald\)" and "open assumption of \(\cald\)" as
synonymous. 
</p>

</div>

<div class="definition">
<p>
A convenient global assumption in the presentation of a deduction is the 
<b>variable convention</b>. A deduction is said to satisfy the variable convention
if the proper variables of the application of \(\exists\)E and \(\forall\)I
are kept distinct.
</p>

<p>
If moreover the bound and free variables are kept distinct, the deduction is
said to be a <b>pure-variable</b> deduction.
</p>

</div>

<div class="remark">
<p>
Since in out notation for prooftrees, \([A]^u\) refers to all assumptions
\(A\) labelled \(u\), it is tacitly understood that in \(\vee\)E the label \(u\)
occurs in \(\cald_2\) only, and \(v\) in \(\cald_3\) only.
</p>

</div>

<div class="definition">
<p>
The theories generated by \(\Nm,\Ni\) and \(\Nc\) are denoted by \(\bM\) (minimal
logic), \(\bI\) (intuitionistic logic) and \(\bC\) (classical logic)
respectively.
</p>

<p>
\(\Gamma\vdash_{\bS}A\) for \(\bS=\bM,\bI,\bC\) iff \(A\) is derivable from the set
of assumptions &Gamma; in the N-systems for \(\bS\)
</p>

</div>

<div class="remark">
<ol class="org-ol">
<li><p>
Sometimes it is more natural to write \(\forall\)E and \(\exists\)I as
two-premise rules, with the individual term as second premise
</p>
\begin{align*}
\AxiomC{$\forall xA$}
\AxiomC{$t$}
\BinaryInfC{$A[x/t]$}
\DisplayProof\hspace{1cm}
\AxiomC{$A[x/t]$}
\AxiomC{$t$}
\BinaryInfC{$\exists xA$}
\DisplayProof
\end{align*}</li>
<li><p>
The statement of the rules \(\forall\)I and \(\exists\)E may be simplified
somewhat if we rely on convention that formulas differing only in the
naming of bound variables are equal. These rules may then be written as:
</p>
\begin{gather*}
\AxiomC{$\cald_1$}
\noLine\UnaryInfC{$A$}\RightLabel{$\forall$I}
\UnaryInfC{$\forall xA$}\DisplayProof\hspace{1cm}
\AxiomC{$\cald_1$}
\noLine\UnaryInfC{$\exists xA$}
\AxiomC{$[A]^u$}\noLine\UnaryInfC{$\cald_2$}\noLine
\UnaryInfC{$C$}\RightLabel{$\exists\text{E},u$}
\BinaryInfC{$C$}\DisplayProof
\end{gather*}
<p>
where in \(\forall\)I \(x\) is not free in any assumption open in \(\cald_1\)
and and \(\exists\)E \(x\) is not free in \(C\) nor in any assumption open in
\(\cald_2\) except in \([A]^u\)
</p></li>
</ol>

</div>
</div>
<div id="outline-container-org8a71b0c" class="outline-4">
<h4 id="org8a71b0c"><span class="section-number-4">2.1.1</span> Natural deductions in sequent style</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
We call the set of open assumptions at a node the <b>context</b>. A context is a set
</p>
\begin{equation*}
u_1:A_1,u_2:A_2,\dots,u_n:A_n
\end{equation*}
<p>
where \(u_i\) are pairwise distinct; the \(A_i\) need not be distinct. The
deductions now become trees where each node is labelled with a sequent of the
form \(\Gamma\Ra B\), &Gamma; is a context. Below, when writing a union of
contexts such as \(\Gamma\Delta\) (short for \(\Gamma\cup\Delta\)), it will
always be assumed that the union is <b>consistent</b>
</p>
\begin{alignat*}{2}
&u:A\Ra A\e(\text{Axiom})&&\\
&\AxiomC{$\Gamma[u:A]\Ra B$}\RightLabel{$\to$I}
\UnaryInfC{$\Gamma\Ra A\to B$}\DisplayProof&&
\AxiomC{$\Gamma\Ra A\to B$}
\AxiomC{$\Delta\Ra A$}\RightLabel{$\to$E}\BinaryInfC{$\Gamma\Delta\Ra B$}
\DisplayProof\\
&\AxiomC{$\Gamma\Ra A$}\AxiomC{$\Delta\Ra B$}\RightLabel{$\wedge$I}
\BinaryInfC{$\Gamma\Delta\Ra A\wedge B$}\DisplayProof\quad&&
\AxiomC{$\Gamma\Ra A_0\wedge A_1$}\RightLabel{$\wedge$E}
\UnaryInfC{$\Gamma\Ra A_i$}\DisplayProof\\
&\AxiomC{$\Gamma\Ra A_i$}\RightLabel{$\vee$I}
\UnaryInfC{$\Gamma\Ra A_0\vee A_1$}\DisplayProof&&
\def\defaultHypSeparation{\hskip 1pt}
\AxiomC{$\Gamma\Ra A\vee B$}
\AxiomC{$\Delta[u:A]\Ra C$}
\AxiomC{$\Delta'[v:B]\Ra C$}
\RightLabel{$\vee$E}
\TrinaryInfC{$\Gamma\Delta\Delta'\Ra C$}\DisplayProof\\
&\AxiomC{$\Gamma[x:\neg A]\Ra\bot$}\RightLabel{$\bot_\text{c}$}
\UnaryInfC{$\Gamma\Ra A$}\DisplayProof&&
\AxiomC{$\Gamma\Ra\bot$}\RightLabel{$\bot_{\text{i}}$}
\UnaryInfC{$\Gamma\Ra A$}\DisplayProof\\
&\EBA\AXC{$\Gamma\Ra[x/y]$}
\RightLabel{$\forall$I}
\UIC{$\Gamma\Ra\forall xA$}\DP&&\EBA
\AXC{$\Gamma\Ra\forall xA$}\RL{$\forall$E}
\UIC{$\Gamma\Ra A[x/t]$}\DP\\
&\EBA\AXC{$\Gamma\Ra A[x/t]$}
\RL{$\exists$I}\UIC{$\Gamma\Ra\exists xA$}\DP&&
\EBA\AXC{$\Gamma\Ra\exists yA[x/y]$}
\AXC{$\Delta[u:A]\Ra C$}\RL{$\exists$E}
\BIC{$\Gamma\delta\Ra C$}\DP
\end{alignat*}

<p>
Here \([u:C]\) means that the assumption \(u:C\) in the context may be present or
absent.
</p>


<div class="exercise">
<p>
Give proofs in \(\Nm\) or in \(\Ni\) of
</p>
\begin{align*}
&A\to(B\to A)\\
&(A\to A\vee B),B\to(A\vee B)\\
&(A\to C)\to[(B\to C)\to(A\vee B\to C)]\\
&A\wedge B\to A,A\wedge B\to B,A\to(B\to A\wedge B)\\
&\bot\to A\\
&\forall xA\to A[x/t];\quad A[x/t]\to\exists xA\\
&\forall x(B\to A)\leftrightarrow(B\to\forall yA[x/y])\e
(x\not\in\fv(B),y\equiv x\text{ or }y\not\in\fv(A))\\
&\forall x(A\to B)\leftrightarrow(\exists yA[x/y]\to B)\e
(x\not\in\fv(B),y\equiv x\text{ or }y\not\in\fv(A))
\end{align*}

</div>
<div class="proof">
\begin{gather*}
\EBA\AXC{$A^u$}
\RL{${\to}\text{I},v$}\UIC{$B\to A$}
\RL{${\to}\text{I},u$}\UIC{$A\to(B\to A)$}\DP\quad
\EBA\AXC{$A^u$}\RL{$\forall\text{I}_\text{R}$}
\UIC{$A\vee B$}\RL{${\to}\text{I},u$}
\UIC{$A\to (A\vee B)$}\DP
\end{gather*}

</div>

<div class="exercise">
<p>
Give proofs in \(\Nm\) of 
</p>
\begin{align*}
&A\to\neg\neg A\\
&\neg\neg\neg A\leftrightarrow\neg A\\
&\neg\neg(A\to B)\to(\neg\neg A\to\neg\neg B)\\
&\neg\neg(A\wedge B)\leftrightarrow(\neg\neg A\wedge\neg\neg B)\\
&\neg(A\vee B)\leftrightarrow(\neg A\wedge \neg B)\\
&\neg\neg\forall xA\to\forall x\neg\neg A\\
\end{align*}

</div>
<div class="proof">
\begin{gather*}
\EBA\AXC{$A\to\bot^u$}
\AXC{$A^v$}\RL{$\to$E}
\BIC{$\bot$}\RL{$\to,u$}
\UIC{$(A\to\bot)\to\bot$}\RL{$\to,v$}
\UIC{$A\to((A\to\bot)\to\bot)$}\DP\hspace{0.5cm}
\EBA\AXC{$\neg\neg\neg A^u$}
\AXC{$A^v$}
\noLine\UIC{$\cald$}\noLine\UIC{$\neg\neg A$}
\BIC{$\bot$}\DP
\end{gather*}

</div>

<div class="exercise">
<p>
Give proofs in \(\Nm\) of
</p>
<ol class="org-ol">
<li>\((B\to C)\to(A\to B)\to A\to C\) (<b>b</b>-axioms)</li>
<li>\((A\to B\to C)\to B\to A\to C\) (<b>c</b>-axioms)</li>
<li>\((A\to A\to B)\to A\to B\) (<b>w</b>-axioms)</li>
</ol>

</div>

<div class="exercise">
<p>
Prove in \(\Ni\) \((\neg\neg A\to\neg\neg B)\to\neg\neg(A\to B)\)
</p>

</div>
<div class="proof">
\begin{gather*}
\EBA\AXC{$(A\to B)\to\bot^v$}
\AXC{$\cald$}\noLine\UIC{$B\to(A\to B)$}
\AXC{$B^u$}
\BIC{$A\to B$}
\BIC{$\bot$}\RL{$\to,u$}
\UIC{$B\to\bot$}\DP
\end{gather*}

</div>

<div class="exercise">
<p>
Prove in \(\Nc\)
</p>
<ol class="org-ol">
<li>\(A\vee B\leftrightarrow\neg(\neg A\wedge\neg B)\)</li>
<li>\(\exists xA\leftrightarrow\neg\forall x\neg A\)</li>
<li>\(((A\to B)\to A)\to A\) (Peirce's law)</li>
</ol>

</div>
<div class="proof">
\begin{gather*}
\EBA\AXC{$(\neg A\wedge\neg B)\to\bot^u$}
\AXC{$(\neg(A\vee B))^v$}
\noLine\UIC{$\cald$}\noLine
\UIC{$(\neg A\wedge\neg B)$}
\BIC{$\bot$}
\UIC{$A\vee B$}\DP
\end{gather*}

</div>
<div class="exercise">
<p>
Construct in \(\tonm\) a proof of
</p>
\begin{equation*}
((A\to B)\to C)\to(A\to C)\to C
\end{equation*}
<p>
from two instances of Peirce's law as assumptions: \(((A\to B)\to A)\to A\) and 
\(((C\to A)\to C)\to C\)
</p>

</div>

<div class="exercise">
<p>
Derive in \(\tonm\) \(P_{A,B\wedge C}\) from \(P_{A,B}\) and \(P_{A,C}\) where
\(P_{X,Y}\) is \(((X\to Y)\to X)\to X\)
</p>

</div>

<div class="exercise">
<p>
Let \(F[*],G[*]\) be a positive and negative context respectively. Prove in
\(\Nm\) that
</p>
\begin{align*}
&\vdash\forall\overrightarrow{x}(A\to B)\to(F[A]\to F[B])\\
&\vdash\forall\overrightarrow{x}(A\to B)\to(G[A]\to G[B])\\
\end{align*}
<p>
where \(\overrightarrow{x}\) consists of the variables in \(A\to B\) becoming
bound by substitution of \(A\) and \(B\) into \(F[*]\) in the first line, and into
\(G[*]\) in the second line
</p>

</div>
</div>
</div>
<div id="outline-container-orgef2c6a3" class="outline-4">
<h4 id="orgef2c6a3"><span class="section-number-4">2.1.2</span> The Complete Discharge Convention</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: A. S. Troelstra and H. Schwichtenberg</p>
<p class="date">Created: 2020-01-17 五 21:59</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
