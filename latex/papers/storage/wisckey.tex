% Created 2024-04-25 Thu 13:34
% Intended LaTeX compiler: xelatex
\documentclass[11pt]{article}
\usepackage{hyperref}
\input{/Users/wu/notes/preamble.tex}
\graphicspath{{../../../paper/storage/}}

%% ox-latex features:
%   !announce-start, !guess-pollyglossia, !guess-babel, !guess-inputenc, caption,
%   underline, image, !announce-end.

\usepackage{capt-of}

\usepackage[normalem]{ulem}

\usepackage{graphicx}

%% end ox-latex features


\author{wu}
\date{\today}
\title{WiscKey: Separating Keys from Values in SSD-Conscious Storage}
\hypersetup{
 pdfauthor={wu},
 pdftitle={WiscKey: Separating Keys from Values in SSD-Conscious Storage},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.1 (Org mode 9.7-pre)}, 
 pdflang={English}}
\begin{document}

\maketitle
\section{Abstract}
\label{sec:org61a1e88}
WiscKey is a persistent LSM-tree-based key-value store with a performance-oriented data layout that
\textbf{separates keys from values to minimize I/O amplification}.
\section{Introduction}
\label{sec:orgfb65a28}
As compared to HDDs, SSDs are fundamentally different in their performance and reliability
characteristics; when considering key-value storage system design, we believe the following three
differences are of paramount importance:
\begin{enumerate}
\item the difference between random and sequential performance is not nearly as large as with HDDs; thus,
an LSM-tree that performs a large number of sequential I/Os to reduce later random I/Os may be
wasting bandwidth needlessly
\item Second, SSDs have a large degree of internal parallelism; an LSM built atop an SSD must be
carefully designed to harness said parallelism
\item Third, SSDs can wear out through repeated writes; the high write ampliﬁcation in LSM-trees can
signiﬁcantly reduce device lifetime.
\end{enumerate}

The combination of these factors greatly impacts LSM-tree performance on SSDs, reducing throughput by
90\% and increasing write load by a factor over 10.

The central idea behind WiscKey is the separation of keys and values; only keys are kept sorted in the
LSM-tree, while values are stored separately in a log.
\begin{enumerate}
\item reduce write amplification by avoiding the unnecessary movement of values while sorting
\item decrease size of the LSM-tree
\end{enumerate}

Separating keys from values introduces a number of challenges and optimization opportunities
\begin{enumerate}
\item range query (scan) performance may be affected because values are not stored in sorted order
anymore.

WiscKey solves this challenge by using the abundant internal parallelism of SSD devices.

\item WiscKey needs garbage collection to reclaim the free space used by invalid values.

WiscKey proposes an online and lightweight garbage collector which only involves sequential I/Os
and impacts the foreground workload minimally.
\item separating keys and values makes crash consistency challenging;

WiscKey leverages an interesting property in modern ﬁle systems, that appends never result in
garbage data on a crash.
\end{enumerate}
\section{Background and Motivation}
\label{sec:org71ee783}
\subsection{Write and Read Amplification}
\label{sec:orge6aae86}
\begin{table}[htbp]
\caption{Write and Read Amplification}
\centering
\begin{tabular}{lrr}
Data Size & Write Amplification & Read Amplification\\
\hline
1GB & 3.1 & 8.2\\
100GB & 14 & 327\\
\end{tabular}
\end{table}
\subsection{Fast Storage Hardware}
\label{sec:orgccc720a}
\begin{center}
\includegraphics[width=.7\textwidth]{../../images/db/15.png}
\captionof{figure}{\label{fig1}Sequential and Random Reads on SSD}
\end{center}
\section{WiscKey}
\label{sec:orge7a286c}
To realize an SSD-optimized key-value store, WiscKey includes four critical ideas:
\begin{enumerate}
\item separate keys and values
\item to deal with unsorted values, WiscKey uses the parallel random-read characteristic of SSD devices
as shown in Figure \ref{fig1}.
\item WiscKey utilizes unique crash-consistency and garbage-collection techniques to efficiently manage
the value log.
\item removing the LSM-tree log without sacrificing consistency.
\end{enumerate}
\subsection{Design Goals}
\label{sec:orgf1c3f5a}
\subsection{Key-Value Separation}
\label{sec:org7be21a8}
Compaction only needs to sort keys, while values can be managed separately.
\subsection{Challenges}
\label{sec:orgd6e255e}
\subsubsection{Parallel Range Query}
\label{sec:org6cba5ac}
Based on Figure \ref{fig1}, parallel random reads with a fairly large request size can fully utilize the
device's internal parallelism, getting performance similar to sequential reads.

To make range queries efﬁcient, WiscKey leverages the parallel I/O characteristic of SSD devices to
prefetch values from the vLog during range queries.
\subsubsection{Garbage Collection}
\label{sec:orgb21fa57}
In WiscKey, only invalid keys are reclaimed by the LSM-tree compaction. Since WiscKey does not compact
values, it needs a special garbage collector to reclaim free space in the vLog.

We introduce a small change to WiscKey’s basic data layout: while storing values in the vLog, we also
store the corresponding key along with the value. The new data layout is shown in Figure \ref{fig5}: the
tuple \texttt{(key size, value size, key, value)} is stored in the vLog.

\begin{center}
\includegraphics[width=.7\textwidth]{../../images/db/16.png}
\captionof{figure}{\label{fig5}WiscKey New Data Layout for Garbage Collection}
\end{center}

WiscKey's garbage collection aims to keep valid values in a \uline{contiguous range} of tghe vLog, as shown in
Figure \ref{fig5}. \textbf{head} always corresponds to the end of the vLog where new values will be appended.
\textbf{tail} is where garbage collection starts freeing space whenever it is triggered. Only the part of the
vLog between the head and the tail contains valid values and will be searched during lookups.

During garbage collection, WiscKey first reads a chunk of key-value pairs from the tail of the vLog,
then finds which of those values are valid by querying the LSM-tree. WiscKey then appends valid values
back to the head of the vLog. Finally, it frees the space occupied previously by the chunk, and
updates the tail accordingly.

To avoid losing any data if a crash happens, WiscKey has to make sure that the newly appended valid
values and the new tail are persistent on the device before actually freeing space. WiscKey achieves
this using the following steps.
\begin{enumerate}
\item After appending the valid values to the vLog, the garbage collection calls a \texttt{fsync()} on the vLog.
\begin{quote}
Calling \texttt{fsync()} does not necessarily ensure that the entry in the
directory containing the file has also reached disk.  For that an
explicit \texttt{fsync()} on a file descriptor for the directory is also needed.
\end{quote}
\item it adds these new values' addresses and current tail to the LSM-tree in a synchronous manner; the
tail is stored in the LSM-tree as \texttt{<tail, tail-vLog-offset>}
\item the free space in the vLog is reclaimed.
\end{enumerate}
\end{document}
