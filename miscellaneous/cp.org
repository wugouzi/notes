#+title: Competitive programming

#+EXPORT_FILE_NAME: ../latex/cp/cp.tex
#+LATEX_HEADER: \AddToHook{cmd/section/before}{\clearpage}
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \makeindex
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \renewcommand*{\proofname}{Solution}
#+LATEX_HEADER: \let\OldTexttt\texttt
#+LATEX_HEADER: \renewcommand{\texttt}[1]{\OldTexttt{\color{MidnightBlue} #1}}

* Dynamic Programming
** General
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/find-all-good-indices/}{LeetCode: Find All Good Indices}]
    #+BEGIN_problem
    You are given a /0-indexed/ integer array nums of size \(n\) and a positive integer \(k\).

    We call an index \(i\) in the range \(k\le i< n-k\) good if the following conditions are satisfied:
    * The \(k\) elements that are just before the index \(i\) are in non-increasing order.
    * The \(k\) elements that are just after the index \(i\) are in non-decreasing order.

    Return an array of all good indices sorted in increasing order.
    #+END_problem

    #+BEGIN_proof
    For \(j\), suppose the non-increasing elements before \(j\) (including \(j\)) is \(left_j\), the
    non-decreasing elements after \(j\) (including \(j\)) is \(right_j\), then \(i\) is good iff
    \(left_{i-1}\ge k\) and \(right_{i+1}\ge k\)
    #+END_proof

    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/get-kth-magic-number-lcci/}{LeetCode: Get Kth Magic Number}]
    #+BEGIN_problem
    Design an algorithm to find the kth number such that the only prime factors are 3, 5, and 7.
    Note that 3, 5, and 7 do not have to be factors, but it should not have any other prime factors.
    For example, the first several multiples would be (in order) 1, 3, 5, 7, 9, 15, 21.
    #+END_problem

    #+BEGIN_proof
    We can use heap: for each element \(x\) took out, add \(3x,5x,7x\) into the heap. Also we need
    to eliminate the duplicates

    Define \(dp[i]\) is the \(i\)th number, so \(dp[1]=1\), and let \(p_3=p_5=p_7=1\) initially, then
    for \(2 \le i\le k\)
    \begin{equation*}
    dp[i]=\min(dp[p_3]\cdot 3, dp[p_5]\cdot 5, dp[p_7]\cdot 7)
    \end{equation*}
    and increment the corresponding \(p_k\) where \(k\in\{3,5,7\}\)
    #+END_proof

    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/remove-boxes/}{LeetCode: Remove Boxes}]
    #+BEGIN_problem
    You are given several boxes with different colors represented by different positive numbers.

    You may experience several rounds to remove boxes until there is no box left. Each time you can
    choose some continuous boxes with the same color (i.e., composed of \(k\) boxes, \(k\ge 1\)), remove
    them and get \(k^2\) points.

    /Return the maximum points you can get./
    #+END_problem

    #+BEGIN_proof
    Let \(dp(l,r,k)\) denote the maximum points we can get in boxes \([l,r]\) if we have extra \(k\)
    boxes which is the same color with \(boxes[l]\) in the left side.

    For example, if ~boxes=[3,3,1,3,3]~, then \(dp(3,4,2)\) is the maximum we can get in ~boxes[3,4]~ if
    we have extra 2 boxes the same color with ~boxes[3]~ in the left side

    Since \((a+b)^2>a^2+b^2\) where \(a>0,b>0\), it's better to greedy to remove all contiguous boxes
    of the same color, instead of split them. So we increase both \(l\) and \(k\) while
    ~boxes[l+1]==boxes[l]~

    Now we have some options:
    * remove all boxes which has the same color with boxes \(l\), total points we can get is
      \(dp(l+1,r,0)+(k+1)^2\)
    * merge non-contiguous boxes of the same color together, by
      * find the index \(j\) where \(l+1\le j\le r\) so that ~boxes[j]==boxes[l]~
      * total points we can get is \(dp(j,r,k+1)+dp(l+1,j-1,0)\)

    #+ATTR_LATEX: :width .6\textwidth
    #+NAME:
    #+CAPTION:
    [[../images/cp/1.png]]
    #+END_proof

    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/k-inverse-pairs-array/}{LeetCode: K Inverse Pairs Array}]
    #+BEGIN_problem
    For an integer array nums, an *inverse pair* is a pair of integers \((i,j)\)
    where \(0\le i<j<len(nums)\) and \(nums[i]>nums[j]\)

    Given two integers \(n\) and \(k\), return the number of different arrays consist of numbers
    from 1 to \(n\) such that there are exactly \(k\) inverse pairs. Since the answer can be huge,
    return it modulo \(10^9+7\).

    #+END_problem

    #+BEGIN_proof
    Let \(f(i,j)\) denote the number of different arrays consisting of numbers from 1 to \(i\) s.t.
    there are exactly \(j\) inverse pairs.

    Suppose we fix \(k\) as the last element of the array, then the number of inverse pairs is the sum of
    * the inverse pairs between \(k\) and other numbers
    * the inverse pairs among other numbers

    The first part is \(i-k\), therefore the second part should be \(j-(i-k)\).
    \begin{equation*}
    f(i,j)=\sum_{k=1}^if(i-1,j-(i-k))=\sum_{k=0}^{i-1}f(i-1,j-k)
    \end{equation*}
    But the above formula's complexity is \(O(n^2k)\).

    Note that
    \begin{align*}
    f(i,j-1)&=\sum_{k=0}^{i-1}f(i-1,j-1-k)\\
    f(i,j)&=\sum_{k=0}^{i-1}f(i-1,j-k)
    \end{align*}
    Therefore
    \begin{equation*}
    f(i,j)=f(i,j-1)-f(i-1,j-i)+f(i-1,j)
    \end{equation*}
    #+END_proof


** Digit DP
    #+ATTR_LATEX: :options [LeetCode 788: Rotated Digits]
    #+BEGIN_problem
    An integer x is a *good* if after rotating each digit individually by 180 degrees, we get a valid
    number that is different  from x. Each digit must be rotated - we cannot choose to leave it alone.

    A number is valid if each digit remains a digit after rotation. For example:
    * 0, 1, and 8 rotate to themselves,
    * 2 and 5 rotate to each other (in this case they are rotated in a different direction, in other
      words, 2 or 5 gets mirrored)
    * 6 and 9 rotate to each other, and
    * the rest of the numbers do not rotate to any other number and become invalid.

    Given an integer n, return the number of good integers in the range [1, n].
    #+END_problem

    #+BEGIN_proof
    Given \(n\).
    Let \(f(pos,bound,diff)\) be the number of good numbers satisfying
    1. Only consider \(pos\)th digit and \(pos\) starts from left, which means 0th digit is the
       highest digit. And we assume the first \(pos-1\)
       digits are fixed
    2. If digits in \([0,pos-1]\) are first \(pos\) digits of \(n\), then \(bound\) is ~true~
    3. If digits in \([0,pos-1]\) has at least one 2/5/6/9, then \(diff\) is ~true~

    Therefore the answer is \(f(0, true, false)\), and the transition formula is
    \begin{equation*}
    f(pos,bound,diff)=\sum f(pos+1,bound',diff')
    \end{equation*}
    * \(bound'\) is true iff \(bound\) is true and the digit we choose is the \(pos\)th digit
      of \(n\)
    * \(diff'\) is true iff \(diff\) is true or we chose 2/5/6/9


    #+END_proof
* Graph
** Union find
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/number-of-good-paths/}{LeetCode: Number of Good Paths}]
    #+BEGIN_problem
    There is a tree (i.e. a connected, undirected graph with no cycles) consisting of \(n\) nodes
    numbered from 0 to \(n-1\) and exactly \(n - 1\) edges.

    You are given a 0-indexed integer array ~vals~ of length \(n\) where ~vals[i]~ denotes the value of the
    \(i\)th node. You are also given a 2D integer array edges where ~edges[i] = [ai,bi]~ denotes that
    there exists an undirected edge connecting nodes \(a_i\) and \(b_i\).

    A good path is a simple path that satisfies the following conditions:
    1. The starting node and the ending node have the same value.
    1. All nodes between the starting node and the ending node have values less than or equal to the
       starting node (i.e. the starting node's value should be the maximum value along the path).

    /Return the number of distinct good paths./

    Note that a path and its reverse are counted as the same path. For example, ~0 -> 1~ is considered
    to be the same as ~1 -> 0~. A single node is also considered as a valid path.
    #+END_problem

    #+BEGIN_proof
    First, to solve the problem, we can enumerate the paths from the nodes with largest ~vals~, and
    then delete these nodes and continue; this requires \(O(n^2)\) time

    If we reverse the direction, we are merging nodes with values from low to high, so what comes to
    our mind? Union find.

    For each node \(s\) and its neighbor \(t\):
    1. if ~vals[s]<vals[t]~, then pass
    2. if ~vals[s]=vals[find[t]]~, then add ~size[find[s]]*size[find[t]]~
    3. merge ~s~ and ~t~
    #+END_proof

* Greedy
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/course-schedule-iii/}{LeetCode: Course Schedule \rom{3}}]
    #+BEGIN_problem
    There are \(n\) different online courses numbered from 1 to \(n\). You are given an array courses where
    \(courses[i]=[duration_i,lastDay_i]\) indicate that the \(i\)th course should be taken continuously for
    \(duration_i\) days and must be finished before or on \(lastDay_i\)

    You will start on the 1st day and you cannot take two or more courses simultaneously.

    Return the maximum number of courses that you can take.
    #+END_problem

    #+BEGIN_proof
    For any two courses \((t_1,d_1)\) and \((t_2,d_2)\), if \(d_1\le d_2\), then it's optimal to study the
    first before the latter. Then "we can study 2 and then 1" always implies "we can study 1 and
    then 2"

    Now we prove by induction.

    Given \(i\) courses, sort them by lastDay. Suppose we choose \(k\) courses \((t_{x_1},d_{x_1}),(t_{x_2},d_{x_2}),\dots,(t_{x_k},d_{x_k})\) where \(x_1<x_2<\dots<x_k\) from
    the first \(i-1\) courses which is optimal for the first \(i-1\) courses. Then

    \begin{equation*}
    \begin{cases}
    t_{x_1}\le d_{x_1}\\
    t_{x_1}+t_{x_2}\le d_{x_2}\\
    \vdots\\
    t_{x_1}+\dots+t_{x_k}\le d_{x_k}
    \end{cases}
    \end{equation*}
    Then we can build the optimal plan for the first \(i\) courses based on this and \((t_i,d_i)\)
    * if \(t_1+\dots+t\)
    #+END_proof

* General
** Intervals
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/count-days-spent-together/}{LeetCode: Count Days Spent Together}]
    #+BEGIN_problem
    Alice and Bob are traveling to Rome for separate business meetings.

    You are given 4 strings ~arriveAlice~, ~leaveAlice~, ~arriveBob~, and ~leaveBob~. Alice will be in the
    city from the dates ~arriveAlice~ to ~leaveAlice~ (inclusive), while Bob will be in the city from
    the dates ~arriveBob~ to ~leaveBob~ (inclusive). Each will be a 5-character string in the format
    "MM-DD", corresponding to the month and day of the date.

    Return the total number of days that Alice and Bob are in Rome together.

    You can assume that all dates occur in the same calendar year, which is not a leap year. Note
    that the number of days  per month can be represented as: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31].

    #+END_problem

    #+BEGIN_proof
    First we can convert the string to \(i\)th day of the year, then Alice's interval is \([a,b]\),
    Bob's interval is \([c,d]\), then we need to calculate the intersection of these intervals.

    \([a,b]\cap[c,d]\neq\emptyset\) iff \(b\ge c\wedge d\ge a\).

    \([a,b]\cap[c,d]=\min(b,d)-\max(a,c)+1\)
    #+END_proof

** Bit operation
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/missing-two-lcci/}{Leetcode: Missing Two LCCI}]
    #+BEGIN_problem
    You are given an array with all the numbers from 1 to N appearing exactly once, except for two
    number that is missing. How can you find the missing number in \(O(N)\) time and \(O(1)\) space?

    You can return the missing numbers in any order.

    | Input | Output |
    |-------+--------|
    | ~[1]~   | ~[2,3]~  |
    | ~[2,3]~ | ~[1,4]~  |


    ~nums.length <= 30000~

    #+END_problem

    #+BEGIN_proof
    Suppose the missing two numbers are \(x_1\) and \(x_2\), and if we add \(1,\dots,N\) to the end of the
    array \(A\), then \(x=\bigoplus A=x_1\oplus x_2\).

    By ~x&-x~ we can get the lowest bit of \(x\), assume it's in \(l\)th bit. Then we can
    assume \(x_1\)'s \(l\)th bit is 0, and \(x_2\)'s \(l\)th bit is 1, and we can partition \(A\) into
    \(A_1\) and \(A_2\) by whether the elements' \(l\)th bit is 1, then \(\bigoplus A_1=x_1\) and \(\bigoplus A_2=x_2\)
    #+END_proof

    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/}{LeetCode: Find a Value of a Mysterious Function Closest to Target}]
    #+BEGIN_problem
    ​
    #+begin_src c++
func(arr, l, r) {
  if (r < l) {
    return -10000000000;
  }
  ans = arr[l];
  for (i = l + 1; i <= r; i++) {
    ans = ans & arr[i];
  }
  return ans;
}
    #+end_src
    Winston was given the above mysterious function ~func~. He has an integer array ~arr~ and an integer
    ~target~ and he wants to find the values ~l~ and ~r~ that make the value ~|func(arr, l, r) - target|~
    minimum possible.

    Return the minimum possible value of ~|func(arr, l, r) - target|~.

    Notice that func should be called with the values l and r where ~0 <= l, r < arr.length~.

    Constraints:
    * ~1 <= arr.length <= 10^5~
    * ~1 <= arr[i] <= 10^6~
    * ~0 <= target <= 10^7~
    #+END_problem

    #+BEGIN_proof
    If we fix \(r\)
    * \(f\) is a non-decreasing function
    * there is at most 20 different values for \(f(arr,l,r)\) as \(arr[r]\le 10^6<2^{20}\), since from
      right to left, 0 won't be transformed into 1
    #+END_proof

    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/}{LeetCode: Smallest Subarrays With Maximum Bitwise OR}]
    #+BEGIN_problem
    You are given a /0-indexed/ array nums of length \(n\), consisting of non-negative integers. For
    each index \(i\) from 0 to \(n-1\), you must determine the size of the minimum sized non-empty
    subarray of nums starting at \(i\) (inclusive) that has the maximum possible bitwise OR.

    Return an integer array answer of size \(n\) where answer[i] is the length of the minimum sized subarray
    starting at \(i\) with maximum bitwise OR.

    A subarray is a contiguous non-empty sequence of elements within an array.
    #+END_problem

    #+BEGIN_proof
    Induction and we build a new array \(A=\{a_i:a_i=nums[i]\}\). In the \(i\)th round, for
    each \(j<i\), check whether \(a_j|a_i>a_j\). If so, \(a_j|a_i\) is the new possible maximum
    for \(a_j\) and the possible \(answer[j]\ge i-j+1\).

    If \(a_j|a_i=a_j\), then \(a_i\subseteq a_j\) in the sense of bits and for
    each \(k<j\), \(a_k|a_i=a_k|a_j\). So we don't need to consider \(k<j\)
    #+END_proof
** Hard to say
    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/minimum-money-required-before-transactions/}{LeetCode: Minimum Money Required Before Transactions}]
    #+BEGIN_problem
    You are given a 0-indexed 2D integer array transactions, where ~transactions[i] = [costi, cashbacki]~.

    The array describes transactions, where each transaction must be completed exactly once in some
    order. At any given moment, you have a certain amount of money. In order to complete transaction
    \(i\), ~money >= cost_i~ must hold true. After performing a transaction, money becomes ~money-cost_i+cashback_i~.

    Return the minimum amount of money required before any transaction so that all of the
    transactions can be completed regardless of the order of the transactions.
    #+END_problem

    #+BEGIN_proof
    The worst case is, we put money-losing transaction first and then put the transaction with
    highest cost after it (erase the transaction before if necessary, and assume its index is \(i\))

    Suppose \(total\) is the total lose, then if the transaction is money-losing, then the money we need is
    \begin{equation*}
    total-(cost[i]-cashback[i])+cost[i] = total+cashback[i]
    \end{equation*}
    Otherwise
    \begin{equation*}
    total+cost[i]
    \end{equation*}
    #+END_proof


    #+ATTR_LATEX: :options [\href{https://leetcode.cn/problems/sparse-similarity-lcci/}{LeetCode: Sparse Similarity}]
    #+BEGIN_problem
    The similarity of two documents (each with distinct words) is defined to be the size of the
    intersection divided by the size of the union. For example, if the documents consist of
    integers, the similarity of {1, 5, 3} and {1, 7, 2, 3} is 0.4, because the intersection has size
    2 and the union has size 5. We have a long list of documents (with distinct values and each with
    an associated ID) where the similarity is believed to be "sparse". That is, any two arbitrarily
    selected documents are very likely to have similarity 0. Design an algorithm that returns a list
    of pairs of document IDs and the associated similarity.

    Input is a 2D array docs, where docs[i] is the document with id i. Return an array of strings,
    where each string represents a pair of documents with similarity greater than 0. The string
    should be formatted as  {id1},{id2}: {similarity}, where id1 is the smaller id in the two
    documents, and similarity is the similarity rounded to four decimal places. You can return the
    array in any order.

    return in any order.

    #+END_problem

    #+BEGIN_proof
    Assume we have \(D\) documents and each document has at most \(W\) words

    Brute force: given two documents \(A, B\), answer
    is \((\abs{A}+\abs{B}-\abs{A\cup B})/\abs{A\cup B}\), \(O(D^2W)\)

    We use inverted index to optimize \(D^2\). We can build a hash table with key the elements of
    documents and the value the index of the document.

    Then to find the document with similarity > 0 with \(A\), we only need to check the hash value
    for each element of \(A\)
    #+END_proof
