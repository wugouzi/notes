#+title: Job Preparation

* OS
** 进程管理
*** 如何避免死锁
    死锁的条件：
    * 互斥条件：多个线程不能同时使用同一个资源
    * 持有并等待条件：线程A在等待资源2的同时不会释放子集已经持有的资源1
    * 不可剥夺条件：资源在自己使用完之前不能被其他线程获取
    * 环路等待条件：


    避免死锁的发生：资源有序分配（相同顺序获取资源）
** 调度算法
    * FCFS(First Come First Serve)
** 文件系统
*** I/O
    I/O分为两个过程：
    1. 数据准备的过程
    2. 数据从内核空间拷贝到用户进程缓冲区的过程
    阻塞I/O会阻塞1、2，非阻塞I/O和基于非阻塞I/O的多路复用只会阻塞2，

    异步I/O 1和2都不阻塞
*** 多路复用
    TCP四元组：本机IP，本机端口，对端IP，对端端口

    多路复用：一个进程/线程维护多个socket

    select 实现多路复用的方式是，将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将
    文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描
    述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合
    拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。

    poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了
    select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

    第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过
    epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。
    而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以
    select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所
    有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存
    分配。

    第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生
    时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事
    件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效
    率。
* 网络
** 基础
    TCP/IP网络通常分为四层
    * 应用层：
    * 传输层：
    * 网络层
    * 网络接口层：

    键入网址到网页显示，期间发生了什么：
    1. 浏览器解析URL，生成发送给服务器的请求信息
    2. 向DNS服务器查询服务器域名对应的IP地址
    3. TCP
    4. IP远程定位
    5. 利用ARP协议获得目标的MAC地址：
       MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包
       到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。
    6. 网卡将数字信息转换为电信号
    7. 交换机
    8. 路由器


    | OSI      | TCP/IP   |
    |----------+----------|
    | 应用层     |          |
    | 表示层     | 应用层     |
    | 会话层     |          |
    |----------+----------|
    | 传输层     | 传输层     |
    |----------+----------|
    | 网络层     | 网络层     |
    |----------+----------|
    | 数据链路层 | 网络接口层 |
    | 物理层     |          |
    |----------+----------|
** HTTP
*** 常见面试题
**** 基本概念
    |     |                                     | 常见状态码         |
    | 1xx | 提示信息                              |                  |
    | 2xx | 成功，报文已经收到并被正确处理            | 200，204，206     |
    | 3xx | 重定向，资源位置发生变动，需要客户端重发请求 | 301，302，304     |
    | 4xx | 客户端错误，请求报文有误，服务器无法处理    | 400，403，404     |
    | 5xx | 服务器错误，服务器在处理请求时内部发生了错误 | 500，501，502，503 |

    常见字段
    * ~Host~: 服务器域名
    * ~Content-Length~: 回应的数据长度
    * ~Connection~: ~Keep-Alive~, 长连接
    * ~Connection-Type~: 本次数据是什么格式

    HTTP缓存：
    * 强制缓存：强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存
      的主动性在于浏览器这边。利用 ~Cache-Control~ 和 ~Expires~ 看是否过期
    * 协商缓存：协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。
