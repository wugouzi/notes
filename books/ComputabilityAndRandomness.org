#+TITLE: Computability and Randomness
#+AUTHOR: Andre Nies

#+EXPORT_FILE_NAME: ../latex/ComputabilityAndRandomness/ComputabilityAndRandomness.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \DeclareMathOperator{\use}{\textsf{use}}
#+LATEX_HEADER: \DeclareMathOperator{\Cop}{Cop}
#+LATEX_HEADER: \makeindex

* The complexity of sets
** The basic concepts
*** Partial computable functions
    Given expression \alpha, \beta,
    \begin{equation*}
    \alpha\simeq\beta
    \end{equation*}
    means that either both expressions are undefined, or they are defined with the same value

    The function \(\Xi(e,x)\simeq\Phi_e(x)\). A Turing program computing \Xi is called a *universal Turing program*

    #+ATTR_LATEX: :options [Parameter Theorem]
    #+BEGIN_theorem
    For each partial computable function \Theta in two variables there is a computable strictly
    increasing function \(q\) s.t.
    \begin{equation*}
    \forall e\forall x\Phi_{q(e)}(x)\simeq\Theta(e,x)
    \end{equation*}
    An index for \(q\) can be obtained effectively from an index for \Theta
    #+END_theorem

    #+ATTR_LATEX: :options [Padding Lemma]
    #+BEGIN_lemma
    For each \(e\) and each \(m\), one may effectively obtain \(e'>m\) s.t. the Turing
    program \(P_{e'}\) behaves exactly like \(P_e\)
    #+END_lemma

    #+ATTR_LATEX: :options [Recursion Theorem]
    #+BEGIN_theorem
    label:1.1.5
    Let \(g:\N\to\N\) be computable. Then there is an \(e\) s.t. \(\Phi_{g(e)}=\Phi_e\). We say that \(e\) is a
    *fixed point* for \(g\)
    #+END_theorem

    #+BEGIN_proof
    There is \(q\) s.t. \(\Phi_{q(e)}(x)\simeq\Phi_{g(\Phi_e(e))}(x)\) for all \(e,x\). Choose an \(i\)
    s.t. \(q=\Phi_i\), then
    \begin{equation*}
    \Phi_{q(i)}=\Phi_{\Phi_i(i)}=\Phi_{g(\Phi_i(i))}
    \end{equation*}
    #+END_proof

    #+ATTR_LATEX: :options [Recursion Theorem with Parameters]
    #+BEGIN_theorem
    label:1.1.6
    Let \(g:\N^2\to\N\) be computable. Then there is a computable function \(f\), which can be obtained
    effectively from \(g\), s.t. \(\Phi_{g(f(n),n)}=\Phi_{f(n)}\) for each \(n\)
    #+END_theorem

    #+BEGIN_proof
    There is \(g_n\) s.t. \(g_n(f(n))=g(f(n),n)\). Then let \(f(n)\) be the fixed point of \(\Phi_{g'(x)}\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.7
    Extend the Recursion Theorem by showing that computable function \(g\) has infinitely many fixed
    points. Conclude that the function \(f\) in Theorem ref:1.1.6 can be chosen one-one
    #+END_exercise

    #+BEGIN_proof
    There is infinite many \(i\) s.t. \(q=\Phi_i\)
    #+END_proof
*** Computably enumerable sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\subseteq\N\) is *computably enumerable* (*c.e.*) if \(A\) is the domain of some partial computable function
    #+END_definition

    Let
    \begin{equation*}
    W_e=\dom(\Phi_e)
    \end{equation*}
    Then \((W_e)_{e\in\N}\) is an effective listing of all c.e. sets. A sequence of sets \((S_e)_{e\in\N}\)
    s.t. \(\{\la e,x\ra:x\in S_e\}\) is c.e. is called *uniformly computably enumerable*

    \(A\) is called *computable* if its characteristic function is computable; otherwise \(A\) is
    called *incomputable*

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computable \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e.
    #+END_proposition

    We may obtain a c.e. incomputable set denoted \(\emptyset'\) by a direct diagonalization. We
    define \(\emptyset'\) in such a way that \(\N-\emptyset'\) differs from \(W_e\) at \(e\): let
    \begin{equation*}
    \emptyset'=\{e:e\in W_e\}
    \end{equation*}
    The set \(\emptyset'\) is called the *halting problem*, since \(e\in\emptyset'\) iff program \(P_e^1\) halts on input \(e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    The set \(\emptyset'\) is c.e. but not computable
    #+END_proposition

    #+BEGIN_proof
    \(\emptyset'\) is c.e. since \(\emptyset'=\dom(J)\), where \(J\) is the partial computable function given
    by \(J(e)\simeq\Phi_e(e)\). If \(\emptyset'\) is computable then there is \(e\) s.t. \(\N-\emptyset'=W_e\).
    Then \(e\in\emptyset'\leftrightarrow e\in W_e\leftrightarrow e\in\emptyset'\), a contradiction
    #+END_proof

    The sequence \((W_e)_{e\in\N}\) is universal for uniformly c.e. sequences

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    For each uniformly c.e. sequence \((A_e)_{e\in\N}\) there is a computable function \(q\)
    s.t. \(A_e=W_{q(e)}\) for each \(e\)
    #+END_corollary

    #+BEGIN_proof
    Define the partial computable function \Theta by \(\Theta(e,x)\simeq 0\) iff \(x\in A_e\), and \(\Theta(e,x)\) is
    undefined otherwise. Then the function \(q\) obtained by the Parameter Theorem is as required.
    #+END_proof

    #+BEGIN_exercise
    label:1.1.12
    Suppose \((\hatW_e)_{e\in\N}\) is a further universal uniformly c.e. sequence. Assume
    that \((\hatW_e)_{e\in\N}\) also has the padding property, one may effectively obtain \(e'>m\)
    s.t. \(\hatW_e'=\hatW_e\). Show that there is a computable permutation \pi of \(\N\)
    s.t. \(\hatW_e=W_{\pi(e)}\) for each \(e\)
    #+END_exercise

    #+BEGIN_proof
    there is \(q\) s.t. \(W_{q(e)}=\hatW_e\), there is \(p\) s.t. \(\hatW_{p(e)}=W_e\)
    Find
    1. \(q'(e)>e\)
    2. \(q'\) is 1-1
    3. \(W_{q'(e)}=\hatW_e\)


    padding \(\pi(m,e)>m\). \(W_{\pi(e,q(e))}=W_{q(e)}\)

    similar to cantor-bernstein

    or back-and-forth
    #+END_proof
*** Indices and approximations
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write
    \begin{equation*}
    \Phi_{e,s}(x)=y
    \end{equation*}
    if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\) yields \(y\) in at
    most \(s\) computation steps. Let \(W_{e,s}=\dom(\Phi_{e,s})\)
    #+END_definition

    At stage \(s\) we have complete information about \(\Phi_{e,s}\) and \(W_{e,s}\). To state this
    more formally, we need to specify an effective listing \(D_0,D_1,\dots\) of the finite subsets of \(\N\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(D_0=\emptyset\). If \(n>0\) has the form \(2^{x_1}+\dots+2^{x_r}\), where \(x_1<\dots<x_r\), then
    let \(D_n=\{x_1,\dots,x_r\}\). We say that \(n\) is a *strong index* for \(D_n\). For instance, \(D_5=\{0,2\}\)
    #+END_definition

    There is a computable function \(f\) s.t. \(f(e,s)\) is a strong index for \(W_{e,s}\). We think
    of a computable enumeration of a set \(A\) as an effective listing \(a_0,a_1,\dots\) of the elements
    of \(A\) in some order. To include the case that \(A\) is finite, we formalize this via an
    effective union of finite sets \((A_s)\). We view \(A_s\) as the set of elements enumerated by
    the end of stage \(s\). At certain stages we may decide not to enumerate any element

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *computable enumeration* of a set \(A\) is an effective sequence \((A_s)_{s\in\N}\) of (strong
    indices for) finite sets s.t. \(A_s\subseteq A_{s+1}\) for each \(s\) and \(A=\bigcup_sA_s\)
    #+END_definition

    Each c.e. set \(W_e\) has the computable enumeration \((W_{e,s})_{s\in\N}\). Conversely, if \(A\)
    has a computable enumeration then \(A\) is c.e., for \(A=\dom(\Phi)\) where \(\Phi\) is the partial
    computable function given by the following procedure: at stage \(s\) we let \(\Phi(x)=0\)
    if \(x\in A_s\). An *index for a c.e. set* \(A\) is a number \(e\) s.t. \(A=W_e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each computable function \Phi, \(\ran(\Phi)\) is c.e.
    #+END_proposition

    #+BEGIN_proof
    Suppose \(\Phi=\Phi_e\) and we enumerate \(A=\ran(\Phi)\). Since we have complete information
    about \(\Phi_s\) at stage \(s\), we can compute from \(s\) a strong index for \(A_s=\ran(\Phi_s)\).
    Then \((A_s)_{s\in\N}\) is the required computable enumeration of \(A\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.17
    #+END_exercise

    #+BEGIN_exercise
    label:1.1.19

    #+END_exercise

    #+BEGIN_proof
    find a subsequence with increasing required steps
    #+END_proof
** Relative computational complexity of sets


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(X\) is *many-one reducible* to \(Y\), denoted \(X\le_mY\), if there is a computable function \(f\)
    s.t. \(n\in X\leftrightarrow f(n)\in Y\) for all \(n\)
    #+END_definition

    If \(X\) is computable, \(Y\neq\emptyset\), and \(Y\neq\N\), then \(X\le_mY\): choose \(y_0\in Y\) and \(y_1\notin Y\).
    Let \(f(n)=y_0\) if \(n\in X\) and \(f(n)=y_1\) otherwise. Then \(X\le_mY\) via \(f\).

    For each set \(Y\) the class \(\{X:X\le_mY\}\) is countable. In particular, there is no greatest
    many-one degree

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.2
    \(A\) is c.e. \(\Leftrightarrow\) \(A\le_m\emptyset'\)

    An index for the many-one reduction as a computable function can be obtained effectively from a
    c.e. index for \(A\), and conversely
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): We claim that there is a computable function \(g\) s.t.
    \begin{equation*}
    W_{g(e,n)}=
    \begin{cases}
    \{e\}&n\in A\\
    \emptyset
    \end{cases}
    \end{equation*}
    For let \(\Theta(e,n,x)\) converge if \(x=e\) and \(n\in A\). Then there is a computable function \(g\)
    s.t. \(\forall e,n,x[\Theta(e,n,x)\simeq\Phi_{g(e,n)}(x)]\). By Theorem ref:1.1.6, there is a computable
    function \(h\) s.t. \(W_{g(h(n),n)}=W_{h(n)}\) for each \(n\). Then
    \begin{align*}
    &n\in A\Rightarrow W_{h(n)}=\{h(n)\}\Rightarrow h(n)\in\emptyset'\\
    &n\notin A\Rightarrow W_{h(n)}=\emptyset\Rightarrow h(n)\notin\emptyset
    \end{align*}
    \(\Leftarrow\): If \(A\le_m\emptyset'\) via \(h\), then \(A=\dom(\Psi)\) where \(\Psi(x)\simeq J(h(x))\) (recall
    that \(J(e)\simeq\Phi_e(e)\))
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A c.e. set \(C\) is called *\(r\)-complete* if \(A\le_rC\) for each c.e. set \(A\)
    #+END_definition

    we say that \(X\le_1Y\) if \(X\le_mY\) via a one-one function \(f\)

    #+BEGIN_exercise
    label:1.2.4
    The set \(\emptyset'\) is \(1\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.5
    \(X\equiv_1 Y\Leftrightarrow\) there is a computable permutation \(p\) of \(\N\) s.t. \(Y=p(X)\)
    #+END_exercise

    Our intuitive understanding of "\(Y\) is at least as complex as \(X\)" is: \(X\) can be computed
    with the help of \(Y\). To formalize more general ways of relative computation, we extend the
    machine model by a one-way infinite "oracle" tape which holds all the answers to oracle
    questions of the form "is \(k\) in \(Y\)".

    We write \(\Phi_e^Y(n)\downarrow\) if the program \(P_e\) halts when the oracle is \(Y\) and the input
    is \(n\); we write \(\Phi_e(Y;n)\) or \(\Phi_e^Y(n)\) for this output. The \(\Phi_e\) are called *Turing
    functionals*. And we let \(W_e^Y=\dom(\Phi_e^Y)\). \(W_e\) is a *c.e. operator*

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A total function \(f:\N\to\N\) is called *Turing reducible* to \(Y\), or *computable relative to* \(Y\),
    or *computable in* \(Y\), if there is an \(e\) s.t. \(f=\Phi_e^Y\). We denote this by \(f\le_TY\). We
    also say that \(Y\) *computes* \(f\). For a set \(A\), we write \(A\le_TY\) if the characteristic
    function of \(A\) is Turing reducible to \(Y\)
    #+END_definition

    For a total functions \(g\), \(f\le_Tg\) means that \(f\) is Turing reducible to the *graph*
    of \(g\), that is, to \(\{\la n,g(n)\ra:n\in\N\}\)

    #+BEGIN_exercise
    label:1.2.7
    \(\le_m\) and \(\le_T\) are preorderings of the subsets of \(\N\)
    #+END_exercise

    A set \(A\) is *c.e. relative to* \(Y\) if \(A=W_e^Y\) for some \(e\). We view \(\Phi_e\)as \(\Phi_e^{\emptyset}\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.8
    \(A\) is computable in \(Y\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(Y\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(J^Y(e)\simeq\Phi_e^Y(e)\). The set \(Y'=\dom(J^Y)\) is the *Turing jump* of \(Y\). The
    map \(Y\to Y'\) is called the *jump operator*
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    For each computable binary function \(g\) there is a computable function \(f\) s.t. \(\Phi_{g(f(n),n)}^Y=\Phi_{f(n)}^Y\)
    #+END_theorem

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.11
    \(A\) is c.e. in \(Y\) iff \(A\le_mY'\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.12
    For each \(Y\), the set \(Y'\) is c.e. relative to \(Y\). Also, \(Y\le_mY'\) and \(Y'\not\le_TY\),
    and therefore \(Y<_TY'\)
    #+END_proposition

    #+BEGIN_proof
    \(Y'\) is c.e. in \(Y\) since \(Y'=\dom(J^Y)\). As \(Y\) is c.e. relative to itself, by
    Proposition ref:1.2.11 \(Y\le_mY'\). If \(Y'\le_TT\) then there is \(e\) s.t. \(\N-Y'=W_e^Y\).
    Then \(e\in Y'\leftrightarrow e\in W_e^Y\leftrightarrow e\notin Y'\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We define \(Y^{(n)}\) inductively by \(Y^{(0)}=Y\) and \(Y^{(n+1)}=(Y^{(n)})'\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each \(Y,Z\) we have \(Y\le_TZ\Leftrightarrow Y'\le_mZ'\)
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): \(Y'\) is c.e. in \(Y\) and hence c.e. in \(Z\). Therefore \(Y'\le_mZ'\) by Proposition ref:1.2.11

    \(\Leftarrow\):By Proposition ref:1.2.8, \(Y\) and \(\N-Y\) are c.e. in \(Y\). So \(Y,\N-Y\le_mY'\le_mZ'\),
    whence both \(Y\) and \(\N-Y\) are c.e. in \(Z\). Hence \(Y\le_TZ\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    From a Turing functional \(\Phi=\Phi_e\) one can effectively obtain a computable strictly increasing
    function \(p\), called a *reduction function* for \Phi, s.t. \(\forall Y\forall x\Phi^Y(x)\simeq J^Y(p(x))\)
    #+END_fact

    #+BEGIN_proof
    Let \(\Theta^Y(x,y)\simeq\Phi^Y(x)\), by the oracle version of the Parameter Theorem there is a computable
    strictly increasing function \(p\) s.t. \(\forall Y\forall y\Phi_{p(x)}^Y(y)\simeq\Theta^Y(x,y)\simeq\Phi^Y(x)\).
    Letting \(y=p(x)\) we obtain \(J^Y(p(x))=\Phi^Y_{p(x)}(p(x))=\Phi^Y(x)\)
    #+END_proof

    We identify \(\sigma\in\{0,1\}^*\) with \(n\in\N\) s.t. the binary representation of \(n+1\) is 1\sigma. For
    instance, 000 is 7

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(\Phi_{e,s}^Y(x)=y\) if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\)
    yields \(y\) in at most \(s\) computation steps, with all oracle queries less than \(s\).
    #+END_definition

    The *use principle* is the fact that a terminating oracle computation only asks finitely many
    oracle questions. Hence \((\Phi_{e,s}^Y)_{s\in\N}\) approximates \(\Phi_e^Y\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *use* of \(\Phi_e^Y(x)\), denoted \(\use\Phi_e^Y(x)\), is defined if \(\Phi_e^Y(x)\downarrow\), where its value is
    1+the largest oracle query asked during this computation.
    #+END_definition

    We write
    \begin{equation*}
    \Phi_e^\sigma(x)=y
    \end{equation*}
    if \(\Phi_e^F(x)\) yields the output \(y\), where \(F=\{i<\abs{\sigma}:\sigma(i)=1\}\), and the use is at
    most \(\abs{\sigma}\). Then for each set \(Y\)
    \begin{equation*}
    \Phi_e^Y(x)=y\leftrightarrow\Phi_e^{Y\uhr u}(x)=y
    \end{equation*}
    where \(u=\use\Phi_e^Y(x)\)

    If a Turing functional \(\Phi_e\) is given then \(\lambda Yx.\use\Phi_e^Y\) is also a Turing functional
    (namely there is \(i\) s.t. \(\Phi_i^Y(x)\simeq\use\Phi_e^Y(x)\) for each \(Y\) and \(x\)). Thus if \(Y\)
    is an oracle s.t. \(f=\Phi_e^Y\) is total, the function \(\use\Phi_e^Y\) is computable in \(Y\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *weak truth-table* reducible to \(Y\), denoted \(f\le_{wtt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    and \(\forall n\use\Phi_e^Y(n)\le r(n)\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *truth-table* reducible to \(Y\), denoted \(f\le_{tt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    \(f=\Phi_e^Y\) and \(\Phi_e^Z\) is total for each oracle \(Z\) (we call such a \(\Phi_e\) a truth table reduction).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. \(X\le_{tt}Y\Leftrightarrow\) there is a computable function \(g\) s.t. for each \(n\),
       \begin{equation*}
       n\in X\Leftrightarrow\bigvee_{\sigma\in D_{g(n)}}[\sigma\preceq Y]
       \end{equation*}
    2. \(X\le_{tt}Y\) implies \(X\le_{wtt}Y\)
    #+END_proposition

    #+BEGIN_proof
    1. \(\Rightarrow\): Suppose \(X\le_{tt}Y\) via a truth-table reduction \(\Phi=\Phi_e\). The
       tree \(T_n=\{\sigma:\Phi^\sigma_{\abs{\sigma}}(n)\uparrow\}\) is finite for each \(n\), for otherwise it has an infinite
       path \(Z\) by KÅ‘nig's Lemma and \(\Phi^Z(n)\uparrow\). Given \(n\) one can compute a strong
       index \(\tilg(n)\) for the finite set of minimal string \sigma s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow\). Hence
       one can compute a strong index \(g(n)\) for the set of all minimal strings \sigma
       s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow=1\). Then \(D_{g(n)}\) is as required

       \(\Leftarrow\):Consider the following procedure relative to an oracle \(Z\): on input \(n\), first
       compute \(D_{g(n)}\). If \(\sigma\preceq Z\) for some \(\sigma\in D_{g(n)}\), output 1, otherwise output 0

    2. For each \(Z\) \(\use\Phi_e^Z(n)\) is bounded by \(\max\{\abs{\sigma}:\sigma\in D_{g(n)}\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.22
    \(f\le_{tt}A\Leftrightarrow\) there is a Turing functional \Phi and a computable function \(t\) s.t. \(f=\Phi^A\) and
    the number of steps needed to compute \(\Phi^A(n)\) is bounded by \(t(n)\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): Let \(\tilPhi\) be the Turing functional s.t. \(\tilPhi^Z(n)=\Phi^Z_{t(n)}(n)\) if the
    latter is defined and \(\tilPhi^Z(n)=0\) otherwise
    #+END_proof

    \begin{equation*}
    \le_m\Rightarrow\le_{tt}\Rightarrow\le_{wtt}\Rightarrow\le_T
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *effective disjoint union* of sets \(A\) and \(B\) is
    \begin{equation*}
    A\oplus B=\{2n:n\in A\}\cup\{2n+1:n\in B\}
    \end{equation*}
    #+END_definition

    #+BEGIN_exercise
    label:1.2.23
    1. \(A,B\le_mA\oplus B\)
    2. Let \(\le_r\) be one of the reducibilities above. Then for any set \(X\)
       \begin{equation*}
       A,B\le_rX\Leftrightarrow A\oplus B\le_rX
       \end{equation*}
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.24
    Let \(C=A_0\cup A_1\) where \(A_0,A_1\) are c.e. and \(A_0\cap A_1=\emptyset\). Then \(C\equiv_{wtt}A_0\oplus A_1\)
    #+END_exercise

    #+BEGIN_proof
    Since \(A_0,A_1\) are c.e., for each \(n\in C\), we can determine if \(n\in A_0\cup A_1\) in finite steps.
    #+END_proof

    #+BEGIN_exercise
    label:1.2.25
    Show that \(\exists Zf\le_{tt}Z\Leftrightarrow\) there is a computable \(h\) s.t. \(\forall nf(n)\le h(n)\)
    #+END_exercise

    #+BEGIN_proof
    Trivial
    #+END_proof
** Descriptive complexity of sets
    In a computable enumeration \((Z_s)_{s\in\N}\) of a set \(Z\), for each \(x\), \(Z_s(x)\) can
    change at most once, namely from 0 to 1. Which sets \(Z\) are described if we allow an arbitrary
    finite number of changes


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We say that a set \(Z\) is \(\Delta_2^0\) if there is a computable sequence of strong
    indices \((Z_s)_{s\in\N}\) s.t. \(Z_s\subseteq[0,s)\) and \(Z(x)=\lim_sZ_s(x)\). We say
    that \((Z_s)_{s\in\N}\) is a *computable approximation* of \(Z\)
    #+END_definition

    Given an expression \(E\) that is approximated during stages \(s\),
    \begin{equation*}
    E[s]
    \end{equation*}
    denotes its value at the *end of* stage \(s\). For instance, given a \(\Delta_2^0\) set \(Z\) with a
    computable approximation, instead of \(\Phi_{e,s}^{Z_s}(x)\) we simply write \(\Phi_e^Z(x)[s]\). We say
    that the expression \(E\) is *stable at* \(s\) if \(E[t]=E[s]\)for all \(t\ge s\)

    #+ATTR_LATEX: :options [Shoenfield Limit Lemma]
    #+BEGIN_lemma
    label:1.4.2
    \(Z\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(Z\le_T\emptyset'\). The equivalence is uniform
    #+END_lemma

    #+BEGIN_proof
    \(\Leftarrow\): Fix a Turing functional \(\Phi_e\) s.t. \(Z=\Phi_e^{\emptyset'}\). Since \(\emptyset'\) is c.e.,
    let \(\la \emptyset'_s\ra_{s\in\N}\) be a computable enumeration of \(\emptyset'\). Define
    \begin{equation*}
    Z_s(x)=
    \begin{cases}
    1&\Phi_{e,s}^{\emptyset'_s\downarrow}=1\\
    0&\text{otherwise}
    \end{cases}
    \end{equation*}
    Let \(u=\use\Phi_e^{\emptyset'}(x)\), there is \(s\) s.t. \(\emptyset'_s\uhr u=\emptyset'\uhr u\), thus there is \(s\ge t\)
    s.t. \(Z_s(x)=Z(x)\)

    Then the required approximation is
    given by \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\)

    \(\Rightarrow\): We define a c.e. set \(C\) s.t. \(Z\le_TC\). This is sufficient because \(C\le_m\emptyset'\) by
    Proposition ref:1.2.2. The set \(C\) is called the *change set* because it records the changes of
    the computable approximation. If \(Z_s(x)\neq Z_{s+1}(x)\) we put \(\la x,i\ra\) into \(C_{s+1}\),
    where \(i\) is the least s.t. \(\la x,i\ra\notin C_s\). To show that \(Z\le_TC\), on input \(x\), using the
    oracle \(C\) compute the least \(i\) s.t. \(\la x,i\ra\notin C\). If \(i\) is even then \(Z(y)=Z_0(y)\),
    otherwise \(Z(y)=1-Z_0(y)\)

    We have obtained \(C\) and the Turing reduction of \(Z\) to \(C\) effectively from the
    computable approximation of \(Z\). Proposition ref:1.2.2 is also effective
    #+END_proof

    If \(Z=\Phi_e^{\emptyset'}\) we say that \(e\) is a *\(\Delta_2^0\)-index* for \(Z\). A number \(e\) is
    a \(\Delta_2^0\) index only if \(\Phi_e^{\emptyset'}\) is total

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. We say that a set \(Z\) is *\omega-c.e.* if there is a computable
       approximation \((Z_s)_{s\in\N}\) of \(Z\) and a computable function \(b\) s.t.
       \begin{equation*}
       b(x)\ge\#\{s>x:Z_x(x)\neq Z_{s-1}(x)\}\text{ for each }x
       \end{equation*}
    2. If \(Z_s(s-1)=0\) for each \(s>0\) and \(b(x)\) can be chosen constant of value \(n\), then
       we say \(Z\) is \(n\)-c.e.
    #+END_definition

    Thus \(Z\) is 1-c.e. iff \(Z\) is c.e., and \(Z\)  is 2-c.e. iff \(Z=A-B\) for c.e. sets \(A,B\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\omega\)-c.e. \(\Leftrightarrow\) \(Z\le_{wtt}\emptyset'\) \(\Leftrightarrow\) \(Z\le_{tt}\emptyset'\)

    The equivalence are effective
    #+END_proposition

    #+BEGIN_proof
    First suppose that \(Z_{wtt}\emptyset'\) via a functional \(\Phi_e\) with computable use bound \(f\). To
    show that \(Z\) is \omega-c.e., let \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\). Since \(\Phi_e^{\emptyset'}(x)[s]\) only
    becomes undefined when a number less than \(f(x)\) enters \(\emptyset'\), the number of changes
    of \(Z_s(x)\) is bounded by \(2f(x)\)

    Now suppose that \(Z\) is \omega-c.e. via the computable approximation \((Z_s)_{s\in\N}\) and the
    function \(b\) bounding the number of changes. We show that \(Z\le_{tt}\emptyset'\). Let \(C\) be the
    change set. Since \(b(x)\ge\min\{i:\la x,i\ra\notin C\}\), the reduction of \(Z\) to \(C\) given there can be
    carried out by computing a truth-table from the input \(x\) and evaluating it on the answers to
    oracle questions to \(C\)
    #+END_proof

    #+ATTR_LATEX: :width .9\textwidth
    #+NAME:
    #+CAPTION:
    [[../images/ComputabilityAndRandomness/1.jpg]]


    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    \(A\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(A\) is both \(\Sigma_2^0\) and \(\Pi_2^0\)
    #+END_corollary

    #+BEGIN_proof
    \begin{align*}
    A\in\Delta_2^0&\Leftrightarrow A\le_T\emptyset'\\
    &\Leftrightarrow A\text{ and }\N-A\text{ are c.e. in }\emptyset'\\
    &\Leftrightarrow A\in\Sigma_2^0\cap\Pi_2^0
    \end{align*}
    last iff from Theorem ref:1.4.13
    #+END_proof


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(A\subseteq\N\) and \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\)if \(x\in A\leftrightarrow\exists y_1\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\), where \(R\) is a symbol for a
       computable relation
    2. \(A\) is \(\Pi_n^0\) if \(\N-A\) is \(\Sigma_n^0\)
    3. \(A\) is *arithmetical* if \(A\) is \(\Sigma_n^0\) for some \(n\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    label:1.4.12
    \(A\) is \(\Sigma_1^0\Leftrightarrow A\) is c.e.. The equivalence is uniform
    #+END_fact

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(x\in A\leftrightarrow\exists y R(x,y)\) for computable \(R\). Let \Phi be the partial computable
    function given by the Turing program that on input \(x\) looks for a witness \(y\)
    s.t. \(R(x,y)\), and halts when such a witness is found. Then \(A=\dom(\Phi)\)

    \(\Leftarrow\): Suppose \(A=\dom(\Phi)\) for a partial computable function \Phi. Let \(R\) be the computable
    relation given by \(R(x,s)\leftrightarrow\Phi(x)[s]\downarrow\). Then \(x\in A\leftrightarrow\exists sR(x,s)\), so \(A\) is \(\Sigma_1^0\)
    #+END_proof

    A \(\Sigma_n^0\) set \(C\) is *\(\Sigma_n^0\)-complete* if \(A\le_mC\) for each \(\Sigma_n^0\) set \(A\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:1.4.13
    Let \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\) \(\Leftrightarrow\) \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)
    2. \(\emptyset^{(n)}\) is \(\Sigma_n^0\)-complete
    #+END_theorem

    #+BEGIN_proof
    Induction on \(n\).  ref:1.4.12 and ref:1.2.2. Now let \(n>1\)
    1. First suppose \(A\) is \(\Sigma_n^0\) for some computable relation \(R\). Then the set
       \begin{equation*}
       B=\{\la x,y_1\ra:\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\}
       \end{equation*}
       is \(\Pi_{n-1}^0\) and \(A\) is c.e. relative to \(B\). By (2) for \(n-1\) we
       have \(B\le_m\N-\emptyset^{(n-1)}\). So \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)

       Now suppose \(A\) is c.e. relative to \(\emptyset^{(n-1)}\). Then there is a Turing functional \Phi
       s.t. \(A=\dom(\Phi^{\emptyset^{(n-1)}})\). By the use principle
       \begin{equation*}
       x\in A\Leftrightarrow\exists\eta,s\ucorner{\Phi_s^\eta(x)\downarrow\wedge\forall i<\abs{\eta}\;\eta(i)=1\leftrightarrow i\in\emptyset^{(n-1)}}
       \end{equation*}
       The innermost part can be put into \(\Sigma_n^0\)-form, so \(A\) is \(\Sigma_n^0\).
    2. Follows by Proposition ref:1.2.11 where \(Y=\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    Let \(n\ge 1\). Then \(A\) is \(\Delta_n^0\Leftrightarrow A\le_T\emptyset^{(n-1)}\)
    #+END_proposition

    #+BEGIN_proof
    By Theorem ref:1.4.13, \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(\emptyset^{(n-1)}\). By
    Proposition ref:1.2.8, this condition is equivalent to \(A\le_T\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\Sigma_2^0\) \(\Leftrightarrow\) there is a computable sequence of strong indices \((Z_s)_{s\in\N}\)
    s.t. \(Z_s\subseteq[0,s)\) and \(x\in Z\leftrightarrow\exists s\forall t\ge s\;Z_t(x)=1\). The equivalence is uniform
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): By Theorem ref:1.4.13, there is a Turing functional \Phi s.t. \(Z=\dom(\Phi^{\emptyset'})\). Now
    let \(Z_s=\{x<s:\Phi^{\emptyset'}(x)[s]\downarrow\}\)

    \(\Leftarrow\):
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *index set* of a class \(S\) of c.e. sets is the set \(\{i:W_i\in S\}\)
    #+END_definition


    #+BEGIN_exercise
    label:1.4.19
    \(\emptyset'\) is not an index set
    #+END_exercise

    #+BEGIN_proof
    We can find \(g\) s.t. \(W_{g(n)}=\{n\}\). Thus there is \(e\) s.t. \(W_{g(e)}=W_e=\{e\}\). By
    padding lemma, we have \(W_i=W_e\) but \(i\notin\emptyset'\)
    #+END_proof



    #+BEGIN_exercise
    label:1.4.20
    1. \(\{e:W_e\neq\emptyset\}\) is \(\Sigma_1^0\)-complete
    2. The set \(\{e:W_e\text{ finite }\}\) is \(\Sigma_2^0\)-complete.
    3. The set \(\Tot=\{e:\dom(\Phi_e)=\N\}=\{e:W_e=\N\}\) is \(\Pi_2^0\)-complete
    4. Both \(\{e:W_e\text{ cofinite}\}\) and \(\Cop=\{e:W_e\text{ computable}\}\) are \(\Sigma_3^0\)-complete
    #+END_exercise

    #+BEGIN_proof
    1. Given \(e\), \(\Phi_{f(n)}\) doesn't converge in \(\N-\{e\}\). And converges on \(e\)
       if \(\Phi_e(e)\downarrow\). Thus \(\emptyset'\le_m\{e:W_e\neq\emptyset\}\)
    2. Let \(\Fin=\{e:W_e\text{ finite}\}\). Then \(e\in\Fin\Leftrightarrow\exists s\forall t\ge s(W_{e,s}=W_{e,t})\)
    3. \(e\in\Tot\Leftrightarrow\forall n\exists s\Phi_{e,s}(n)\downarrow\)

       For any \(A\) in \(\Pi_2^0\), \(x\in A\Leftrightarrow\forall y\exists zR(x,y,z)\)

       We could define
       \begin{equation*}
       \Phi_{q(x)}(u)=
       \begin{cases}
       0&\forall y\le u\exists zR(x,y,z)\\
       \uparrow
       \end{cases}
       \end{equation*}
       Then \(x\in A\Leftrightarrow W_{q(x)}=\omega\Leftrightarrow q(x)\in\Tot\)

       \(x\in\barA\Leftrightarrow W_{q(x)}\) is finite
    4. \(e\in\Cof\Leftrightarrow\exists z\forall n\ge z\exists s\Phi_{e,s}(n)\downarrow\), thus \(\Cof\in\Sigma_3^0\)

       check fudan's textbook p120
    #+END_proof

    #+BEGIN_exercise
    label:1.4.21
    The set \(\{e:\dom\Phi_e^{\emptyset'}=\N\}\) is \(\Pi_0^3\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.4.22
    Let \(\cals\) be a class of c.e. sets [\omega-c.e. sets] containing all the finite sets. Suppose the
    index set of \(S\) is \(\Sigma_3^0\).  Then \(\cals\) is uniformly c.e. [uniformly c.e.]
    #+END_exercise

    #+BEGIN_proof
    Let \(I=\{e\mid\exists x\forall y\exists z\;R(e,x,y,.z)\}\), \(\cals=\{W_e\}_{e\in I}\)

    \(\cals\) is \(\Sigma_3^0\), \(\cals\le_m\Cof\)
    #+END_proof

    #+BEGIN_exercise
    label:1.4.24
    Let \(X\subseteq\N\)
    1. Each relation \(R\le_TX\) is first-order definable in the structure \((\N,+,\cdot ,X)\)
    2. The index set \(\{e:W_e\le_TX\}\) is \(\Sigma_3^0(X)\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.4.25
    \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(\forall x A(x)=\lim_{k_1}\dots\lim_{k_{n-1}}g(x,k_1,\dots,k_{n-1})\) for some
    computable \(\{0,1\}\)-valued function \(g\)
    #+END_exercise
** Absolute computational complexity of sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(f,g:\N\to\R\). \(f\) *dominates* \(g\) if \(f(n)\ge g(n)\) for almost every \(n\)
    #+END_definition

    1. \(A\) is *low* if \(A'\le_T\emptyset'\)
    2. \(A\) is *computably dominated* if each function \(g\le_TA\) is dominated by a computable
       function
    3. \(A\) is *high* if \(\emptyset''\le_TA'\)


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(n\ge 0\). We say that \(C\) is \(low_n\) if \(C^{(n)}\equiv_T\emptyset^{(n)}\)
    #+END_definition

    If \(C\in low_1\) we simply say that \(C\) is *low*. Each low set is \(\Delta_2^0\).

    Each class \(low_n\) is closed downward under Turing reducibility, and contained in \(\Delta_{n+1}^0\)
    \begin{equation*}
    \text{computable}\subset low_1\subset low_2\subset\dots\subset\{Z:Z\not\ge_T\emptyset'\}
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(C\) is *superlow* if \(C'\equiv_{tt}\emptyset'\)
    #+END_definition

    It suffices to require that \(C'\le_{tt}\emptyset'\), because \(\emptyset'\le_mC'\) for any \(C\) by ref:1.2.14. By
    ref:1.4.4 it is equivalent to ask that \(C'\) be \omega-c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is *generalized \(low_1\)*, or in \(\GL_1\) for short, if \(A'\equiv_TA\oplus\emptyset'\)
    #+END_definition

    #+BEGIN_exercise
    label:1.5.5
    If \(C\) is superlow, there is a computable function \(h\) s.t. \(Y\le_TC\) implies \(Y\le_{tt}\emptyset'\)
    with use function bounded by \(h\) for each \(Y\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.5.7
    If \(B\) is \(low_2\) then the index set \(\{e:W_e\le_TB\}\) is \(\Sigma_3^0\)
    #+END_exercise

    #+BEGIN_exercise
    label:1.5.8
    \(B\) is \(low_2\)\(\Leftrightarrow\) \(\Tot^B=\{e:\Phi_e^B\text{ total}\}\) is \(\Sigma_3^0\)
    #+END_exercise

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is called *computably dominated* if each function \(g\le_TA\) is dominated by a computable
    functional
    #+END_definition

    \(E\subseteq\N\)  is *hyperimmune* if \(E\) is infinite and \(p_E\) is not dominated by a computable
    function, where \(p_E\) is the listing of \(E\) in order of magnitude

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is not computably dominated \(\Leftrightarrow\) there is a hyperimmune set \(E\equiv_TA\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): immediate since \(p_E\le_TE\)

    \(\Rightarrow\): Suppose \(g\le_TA\) is not dominated by a computable function. Let \(E=\ran(h)\), where the
    function \(h\) is defined as follows: \(h(0)=0\), and for each \(n\in\N\), \(h(2n+1)=h(2n)+g(n)+1\)
    and \(h(2n+2)=h(2n+1)+p_A(n)+1\).
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computably dominated \(\Leftrightarrow\) for each function \(f\)
    \begin{equation*}
    f\le_TA\to f\le_{tt}A
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(f=\Phi^A\). Let \(g(x)=\mu s\Phi_s^A(x)\downarrow\). Then \(g\le_TA\), so there is a computable
    function \(t\) s.t. \(t(x)\ge g(x)\) for each \(x\). Thus \(t\) bounds the running time of \(\Phi^A\),
    whence \(f\le_{tt}A\) by Proposition ref:1.2.22
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    If \(A\) is \(\Delta_2^0\) and incomputable, then \(A\) is not computably dominated
    #+END_proposition

    #+BEGIN_proof
    Let \((A_s)_{s\in\N}\) be a computable approximation of \(A\). Then the following function \(g\) is
    total
    \begin{equation*}
    g(s)\simeq\mu t\ge s.A_t\uhr s=A\uhr s
    \end{equation*}
    #+END_proof
