#+TITLE: Computability and Randomness
#+AUTHOR: Andre Nies

#+EXPORT_FILE_NAME: ../latex/ComputabilityAndRandomness/ComputabilityAndRandomness.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \DeclareMathOperator{\use}{\textsf{use}}
#+LATEX_HEADER: \DeclareMathOperator{\Cop}{Cop}
#+LATEX_HEADER: \DeclareMathOperator{\pf}{pf}
#+LATEX_HEADER: \DeclareMathOperator{\non}{\textsf{non}}
#+LATEX_HEADER: \usepackage[UTF8]{ctex}
#+LATEX_HEADER: \makeindex

* The complexity of sets
** The basic concepts
*** Partial computable functions
    Given expression \alpha, \beta,
    \begin{equation*}
    \alpha\simeq\beta
    \end{equation*}
    means that either both expressions are undefined, or they are defined with the same value

    The function \(\Xi(e,x)\simeq\Phi_e(x)\). A Turing program computing \Xi is called a *universal Turing program*

    #+ATTR_LATEX: :options [Parameter Theorem]
    #+BEGIN_theorem
    For each partial computable function \Theta in two variables there is a computable strictly
    increasing function \(q\) s.t.
    \begin{equation*}
    \forall e\forall x\Phi_{q(e)}(x)\simeq\Theta(e,x)
    \end{equation*}
    An index for \(q\) can be obtained effectively from an index for \Theta
    #+END_theorem

    #+ATTR_LATEX: :options [Padding Lemma]
    #+BEGIN_lemma
    For each \(e\) and each \(m\), one may effectively obtain \(e'>m\) s.t. the Turing
    program \(P_{e'}\) behaves exactly like \(P_e\)
    #+END_lemma

    #+ATTR_LATEX: :options [Recursion Theorem]
    #+BEGIN_theorem
    label:1.1.5
    Let \(g:\N\to\N\) be computable. Then there is an \(e\) s.t. \(\Phi_{g(e)}=\Phi_e\). We say that \(e\) is a
    *fixed point* for \(g\)
    #+END_theorem

    #+BEGIN_proof
    There is \(q\) s.t. \(\Phi_{q(e)}(x)\simeq\Phi_{g(\Phi_e(e))}(x)\) for all \(e,x\). Choose an \(i\)
    s.t. \(q=\Phi_i\), then
    \begin{equation*}
    \Phi_{q(i)}=\Phi_{\Phi_i(i)}=\Phi_{g(\Phi_i(i))}
    \end{equation*}
    #+END_proof

    #+ATTR_LATEX: :options [Recursion Theorem with Parameters]
    #+BEGIN_theorem
    label:1.1.6
    Let \(g:\N^2\to\N\) be computable. Then there is a computable function \(f\), which can be obtained
    effectively from \(g\), s.t. \(\Phi_{g(f(n),n)}=\Phi_{f(n)}\) for each \(n\)
    #+END_theorem

    #+BEGIN_proof
    There is \(g_n\) s.t. \(g_n(f(n))=g(f(n),n)\). Then let \(f(n)\) be the fixed point of \(\Phi_{g'(x)}\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.7
    Extend the Recursion Theorem by showing that computable function \(g\) has infinitely many fixed
    points. Conclude that the function \(f\) in Theorem ref:1.1.6 can be chosen one-one
    #+END_exercise

    #+BEGIN_proof
    There is infinite many \(i\) s.t. \(q=\Phi_i\)
    #+END_proof
*** Computably enumerable sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\subseteq\N\) is *computably enumerable* (*c.e.*) if \(A\) is the domain of some partial computable function
    #+END_definition

    Let
    \begin{equation*}
    W_e=\dom(\Phi_e)
    \end{equation*}
    Then \((W_e)_{e\in\N}\) is an effective listing of all c.e. sets. A sequence of sets \((S_e)_{e\in\N}\)
    s.t. \(\{\la e,x\ra:x\in S_e\}\) is c.e. is called *uniformly computably enumerable*

    \(A\) is called *computable* if its characteristic function is computable; otherwise \(A\) is
    called *incomputable*

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computable \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e.
    #+END_proposition

    We may obtain a c.e. incomputable set denoted \(\emptyset'\) by a direct diagonalization. We
    define \(\emptyset'\) in such a way that \(\N-\emptyset'\) differs from \(W_e\) at \(e\): let
    \begin{equation*}
    \emptyset'=\{e:e\in W_e\}
    \end{equation*}
    The set \(\emptyset'\) is called the *halting problem*, since \(e\in\emptyset'\) iff program \(P_e^1\) halts on input \(e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    The set \(\emptyset'\) is c.e. but not computable
    #+END_proposition

    #+BEGIN_proof
    \(\emptyset'\) is c.e. since \(\emptyset'=\dom(J)\), where \(J\) is the partial computable function given
    by \(J(e)\simeq\Phi_e(e)\). If \(\emptyset'\) is computable then there is \(e\) s.t. \(\N-\emptyset'=W_e\).
    Then \(e\in\emptyset'\leftrightarrow e\in W_e\leftrightarrow e\in\emptyset'\), a contradiction
    #+END_proof

    The sequence \((W_e)_{e\in\N}\) is universal for uniformly c.e. sequences

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    For each uniformly c.e. sequence \((A_e)_{e\in\N}\) there is a computable function \(q\)
    s.t. \(A_e=W_{q(e)}\) for each \(e\)
    #+END_corollary

    #+BEGIN_proof
    Define the partial computable function \Theta by \(\Theta(e,x)\simeq 0\) iff \(x\in A_e\), and \(\Theta(e,x)\) is
    undefined otherwise. Then the function \(q\) obtained by the Parameter Theorem is as required.
    #+END_proof

    #+BEGIN_exercise
    label:1.1.12
    Suppose \((\hatW_e)_{e\in\N}\) is a further universal uniformly c.e. sequence. Assume
    that \((\hatW_e)_{e\in\N}\) also has the padding property, one may effectively obtain \(e'>m\)
    s.t. \(\hatW_e'=\hatW_e\). Show that there is a computable permutation \pi of \(\N\)
    s.t. \(\hatW_e=W_{\pi(e)}\) for each \(e\)
    #+END_exercise

    #+BEGIN_proof
    there is \(q\) s.t. \(W_{q(e)}=\hatW_e\), there is \(p\) s.t. \(\hatW_{p(e)}=W_e\)
    Find
    1. \(q'(e)>e\)
    2. \(q'\) is 1-1
    3. \(W_{q'(e)}=\hatW_e\)


    padding \(\pi(m,e)>m\). \(W_{\pi(e,q(e))}=W_{q(e)}\)

    similar to cantor-bernstein

    or back-and-forth
    #+END_proof
*** Indices and approximations
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write
    \begin{equation*}
    \Phi_{e,s}(x)=y
    \end{equation*}
    if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\) yields \(y\) in at
    most \(s\) computation steps. Let \(W_{e,s}=\dom(\Phi_{e,s})\)
    #+END_definition

    At stage \(s\) we have complete information about \(\Phi_{e,s}\) and \(W_{e,s}\). To state this
    more formally, we need to specify an effective listing \(D_0,D_1,\dots\) of the finite subsets of \(\N\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(D_0=\emptyset\). If \(n>0\) has the form \(2^{x_1}+\dots+2^{x_r}\), where \(x_1<\dots<x_r\), then
    let \(D_n=\{x_1,\dots,x_r\}\). We say that \(n\) is a *strong index* for \(D_n\). For instance, \(D_5=\{0,2\}\)
    #+END_definition

    There is a computable function \(f\) s.t. \(f(e,s)\) is a strong index for \(W_{e,s}\). We think
    of a computable enumeration of a set \(A\) as an effective listing \(a_0,a_1,\dots\) of the elements
    of \(A\) in some order. To include the case that \(A\) is finite, we formalize this via an
    effective union of finite sets \((A_s)\). We view \(A_s\) as the set of elements enumerated by
    the end of stage \(s\). At certain stages we may decide not to enumerate any element

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *computable enumeration* of a set \(A\) is an effective sequence \((A_s)_{s\in\N}\) of (strong
    indices for) finite sets s.t. \(A_s\subseteq A_{s+1}\) for each \(s\) and \(A=\bigcup_sA_s\)
    #+END_definition

    Each c.e. set \(W_e\) has the computable enumeration \((W_{e,s})_{s\in\N}\). Conversely, if \(A\)
    has a computable enumeration then \(A\) is c.e., for \(A=\dom(\Phi)\) where \(\Phi\) is the partial
    computable function given by the following procedure: at stage \(s\) we let \(\Phi(x)=0\)
    if \(x\in A_s\). An *index for a c.e. set* \(A\) is a number \(e\) s.t. \(A=W_e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each computable function \Phi, \(\ran(\Phi)\) is c.e.
    #+END_proposition

    #+BEGIN_proof
    Suppose \(\Phi=\Phi_e\) and we enumerate \(A=\ran(\Phi)\). Since we have complete information
    about \(\Phi_s\) at stage \(s\), we can compute from \(s\) a strong index for \(A_s=\ran(\Phi_s)\).
    Then \((A_s)_{s\in\N}\) is the required computable enumeration of \(A\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.17
    #+END_exercise

    #+BEGIN_exercise
    label:1.1.19

    #+END_exercise

    #+BEGIN_proof
    find a subsequence with increasing required steps
    #+END_proof
** Relative computational complexity of sets


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(X\) is *many-one reducible* to \(Y\), denoted \(X\le_mY\), if there is a computable function \(f\)
    s.t. \(n\in X\leftrightarrow f(n)\in Y\) for all \(n\)
    #+END_definition

    If \(X\) is computable, \(Y\neq\emptyset\), and \(Y\neq\N\), then \(X\le_mY\): choose \(y_0\in Y\) and \(y_1\notin Y\).
    Let \(f(n)=y_0\) if \(n\in X\) and \(f(n)=y_1\) otherwise. Then \(X\le_mY\) via \(f\).

    For each set \(Y\) the class \(\{X:X\le_mY\}\) is countable. In particular, there is no greatest
    many-one degree

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.2
    \(A\) is c.e. \(\Leftrightarrow\) \(A\le_m\emptyset'\)

    An index for the many-one reduction as a computable function can be obtained effectively from a
    c.e. index for \(A\), and conversely
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): We claim that there is a computable function \(g\) s.t.
    \begin{equation*}
    W_{g(e,n)}=
    \begin{cases}
    \{e\}&n\in A\\
    \emptyset
    \end{cases}
    \end{equation*}
    For let \(\Theta(e,n,x)\) converge if \(x=e\) and \(n\in A\). Then there is a computable function \(g\)
    s.t. \(\forall e,n,x[\Theta(e,n,x)\simeq\Phi_{g(e,n)}(x)]\). By Theorem ref:1.1.6, there is a computable
    function \(h\) s.t. \(W_{g(h(n),n)}=W_{h(n)}\) for each \(n\). Then
    \begin{align*}
    &n\in A\Rightarrow W_{h(n)}=\{h(n)\}\Rightarrow h(n)\in\emptyset'\\
    &n\notin A\Rightarrow W_{h(n)}=\emptyset\Rightarrow h(n)\notin\emptyset
    \end{align*}
    \(\Leftarrow\): If \(A\le_m\emptyset'\) via \(h\), then \(A=\dom(\Psi)\) where \(\Psi(x)\simeq J(h(x))\) (recall
    that \(J(e)\simeq\Phi_e(e)\))
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A c.e. set \(C\) is called *\(r\)-complete* if \(A\le_rC\) for each c.e. set \(A\)
    #+END_definition

    we say that \(X\le_1Y\) if \(X\le_mY\) via a one-one function \(f\)

    #+BEGIN_exercise
    label:1.2.4
    The set \(\emptyset'\) is \(1\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.5
    \(X\equiv_1 Y\Leftrightarrow\) there is a computable permutation \(p\) of \(\N\) s.t. \(Y=p(X)\)
    #+END_exercise

    Our intuitive understanding of "\(Y\) is at least as complex as \(X\)" is: \(X\) can be computed
    with the help of \(Y\). To formalize more general ways of relative computation, we extend the
    machine model by a one-way infinite "oracle" tape which holds all the answers to oracle
    questions of the form "is \(k\) in \(Y\)".

    We write \(\Phi_e^Y(n)\downarrow\) if the program \(P_e\) halts when the oracle is \(Y\) and the input
    is \(n\); we write \(\Phi_e(Y;n)\) or \(\Phi_e^Y(n)\) for this output. The \(\Phi_e\) are called *Turing
    functionals*. And we let \(W_e^Y=\dom(\Phi_e^Y)\). \(W_e\) is a *c.e. operator*

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A total function \(f:\N\to\N\) is called *Turing reducible* to \(Y\), or *computable relative to* \(Y\),
    or *computable in* \(Y\), if there is an \(e\) s.t. \(f=\Phi_e^Y\). We denote this by \(f\le_TY\). We
    also say that \(Y\) *computes* \(f\). For a set \(A\), we write \(A\le_TY\) if the characteristic
    function of \(A\) is Turing reducible to \(Y\)
    #+END_definition

    For a total functions \(g\), \(f\le_Tg\) means that \(f\) is Turing reducible to the *graph*
    of \(g\), that is, to \(\{\la n,g(n)\ra:n\in\N\}\)

    #+BEGIN_exercise
    label:1.2.7
    \(\le_m\) and \(\le_T\) are preorderings of the subsets of \(\N\)
    #+END_exercise

    A set \(A\) is *c.e. relative to* \(Y\) if \(A=W_e^Y\) for some \(e\). We view \(\Phi_e\)as \(\Phi_e^{\emptyset}\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.8
    \(A\) is computable in \(Y\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(Y\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(J^Y(e)\simeq\Phi_e^Y(e)\). The set \(Y'=\dom(J^Y)\) is the *Turing jump* of \(Y\). The
    map \(Y\to Y'\) is called the *jump operator*
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    For each computable binary function \(g\) there is a computable function \(f\) s.t. \(\Phi_{g(f(n),n)}^Y=\Phi_{f(n)}^Y\)
    #+END_theorem

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.11
    \(A\) is c.e. in \(Y\) iff \(A\le_mY'\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.12
    For each \(Y\), the set \(Y'\) is c.e. relative to \(Y\). Also, \(Y\le_mY'\) and \(Y'\not\le_TY\),
    and therefore \(Y<_TY'\)
    #+END_proposition

    #+BEGIN_proof
    \(Y'\) is c.e. in \(Y\) since \(Y'=\dom(J^Y)\). As \(Y\) is c.e. relative to itself, by
    Proposition ref:1.2.11 \(Y\le_mY'\). If \(Y'\le_TT\) then there is \(e\) s.t. \(\N-Y'=W_e^Y\).
    Then \(e\in Y'\leftrightarrow e\in W_e^Y\leftrightarrow e\notin Y'\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We define \(Y^{(n)}\) inductively by \(Y^{(0)}=Y\) and \(Y^{(n+1)}=(Y^{(n)})'\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each \(Y,Z\) we have \(Y\le_TZ\Leftrightarrow Y'\le_mZ'\)
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): \(Y'\) is c.e. in \(Y\) and hence c.e. in \(Z\). Therefore \(Y'\le_mZ'\) by Proposition ref:1.2.11

    \(\Leftarrow\):By Proposition ref:1.2.8, \(Y\) and \(\N-Y\) are c.e. in \(Y\). So \(Y,\N-Y\le_mY'\le_mZ'\),
    whence both \(Y\) and \(\N-Y\) are c.e. in \(Z\). Hence \(Y\le_TZ\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    From a Turing functional \(\Phi=\Phi_e\) one can effectively obtain a computable strictly increasing
    function \(p\), called a *reduction function* for \Phi, s.t. \(\forall Y\forall x\Phi^Y(x)\simeq J^Y(p(x))\)
    #+END_fact

    #+BEGIN_proof
    Let \(\Theta^Y(x,y)\simeq\Phi^Y(x)\), by the oracle version of the Parameter Theorem there is a computable
    strictly increasing function \(p\) s.t. \(\forall Y\forall y\Phi_{p(x)}^Y(y)\simeq\Theta^Y(x,y)\simeq\Phi^Y(x)\).
    Letting \(y=p(x)\) we obtain \(J^Y(p(x))=\Phi^Y_{p(x)}(p(x))=\Phi^Y(x)\)
    #+END_proof

    We identify \(\sigma\in\{0,1\}^*\) with \(n\in\N\) s.t. the binary representation of \(n+1\) is 1\sigma. For
    instance, 000 is 7

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(\Phi_{e,s}^Y(x)=y\) if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\)
    yields \(y\) in at most \(s\) computation steps, with all oracle queries less than \(s\).
    #+END_definition

    The *use principle* is the fact that a terminating oracle computation only asks finitely many
    oracle questions. Hence \((\Phi_{e,s}^Y)_{s\in\N}\) approximates \(\Phi_e^Y\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *use* of \(\Phi_e^Y(x)\), denoted \(\use\Phi_e^Y(x)\), is defined if \(\Phi_e^Y(x)\downarrow\), where its value is
    1+the largest oracle query asked during this computation.
    #+END_definition

    We write
    \begin{equation*}
    \Phi_e^\sigma(x)=y
    \end{equation*}
    if \(\Phi_e^F(x)\) yields the output \(y\), where \(F=\{i<\abs{\sigma}:\sigma(i)=1\}\), and the use is at
    most \(\abs{\sigma}\). Then for each set \(Y\)
    \begin{equation*}
    \Phi_e^Y(x)=y\leftrightarrow\Phi_e^{Y\uhr u}(x)=y
    \end{equation*}
    where \(u=\use\Phi_e^Y(x)\)

    If a Turing functional \(\Phi_e\) is given then \(\lambda Yx.\use\Phi_e^Y\) is also a Turing functional
    (namely there is \(i\) s.t. \(\Phi_i^Y(x)\simeq\use\Phi_e^Y(x)\) for each \(Y\) and \(x\)). Thus if \(Y\)
    is an oracle s.t. \(f=\Phi_e^Y\) is total, the function \(\use\Phi_e^Y\) is computable in \(Y\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *weak truth-table* reducible to \(Y\), denoted \(f\le_{wtt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    and \(\forall n\use\Phi_e^Y(n)\le r(n)\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *truth-table* reducible to \(Y\), denoted \(f\le_{tt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    \(f=\Phi_e^Y\) and \(\Phi_e^Z\) is total for each oracle \(Z\) (we call such a \(\Phi_e\) a truth table reduction).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. \(X\le_{tt}Y\Leftrightarrow\) there is a computable function \(g\) s.t. for each \(n\),
       \begin{equation*}
       n\in X\Leftrightarrow\bigvee_{\sigma\in D_{g(n)}}[\sigma\preceq Y]
       \end{equation*}
    2. \(X\le_{tt}Y\) implies \(X\le_{wtt}Y\)
    #+END_proposition

    #+BEGIN_proof
    1. \(\Rightarrow\): Suppose \(X\le_{tt}Y\) via a truth-table reduction \(\Phi=\Phi_e\). The
       tree \(T_n=\{\sigma:\Phi^\sigma_{\abs{\sigma}}(n)\uparrow\}\) is finite for each \(n\), for otherwise it has an infinite
       path \(Z\) by Kőnig's Lemma and \(\Phi^Z(n)\uparrow\). Given \(n\) one can compute a strong
       index \(\tilg(n)\) for the finite set of minimal string \sigma s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow\). Hence
       one can compute a strong index \(g(n)\) for the set of all minimal strings \sigma
       s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow=1\). Then \(D_{g(n)}\) is as required

       \(\Leftarrow\):Consider the following procedure relative to an oracle \(Z\): on input \(n\), first
       compute \(D_{g(n)}\). If \(\sigma\preceq Z\) for some \(\sigma\in D_{g(n)}\), output 1, otherwise output 0

    2. For each \(Z\) \(\use\Phi_e^Z(n)\) is bounded by \(\max\{\abs{\sigma}:\sigma\in D_{g(n)}\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.22
    \(f\le_{tt}A\Leftrightarrow\) there is a Turing functional \Phi and a computable function \(t\) s.t. \(f=\Phi^A\) and
    the number of steps needed to compute \(\Phi^A(n)\) is bounded by \(t(n)\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): Let \(\tilPhi\) be the Turing functional s.t. \(\tilPhi^Z(n)=\Phi^Z_{t(n)}(n)\) if the
    latter is defined and \(\tilPhi^Z(n)=0\) otherwise
    #+END_proof

    \begin{equation*}
    \le_m\Rightarrow\le_{tt}\Rightarrow\le_{wtt}\Rightarrow\le_T
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *effective disjoint union* of sets \(A\) and \(B\) is
    \begin{equation*}
    A\oplus B=\{2n:n\in A\}\cup\{2n+1:n\in B\}
    \end{equation*}
    #+END_definition

    #+BEGIN_exercise
    label:1.2.23
    1. \(A,B\le_mA\oplus B\)
    2. Let \(\le_r\) be one of the reducibilities above. Then for any set \(X\)
       \begin{equation*}
       A,B\le_rX\Leftrightarrow A\oplus B\le_rX
       \end{equation*}
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.24
    Let \(C=A_0\cup A_1\) where \(A_0,A_1\) are c.e. and \(A_0\cap A_1=\emptyset\). Then \(C\equiv_{wtt}A_0\oplus A_1\)
    #+END_exercise

    #+BEGIN_proof
    Since \(A_0,A_1\) are c.e., for each \(n\in C\), we can determine if \(n\in A_0\cup A_1\) in finite steps.
    #+END_proof

    #+BEGIN_exercise
    label:1.2.25
    Show that \(\exists Zf\le_{tt}Z\Leftrightarrow\) there is a computable \(h\) s.t. \(\forall nf(n)\le h(n)\)
    #+END_exercise

    #+BEGIN_proof
    Trivial
    #+END_proof
** Descriptive complexity of sets
    In a computable enumeration \((Z_s)_{s\in\N}\) of a set \(Z\), for each \(x\), \(Z_s(x)\) can
    change at most once, namely from 0 to 1. Which sets \(Z\) are described if we allow an arbitrary
    finite number of changes


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We say that a set \(Z\) is \(\Delta_2^0\) if there is a computable sequence of strong
    indices \((Z_s)_{s\in\N}\) s.t. \(Z_s\subseteq[0,s)\) and \(Z(x)=\lim_sZ_s(x)\). We say
    that \((Z_s)_{s\in\N}\) is a *computable approximation* of \(Z\)
    #+END_definition

    Given an expression \(E\) that is approximated during stages \(s\),
    \begin{equation*}
    E[s]
    \end{equation*}
    denotes its value at the *end of* stage \(s\). For instance, given a \(\Delta_2^0\) set \(Z\) with a
    computable approximation, instead of \(\Phi_{e,s}^{Z_s}(x)\) we simply write \(\Phi_e^Z(x)[s]\). We say
    that the expression \(E\) is *stable at* \(s\) if \(E[t]=E[s]\)for all \(t\ge s\)

    #+ATTR_LATEX: :options [Shoenfield Limit Lemma]
    #+BEGIN_lemma
    label:1.4.2
    \(Z\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(Z\le_T\emptyset'\). The equivalence is uniform
    #+END_lemma

    #+BEGIN_proof
    \(\Leftarrow\): Fix a Turing functional \(\Phi_e\) s.t. \(Z=\Phi_e^{\emptyset'}\). Since \(\emptyset'\) is c.e.,
    let \(\la \emptyset'_s\ra_{s\in\N}\) be a computable enumeration of \(\emptyset'\). Define
    \begin{equation*}
    Z_s(x)=
    \begin{cases}
    1&\Phi_{e,s}^{\emptyset'_s\downarrow}=1\\
    0&\text{otherwise}
    \end{cases}
    \end{equation*}
    Let \(u=\use\Phi_e^{\emptyset'}(x)\), there is \(s\) s.t. \(\emptyset'_s\uhr u=\emptyset'\uhr u\), thus there is \(s\ge t\)
    s.t. \(Z_s(x)=Z(x)\)

    Then the required approximation is
    given by \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\)

    \(\Rightarrow\): We define a c.e. set \(C\) s.t. \(Z\le_TC\). This is sufficient because \(C\le_m\emptyset'\) by
    Proposition ref:1.2.2. The set \(C\) is called the *change set* because it records the changes of
    the computable approximation. If \(Z_s(x)\neq Z_{s+1}(x)\) we put \(\la x,i\ra\) into \(C_{s+1}\),
    where \(i\) is the least s.t. \(\la x,i\ra\notin C_s\). To show that \(Z\le_TC\), on input \(x\), using the
    oracle \(C\) compute the least \(i\) s.t. \(\la x,i\ra\notin C\). If \(i\) is even then \(Z(y)=Z_0(y)\),
    otherwise \(Z(y)=1-Z_0(y)\)

    We have obtained \(C\) and the Turing reduction of \(Z\) to \(C\) effectively from the
    computable approximation of \(Z\). Proposition ref:1.2.2 is also effective
    #+END_proof

    If \(Z=\Phi_e^{\emptyset'}\) we say that \(e\) is a *\(\Delta_2^0\)-index* for \(Z\). A number \(e\) is
    a \(\Delta_2^0\) index only if \(\Phi_e^{\emptyset'}\) is total

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. We say that a set \(Z\) is *\omega-c.e.* if there is a computable
       approximation \((Z_s)_{s\in\N}\) of \(Z\) and a computable function \(b\) s.t.
       \begin{equation*}
       b(x)\ge\#\{s>x:Z_x(x)\neq Z_{s-1}(x)\}\text{ for each }x
       \end{equation*}
    2. If \(Z_s(s-1)=0\) for each \(s>0\) and \(b(x)\) can be chosen constant of value \(n\), then
       we say \(Z\) is \(n\)-c.e.
    #+END_definition

    Thus \(Z\) is 1-c.e. iff \(Z\) is c.e., and \(Z\)  is 2-c.e. iff \(Z=A-B\) for c.e. sets \(A,B\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\omega\)-c.e. \(\Leftrightarrow\) \(Z\le_{wtt}\emptyset'\) \(\Leftrightarrow\) \(Z\le_{tt}\emptyset'\)

    The equivalence are effective
    #+END_proposition

    #+BEGIN_proof
    First suppose that \(Z_{wtt}\emptyset'\) via a functional \(\Phi_e\) with computable use bound \(f\). To
    show that \(Z\) is \omega-c.e., let \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\). Since \(\Phi_e^{\emptyset'}(x)[s]\) only
    becomes undefined when a number less than \(f(x)\) enters \(\emptyset'\), the number of changes
    of \(Z_s(x)\) is bounded by \(2f(x)\)

    Now suppose that \(Z\) is \omega-c.e. via the computable approximation \((Z_s)_{s\in\N}\) and the
    function \(b\) bounding the number of changes. We show that \(Z\le_{tt}\emptyset'\). Let \(C\) be the
    change set. Since \(b(x)\ge\min\{i:\la x,i\ra\notin C\}\), the reduction of \(Z\) to \(C\) given there can be
    carried out by computing a truth-table from the input \(x\) and evaluating it on the answers to
    oracle questions to \(C\)
    #+END_proof

    #+ATTR_LATEX: :width .9\textwidth
    #+NAME:
    #+CAPTION:
    [[../images/ComputabilityAndRandomness/1.jpg]]


    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    label:1.4.14
    \(A\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(A\) is both \(\Sigma_2^0\) and \(\Pi_2^0\)
    #+END_corollary

    #+BEGIN_proof
    \begin{align*}
    A\in\Delta_2^0&\Leftrightarrow A\le_T\emptyset'\\
    &\Leftrightarrow A\text{ and }\N-A\text{ are c.e. in }\emptyset'\\
    &\Leftrightarrow A\in\Sigma_2^0\cap\Pi_2^0
    \end{align*}
    last iff from Theorem ref:1.4.13
    #+END_proof


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(A\subseteq\N\) and \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\)if \(x\in A\leftrightarrow\exists y_1\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\), where \(R\) is a symbol for a
       computable relation
    2. \(A\) is \(\Pi_n^0\) if \(\N-A\) is \(\Sigma_n^0\)
    3. \(A\) is *arithmetical* if \(A\) is \(\Sigma_n^0\) for some \(n\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    label:1.4.12
    \(A\) is \(\Sigma_1^0\Leftrightarrow A\) is c.e.. The equivalence is uniform
    #+END_fact

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(x\in A\leftrightarrow\exists y R(x,y)\) for computable \(R\). Let \Phi be the partial computable
    function given by the Turing program that on input \(x\) looks for a witness \(y\)
    s.t. \(R(x,y)\), and halts when such a witness is found. Then \(A=\dom(\Phi)\)

    \(\Leftarrow\): Suppose \(A=\dom(\Phi)\) for a partial computable function \Phi. Let \(R\) be the computable
    relation given by \(R(x,s)\leftrightarrow\Phi(x)[s]\downarrow\). Then \(x\in A\leftrightarrow\exists sR(x,s)\), so \(A\) is \(\Sigma_1^0\)
    #+END_proof

    A \(\Sigma_n^0\) set \(C\) is *\(\Sigma_n^0\)-complete* if \(A\le_mC\) for each \(\Sigma_n^0\) set \(A\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:1.4.13
    Let \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\) \(\Leftrightarrow\) \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)
    2. \(\emptyset^{(n)}\) is \(\Sigma_n^0\)-complete
    #+END_theorem

    #+BEGIN_proof
    Induction on \(n\).  ref:1.4.12 and ref:1.2.2. Now let \(n>1\)
    1. First suppose \(A\) is \(\Sigma_n^0\) for some computable relation \(R\). Then the set
       \begin{equation*}
       B=\{\la x,y_1\ra:\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\}
       \end{equation*}
       is \(\Pi_{n-1}^0\) and \(A\) is c.e. relative to \(B\). By (2) for \(n-1\) we
       have \(B\le_m\N-\emptyset^{(n-1)}\). So \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)

       Now suppose \(A\) is c.e. relative to \(\emptyset^{(n-1)}\). Then there is a Turing functional \Phi
       s.t. \(A=\dom(\Phi^{\emptyset^{(n-1)}})\). By the use principle
       \begin{equation*}
       x\in A\Leftrightarrow\exists\eta,s\ucorner{\Phi_s^\eta(x)\downarrow\wedge\forall i<\abs{\eta}\;\eta(i)=1\leftrightarrow i\in\emptyset^{(n-1)}}
       \end{equation*}
       The innermost part can be put into \(\Sigma_n^0\)-form, so \(A\) is \(\Sigma_n^0\).
    2. Follows by Proposition ref:1.2.11 where \(Y=\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    Let \(n\ge 1\). Then \(A\) is \(\Delta_n^0\Leftrightarrow A\le_T\emptyset^{(n-1)}\)
    #+END_proposition

    #+BEGIN_proof
    By Theorem ref:1.4.13, \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(\emptyset^{(n-1)}\). By
    Proposition ref:1.2.8, this condition is equivalent to \(A\le_T\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\Sigma_2^0\) \(\Leftrightarrow\) there is a computable sequence of strong indices \((Z_s)_{s\in\N}\)
    s.t. \(Z_s\subseteq[0,s)\) and \(x\in Z\leftrightarrow\exists s\forall t\ge s\;Z_t(x)=1\). The equivalence is uniform
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): By Theorem ref:1.4.13, there is a Turing functional \Phi s.t. \(Z=\dom(\Phi^{\emptyset'})\). Now
    let \(Z_s=\{x<s:\Phi^{\emptyset'}(x)[s]\downarrow\}\)

    \(\Leftarrow\):
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *index set* of a class \(S\) of c.e. sets is the set \(\{i:W_i\in S\}\)
    #+END_definition


    #+BEGIN_exercise
    label:1.4.19
    \(\emptyset'\) is not an index set
    #+END_exercise

    #+BEGIN_proof
    We can find \(g\) s.t. \(W_{g(n)}=\{n\}\). Thus there is \(e\) s.t. \(W_{g(e)}=W_e=\{e\}\). By
    padding lemma, we have \(W_i=W_e\) but \(i\notin\emptyset'\)
    #+END_proof



    #+BEGIN_exercise
    label:1.4.20
    1. \(\{e:W_e\neq\emptyset\}\) is \(\Sigma_1^0\)-complete
    2. The set \(\{e:W_e\text{ finite }\}\) is \(\Sigma_2^0\)-complete.
    3. The set \(\Tot=\{e:\dom(\Phi_e)=\N\}=\{e:W_e=\N\}\) is \(\Pi_2^0\)-complete
    4. Both \(\{e:W_e\text{ cofinite}\}\) and \(\Cop=\{e:W_e\text{ computable}\}\) are \(\Sigma_3^0\)-complete
    #+END_exercise

    #+BEGIN_proof
    1. Given \(e\), \(\Phi_{f(n)}\) doesn't converge in \(\N-\{e\}\). And converges on \(e\)
       if \(\Phi_e(e)\downarrow\). Thus \(\emptyset'\le_m\{e:W_e\neq\emptyset\}\)
    2. Let \(\Fin=\{e:W_e\text{ finite}\}\). Then \(e\in\Fin\Leftrightarrow\exists s\forall t\ge s(W_{e,s}=W_{e,t})\)
    3. \(e\in\Tot\Leftrightarrow\forall n\exists s\Phi_{e,s}(n)\downarrow\)

       For any \(A\) in \(\Pi_2^0\), \(x\in A\Leftrightarrow\forall y\exists zR(x,y,z)\)

       We could define
       \begin{equation*}
       \Phi_{q(x)}(u)=
       \begin{cases}
       0&\forall y\le u\exists zR(x,y,z)\\
       \uparrow
       \end{cases}
       \end{equation*}
       Then \(x\in A\Leftrightarrow W_{q(x)}=\omega\Leftrightarrow q(x)\in\Tot\)

       \(x\in\barA\Leftrightarrow W_{q(x)}\) is finite
    4. \(e\in\Cof\Leftrightarrow\exists z\forall n\ge z\exists s\Phi_{e,s}(n)\downarrow\), thus \(\Cof\in\Sigma_3^0\)

       check fudan's textbook p120
    #+END_proof

    #+BEGIN_exercise
    label:1.4.21
    The set \(\{e:\dom\Phi_e^{\emptyset'}=\N\}\) is \(\Pi_0^3\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.4.22
    Let \(\cals\) be a class of c.e. sets [\omega-c.e. sets] containing all the finite sets. Suppose the
    index set of \(S\) is \(\Sigma_3^0\).  Then \(\cals\) is uniformly c.e. [uniformly c.e.]
    #+END_exercise

    #+BEGIN_proof
    Let \(I=\{e\mid\exists x\forall y\exists z\;R(e,x,y,.z)\}\), \(\cals=\{W_e\}_{e\in I}\)

    \(\cals\) is \(\Sigma_3^0\), \(\cals\le_m\Cof\)
    #+END_proof

    #+BEGIN_exercise
    label:1.4.24
    Let \(X\subseteq\N\)
    1. Each relation \(R\le_TX\) is first-order definable in the structure \((\N,+,\cdot ,X)\)
    2. The index set \(\{e:W_e\le_TX\}\) is \(\Sigma_3^0(X)\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.4.25
    \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(\forall x A(x)=\lim_{k_1}\dots\lim_{k_{n-1}}g(x,k_1,\dots,k_{n-1})\) for some
    computable \(\{0,1\}\)-valued function \(g\)
    #+END_exercise
** Absolute computational complexity of sets
*** Sets that are \texorpdfstring{\(low_n\)}{lown}
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(f,g:\N\to\R\). \(f\) *dominates* \(g\) if \(f(n)\ge g(n)\) for almost every \(n\)
    #+END_definition

    1. \(A\) is *low* if \(A'\le_T\emptyset'\)
    2. \(A\) is *computably dominated* if each function \(g\le_TA\) is dominated by a computable
       function
    3. \(A\) is *high* if \(\emptyset''\le_TA'\)


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(n\ge 0\). We say that \(C\) is \(low_n\) if \(C^{(n)}\equiv_T\emptyset^{(n)}\)
    #+END_definition

    If \(C\in low_1\) we simply say that \(C\) is *low*. Each low set is \(\Delta_2^0\).

    Each class \(low_n\) is closed downward under Turing reducibility, and contained in \(\Delta_{n+1}^0\)
    \begin{equation*}
    \text{computable}\subset low_1\subset low_2\subset\dots\subset\{Z:Z\not\ge_T\emptyset'\}
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(C\) is *superlow* if \(C'\equiv_{tt}\emptyset'\)
    #+END_definition

    It suffices to require that \(C'\le_{tt}\emptyset'\), because \(\emptyset'\le_mC'\) for any \(C\) by ref:1.2.14. By
    ref:1.4.4 it is equivalent to ask that \(C'\) be \omega-c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is *generalized \(low_1\)*, or in \(\GL_1\) for short, if \(A'\equiv_TA\oplus\emptyset'\)
    #+END_definition

    #+BEGIN_exercise
    label:1.5.5
    If \(C\) is superlow, there is a computable function \(h\) s.t. \(Y\le_TC\) implies \(Y\le_{tt}\emptyset'\)
    with use function bounded by \(h\) for each \(Y\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.5.7
    If \(B\) is \(low_2\) then the index set \(\{e:W_e\le_TB\}\) is \(\Sigma_3^0\)
    #+END_exercise

    #+BEGIN_exercise
    label:1.5.8
    \(B\) is \(low_2\)\(\Leftrightarrow\) \(\Tot^B=\{e:\Phi_e^B\text{ total}\}\) is \(\Sigma_3^0\)
    #+END_exercise
*** Computably dominated sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is called *computably dominated* if each function \(g\le_TA\) is dominated by a computable
    function
    #+END_definition

    \(E\subseteq\N\)  is *hyperimmune* if \(E\) is infinite and \(p_E\) is not dominated by a computable
    function, where \(p_E\) is the listing of \(E\) in order of magnitude

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is not computably dominated \(\Leftrightarrow\) there is a hyperimmune set \(E\equiv_TA\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): immediate since \(p_E\le_TE\)

    \(\Rightarrow\): Suppose \(g\le_TA\) is not dominated by a computable function. Let \(E=\ran(h)\), where the
    function \(h\) is defined as follows: \(h(0)=0\), and for each \(n\in\N\), \(h(2n+1)=h(2n)+g(n)+1\)
    and \(h(2n+2)=h(2n+1)+p_A(n)+1\).
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computably dominated \(\Leftrightarrow\) for each function \(f\)
    \begin{equation*}
    f\le_TA\to f\le_{tt}A
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(f=\Phi^A\). Let \(g(x)=\mu s\Phi_s^A(x)\downarrow\). Then \(g\le_TA\), so there is a computable
    function \(t\) s.t. \(t(x)\ge g(x)\) for each \(x\). Thus \(t\) bounds the running time of \(\Phi^A\),
    whence \(f\le_{tt}A\) by Proposition ref:1.2.22
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    If \(A\) is \(\Delta_2^0\) and incomputable, then \(A\) is not computably dominated
    #+END_proposition

    #+BEGIN_proof
    Let \((A_s)_{s\in\N}\) be a computable approximation of \(A\). Then the following function \(g\) is
    total
    \begin{equation*}
    g(s)\simeq\mu t\ge s.A_t\uhr s=A\uhr s
    \end{equation*}
    Note that \(g\le_TA\). Assume that there is a computable function \(f\) s.t. \(g(s)\le f(s)\) for
    each \(s\). Then \(A\) is computable: for each \(n\) and each \(s>n\) we have \(A_t(n)=A(n)\)
    for some \(t\in[s,f(s))\), namely \(t=g(s)\). On the other hand, if \(s\) is sufficiently large
    then \(A_u(n)=A_s(n)\) for all \(u\ge s\). Thus to compute \(A\), on input \(n\) determine the
    least \(s>n\) s.t. \(A_u(n)=A_s(n)\) for all \(u\in[s,f(s))\). Then \(A_s(n)=A(n)\), so the
    output \(A_s(n)\) is correct
    #+END_proof
*** Sets that are \texorpdfstring{\(high_n\)}{highn}
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(n\ge 0\). A set \(C\) is \(high_n\) if \(\emptyset^{(n+1)}\le_TC^{(n)}\)
    #+END_definition

    All the classes \(high_n\) are closed upward under Turing reducibility, so the complementary
    classes \(\non-high_n=2^{\N}-high_n\) are closed downward. Therefore
    \begin{equation*}
    comp.\subset low_1\subset low_2\subset\dots\subset\non-high_2\subset\non-high_1\subset\{Z:Z\not\ge_T\emptyset'\}
    \end{equation*}

    It is easy to define a function \(f\le_T\emptyset'\) that dominates all computable functions: the
    set \(\{\la e,x\ra:\Phi_e(x)\downarrow\}\) is c.e., and hence many-one reducible to \(\emptyset'\) via a computable
    function \(h\). Let \(f(x)=\max\{\Phi_e(x):e\le x\wedge h(\la e,x\ra)\in\emptyset')\}\). If \(\Phi_e\) is total
    then \(f(x)\ge\Phi_e(x)\) for all \(x\ge e\). This property of \(\emptyset'\) in fact characterizes the high
    sets.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    \(C\) is high \(\Leftrightarrow\) some function \(f\le_TC\) dominates all computable functions
    #+END_theorem

    #+BEGIN_proof
    \(\Rightarrow\): We define a function \(f\le_TC\) that dominates each total \(\Phi_e\), extending the argument
    for the case \(C=\emptyset'\). Note that \(\Tot=\{e:\Phi_e\text{ total}\}\) is \(\Pi_2^0\), and
    hence \(\ove{\Tot}\le_m\emptyset''\le_TC'\). By the Limit Lemma ref:1.4.2, \(\Tot\) is \(\Delta_2^0(C)\), there is
    a \(A\)-computable approximation \((T_s)_{s\in\N}\) of \(\Tot\). Define \(f\le_TA\) as:
    \(\forall x\in\N\), let
    \begin{align*}
    &S_x=\mu s(\forall e\le x(\Phi_{e,s}(x)\downarrow\text{ or }T_s(e)=0))\\
    &f(x)=\max\{\Phi_{e,S_x}(x)\mid e\le x,\Phi_{e,S_x}(x)\downarrow\}
    \end{align*}
    *Claim*: \(\forall x\), \(S_x\) exists

    For any \(e\le x\), if \(\Phi_e\) is total, then \(S_x\) always exists. Otherwise, \(T_s(e)\) converges
    to 0

    *Claim*: \(f\) dominates all computable total functions

    \(\forall x\ge e\), \(\exists s\le S_x\), \(\Phi_{e,s}\downarrow\le f(x)\)

    \(\Leftarrow\): Suppose \(f\le_TC\) dominates all computable functions. We show
    that \(\N-\emptyset''=\{e:\Phi_e^{\emptyset'}(e)\uparrow\}\) is Turing reducible to \(C'\). Note that \(\Phi_e^{\emptyset'}(e)\uparrow\) iff the
    computation is undefined at infinitely many stages, that is, no computation \(\Phi_e^{\emptyset'}(e)[s]\) is
    stable. Thus \(\Phi_e^{\emptyset'}(e)\uparrow\) iff the partial computable function
    \begin{equation*}
    g(s)\simeq\mu t>s[\Phi_e^{\emptyset'}(e)[t]\uparrow]
    \end{equation*}
    is total. In that case \(g\) is dominated by \(f\), and therefore
    \begin{equation*}
    e\notin\emptyset''\Leftrightarrow\exists n_0\forall n\ge n_0\exists t[n\le t\le f(n)\wedge\Phi_e^{\emptyset'}(e)[t]\uparrow]
    \end{equation*}
    Since \(t\) is bounded by \(f(n)\) and \(f\le_T(C)\), this shows that \(\N-\emptyset''\) is \(\Sigma_2^0(C)\).
    Also \(\emptyset''\in\Sigma_2^0\subseteq\Sigma_2^0(C)\). Therefore \(\emptyset''\le_TC'\) by Proposition ref:1.4.14 relative to \(C\)
    #+END_proof
** Post's problem
*** Turing incomparable \texorpdfstring{\(\Delta_2^0\)}{Δ02}-sets
    For sets \(Y,Z\), we write \(Y\mid_TZ\) if \(Y\not\le_TZ\) and \(Z\not\le_TY\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There are sets \(Y,Z\le_T\emptyset'\) s.t. \(Y\mid_TZ\)
    #+END_theorem

    #+BEGIN_proof
    Noe that \(Y\mid_TZ\) is equivalent to the conjunction of the statements \(R_i\) for all \(i\) where
    \begin{align*}
    R_{2e}&:\exists n\neg Y(n)=\Phi_e^Z(n)\\
    R_{2e+1}&:\exists n\neg Z(n)=\Phi_e^Y(n)
    \end{align*}
    Thus we may divide the overall task that \(Y\mid_TZ\) into subtasks, called *requirements*. To *meet* a
    requirement means to make its statement true.

    The construction of \(Y\) and \(Z\) is relative to \(\emptyset'\). We meet the requirements one by one
    in the given order. We define sequences \(\sigma_0\prec\sigma_1\prec\dots\) and \(\tau_0\prec\tau_1\prec\dots\) and let \(Y=\bigcup_i\sigma_i\)
    and \(Z=\bigcup_i\tau_i\). As stage \(i+1\) we meet \(R_i\) by defining \(\sigma_{i+1}\) and \(\tau_{i+1}\)
    appropriately. Since we have \(\emptyset'\) at our disposal as an oracle, we may ask whether \(\Phi_e^Z(n)\)
    can be made defined for a particular number \(n\). Then we may define \(Y(n)\) in such a way
    that it differs from \(\Phi_e^Z(n)\). This method of providing a counterexample to an equality of
    sets is called *diagonalization*

    *Construction*. Let \(\sigma_0=\tau_0=\emptyset\)

    _Stage \(i+1\), \(i=2e\)_. Let \(n=\abs{\sigma_i}\). Using \(\emptyset'\) as an oracle, check whether there
    is \(\tau\succ\tau_i\) s.t. \(y=\Phi_e^\tau(n)\downarrow\). (Note that this is a \(\Sigma_0^1\) question, so it can be answered
    by \(\emptyset\).) It so, let \(\tau_{i+1}=\tau\) and \(\sigma_{i+1}=\sigma_ix\) where \(x=\max(1-y,0)\). Otherwise
    let \(\sigma_{i+1}=\sigma_i0\) and \(\tau_{i+1}=\tau_i0\)

    _Stage \(i+1\), \(i=2e+1\)_. Similar

    *Verification*. Clearly \(Y,Z\le_T\emptyset'\). Each requirement \(R_{2e}\) is met: if we cannot find an
     extension \(\tau\succ\tau_i\) s.t. \(\Phi^\tau_e(n)\downarrow\), then by use principle \(\Phi_e^Z(n)\uparrow\). Otherwise we ensure
     that \(Y(n)\neq\Phi_e^Z(n)\). Either way \(R_{2e}\) is met
    #+END_proof
*** Simple sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A c.e. set \(A\) is *simple* if \(\N-A\) is infinite and \(A\cap W\neq\emptyset\) for each infinite c.e. set \(W\)
    #+END_definition

    In particular, \(\N-A\) is not c.e., so \(A\) is not computable.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There is a simple set
    #+END_theorem

    #+BEGIN_proof
    Let \(A=\ran(\psi)\) where
    \begin{equation*}
    \psi(i)\simeq\text{ the first element }\ge 2i\text{ enumerated into }W_i
    \end{equation*}
    Since \psi is partial computable, \(A\) is c.e. If \(x<2i\) is in \(A\) then \(x=\psi(k)\) for
    some \(k<i\). Hence \(\#A\cap[0,2i)\le i\), so \(A\) is co-infinite. By definition \(A\) is simple
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There is a low simple set \(A\)
    #+END_theorem

    #+BEGIN_proof
    Let
    \begin{align*}
    S_e&:\#W_e=\infty\Rightarrow W_e\cap A\neq\emptyset\\
    L_e&:\exists^\infty sJ^A(e)[s-1]\downarrow\Rightarrow J^A(e)\downarrow
    \end{align*}
    that restrict \(A\). If \(L_e\) is met then \(A'(e)=\lim_sf(e,s)\) where
    \begin{equation*}
    f(e,s)=
    \begin{cases}
    1&J^A(e)[s]\downarrow\\
    0
    \end{cases}
    \end{equation*}
    So \(A'\le_T\emptyset'\) by the Limit Lemma ref:1.4.2. That is \(A\) is low.

    The strategy for \(L_e\) is as follows. When \(J^A(e)[s-1]\) newly converges then \(L_e\)
    *restrains* \(A\) up to \(s\); in other words, \(L_e\) attempts to prevent numbers \(<s\) from
    entering \(A\)

    The conflict between the \(A\)-positive requirements \(S_i\) and the \(A\)-restricting
    requirements \(L_e\) is resolved by imposing an effective *priority ordering*, for instance
    \begin{equation*}
    S_0>L_0>S_1>L_1>\dots
    \end{equation*}

    If a requirement is initialized at stage \(s\), it can afterwards only put numbers \(\ge s\)
    into \(A\). Since oracle questions occurring in the computation \(J^A(e)[s-1]\) are less
    than \(s\), an enumeration of such numbers cannot injure \(L_e\)

    *Construction*. Let \(A_0=\emptyset\)

    /Stage \(s>0\)/
    1. For each \(e<s\), if \(J^A(e)[s-1]\downarrow\) but \(J^A(e)[s-2]\uparrow\) in case \(s>1\), then initialize the
       requirements \(S_i\) for \(i>e\). We say that \(L_e\) *acts*
    2. For each \(e<s\), if \(A_{s-1}\cap W_{e,s-1}=\emptyset\) and there is \(x\in W_{e,s}\) s.t. \(x\ge 2e\)
       and \(x\) is no less than the last stage when \(S_e\) was initialized, then enumerate the
       least such \(x\) into \(A\). We say that \(S_e\) *acts*

    #+END_proof
** Cantor Space
*** Cantor space
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    For any finite 01 string \(\sigma\in 2^{<\omega}\), *cylinder set* is
    \begin{equation*}
    [\sigma]=\{Z\in 2^\omega\mid\sigma\prec Z\}
    \end{equation*}

    And for \(E\subset 2^{<\omega}\), define
    \begin{equation*}
    [E]^\prec=\bigcup\{[\sigma]\mid\sigma\in E\}=\{Z\in 2^\omega\mid\exists \sigma\in E(\sigma\prec Z)\}
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    *Cantor space* is the space with base set the cylinder sets. \(U\subset 2^\omega\) is open (or \(\Sigma_0^1\)) iff there
     is \(E\subset 2^{<\omega}\) s.t. \(U=[E]^{\prec}\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(E\subset 2^{<\omega}\) is *prefix-free* iff \(\forall \sigma,\tau\in E(\sigma\neq\tau\to\sigma\mid\tau)\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(U\subset 2^\omega\) is open iff there is prefix-free \(E\subset 2^{<\omega}\) s.t. \(U=[E]^{\prec}\)
    #+END_proposition

    #+BEGIN_proof
    Given \(E'\) with \(U=[E']^{\prec}\), let \(E'=\{\sigma_i:i<N\}\), \(N\in\omega\) or \(N​=\omega\). Let \(E_0​=\emptyset\)

    If \([\sigma_i]\subset[E_i]^\prec\), let \(E_{i+1}=E_i\)

    If not, and \(\{\sigma_i\}\cup E_i\) is prefix-free, then \(E_{i+1}=E_i\)

    If not, then there is \(\{\tau_1,\dots,\tau_m\}\subset E_i\), \(\sigma\prec\tau_j\), \(1\le j\le m\), then let \(E_{i+1}=\{\sigma\}\cup E_i\setminus\{\tau_1,\dots,\tau_m\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. Cantor space is a closed in \(\R\)
    2. Cantor space is the infinite product of discrete space \(\{0,1\}\), that is, \(\{0,1\}^\omega\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. Every cylinder set is clopen
    2. Cantor space and every cylinder subspace is compact (closed subspace of a compact subspace is
       compact)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. For subtree \(B\) of \(2^{<\omega}\), \(Paths(B)=\{Z\in 2^\omega\mid Z\text{ is a path in }B\}\) is closed
    2. If \(P\subset 2^\omega\) is closed, \(T_P=\{\sigma\mid[\sigma]\cap P\neq\emptyset\}\) is a tree without dead branch and \(Paths(T_P)=P\)
    3. If \(B\) is a tree without dead branch, then \(B=T_{Paths(B)}\)
    #+END_proposition

    #+BEGIN_proof
    2. [@2] \(T_P\) is a tree. \(\sigma\in T_P\Leftrightarrow[\sigma]\cap P\neq\emptyset\), let \(z\in[\sigma]\cap P\),
       then \(\forall n\), \([z\uhr n]\cap P\neq\emptyset\), therefore \([z\uhr n]\in T_P\).

       \(z\in Paths(T_P)\Leftrightarrow\forall n[z\uhr n]\in T_P\Leftrightarrow\forall n[z\uhr n]\cap P\neq\emptyset\Leftrightarrow z\in P\) since \(P\) is closed

    3. \(\sigma\in B\Rightarrow[\sigma]\cap Paths(B)\neq\emptyset\)
    #+END_proof

    For open set \(U\subset 2^\omega\), let \(P=2^\omega\setminus U\), define
    \begin{equation*}
    A_U=2^{<\omega}\setminus T_P=\{\sigma\mid[\sigma]\subset U\}
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. If \(U\) is open, then \(A_U\) is an ideal: if \(\sigma\in A_U\) and \(\sigma\prec\tau\), then \(\tau\in A_U\);
       if \(\sigma0,\sigma1\in A_U\), then \(\sigma\in A_U\)
    2. If \(I\) is an ideal, then \(I=A_{[I]^{\prec}}\)
    #+END_proposition

    #+BEGIN_proof
    2. [@2] \(\sigma\in I\), \([\sigma]\subset[I]^\prec\), \(\sigma\in A_{[I]^\prec}\).

       \(\sigma\in A_{[I]^\prec}\), \([\sigma]\subset[I]^\prec\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(X\subset 2^\omega\) is clopen iff there is finite \(F\subset 2^{<\omega}\), \(X=[F]^\prec\)
    #+END_proposition

    #+BEGIN_proof
    \(X\) is compact
    #+END_proof

    There is a *measure* in cantor space:
    * \(\forall\sigma\in 2^{<\omega}\), \(\lambda([\sigma])=2^{-\abs{\sigma}}\)
    * for \(U=[E]^\prec\), where \(E\) is prefix-free, \(\lambda(U)=\sum_{\sigma\in E}\lambda([\sigma])\)
    * \(\lambda(2^\omega\setminus U)=1-\lambda(U)\)


    \(M:2^{<\omega}\to 2^{<\omega}\) is a

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    given 解压缩程序\(M:2^{<\omega}\to 2^{<\omega}\), the *Kolmogorov complexity* of \tau on \(M\) is
    \begin{equation*}
    C_M(\tau)=\min\{\abs{\sigma}:M(\sigma)=\tau\}
    \end{equation*}
    #+END_definition

    If \(\tau\notin\ran M\), then \(C_M(\tau)=\infty\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    For any \(M:2^{<\omega}\to 2^{<\omega}\)
    \begin{equation*}
    U(\rho_M\sigma)=M(\sigma)
    \end{equation*}
    \(\rho_M\) is coding of \(M\), \(\abs{\rho_M}\) is the coding constant of \(M\) in \(U\)
    #+END_definition

    #+BEGIN_proof
    Every universal program \(U\) is *optimal*, that is, for any \(M\) there is coding
    constant \(c_M\) s.t. for any \tau,
    \begin{equation*}
    C_U(\tau)\le C_M(\tau)+c_M
    \end{equation*}
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    there is a universal machine
    #+END_theorem

    #+BEGIN_proof
    Let \(\{\Phi_e\}_{e\in\N}\) is a computable enumeration of all machines, let
    \begin{equation*}
    U(\underbrace{0\dots 0}_{e\text{ times}}1\sigma)=\Phi_e(\sigma)
    \end{equation*}
    therefore \(c_e=e+1\)
    #+END_proof

    Fix a universal machine
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The Kolmogorov complexity of \tau is
    \begin{equation*}
    C(\tau)=C_U(\tau)
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c_1,c_2,c_3\), for any \(\tau\)
    1. \(C(\tau)\le\abs{\tau}+c_1\)
    2. \(C(\tau\tau)\le C(\tau)+c_2\)
    3. \(C(h(\tau))\le C(\tau)+c_3\), \(h\) is computable
    #+END_proposition

    #+BEGIN_proof
    1. suppose \(M(\sigma)=\sigma\), then for any \tau, \(C_U(\tau)\le C_M(\tau)+c_M=\abs{\tau}+c_M\)
    2. suppose \(M'(\tau)=\tau\tau\), \(M''(\sigma)=M'(U(\sigma))\), if \(U(\sigma)=\tau\), then \(M''(\sigma)=\tau\tau\)

       \(C(\tau\tau)\le C(\tau)+c_{M''}\)
    3. \(M(\tau)=h(\tau)\), \(M'(\sigma)=M(U(\sigma))\)
    #+END_proof

    \(C(\tau)\le\abs{\tau}+c_{\id}\) gives us an upper bound, therefore we can give a computable
    approximation:
    for any \(\tau\in 2^{<\omega}\), \(s\in\N\),
    \begin{equation*}
    C_s(\tau)=\min(\{\abs{\sigma}:U_s(\sigma)\downarrow=\sigma\}\cup\{\abs{\tau}+c_{\id}\})
    \end{equation*}

    we call \(\la n,\tau\ra\in\N\times 2^{<\omega}\) is a compression request

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    let \(W\) be a c.e. compression request sets, and \(\forall n\), there is at most \(2^n\) \(\tau\in 2^{<\omega}\)
    s.t. \(\la n,\tau\ra\in W\), then there is a \(M\)
    \begin{equation*}
    \la n,\tau\ra\in W\Leftrightarrow\exists\sigma(\abs{\sigma}=n\wedge M(\sigma)=\tau)
    \end{equation*}
    #+END_theorem

    Let \(\log n=\floor{\log_2n}\)

    let \(n=string(n)\), therefore there is \(c\) s.t.
    \begin{equation*}
    C(n)\le\log n+c
    \end{equation*}

    if \(C(\tau)=n\), there is a leftest \(\sigma\in 2^n\) s.t. \(U(\sigma)=\tau\), denoted by \(\tau^*_C\)

    Let \(C(\sigma,\tau)\) denote \(C(\la\sigma,\tau\ra)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is a constant \(c\)
    \begin{equation*}
    C(\tau,C(\tau))\le C(\tau_C^*)+c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(M(\sigma)=\la U(\sigma),\abs{\sigma}\ra\), suppose \(U(\sigma)=\tau^*_C\),
    then \(M(U(\sigma))=\la U(\tau^*_C),\abs{\tau_C^*}\ra=\la\tau,C(\tau)\ra\)

    \(M'=M(U(\sigma))\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    given \(d\in\omega\), \tau is *\(d\)-\(C\)-random* iff
    \begin{equation*}
    C(\tau)\ge\abs{\tau}-d
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. for any \(n\), there is \tau s.t. \(\abs{\tau}=n\) and \(C(\tau)\ge n\)
    2. \(\forall d\in\omega,n\in N\), there is \(2^n-2^{n-d}+1\) \(d\)-\(C\)-random strings of length n
    #+END_proposition

    #+BEGIN_proof
    1. there is \(2^n\) possibilities, but there are only \(2^n-1\) strings of length \(2^{<n}\)
    #+END_proof

    \sigma is semi-random iff \(C(\sigma)\ge\frac{\abs{\sigma}}{2}\)

    intuitively, the information of \(\sigma\tau\) shouldn't greater than the sum of \sigma of \tau. Therefore we
    wish that
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma)+C(\tau)+c
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    \(\forall d\in\N\) there is \mu s.t. \(C(\mu)\ge\abs{\mu}\) and for all such \mu, there is \(\sigma\prec\mu\), \(\mu=\sigma\tau\) and
    \begin{equation*}
    C(\mu)>C(\sigma)+C(\tau)+d
    \end{equation*}
    #+END_theorem

    #+ATTR_LATEX: :options []
    #+BEGIN_lemma
    \(\exists c_M\in\N\),\(\forall k\in\N\), there is \(\mu\) (\(\abs{\mu}\ge 2^{k+c_M+1}+k+c_M+1\)) there is \(\sigma\prec\mu\) s.t. \(C(\sigma)<\abs{\sigma}-k\)
    #+END_lemma

    #+BEGIN_proof
    Consider \(M\): input \rho, output \(M(\rho)=\nu\rho\) where \nu is the binary form
    of \(\abs{\rho}\), \(\forall\sigma\in\ran M\), we can write \sigma as \(\nu\rho\)
    and \(C(\sigma)\le C_M(\sigma)+c_M=\abs{\rho}+c_M=\abs{\sigma}-\abs{\nu}+c_M\). Given \(k\in\N\) and a sufficiently long
    \mu, let \(\nu=\mu\uhr k+c_M+1\), let \(n\) be the integer represented by \nu,
    let \(\rho=\mu\uhr[k+c_M+1,k+c_M+1+n)\), since \(\abs{\sigma}=k+c_M+1\),
    therefore \(n\in[2^{k+c_M},2^{k+c_M+1})\), therefore definition of \rho is valid. Finally
    let \(\sigma=\nu\rho\), then
    \begin{equation*}
    C(\sigma)\le\abs{\sigma}-\abs{\nu}+c_M=\abs{\Delta}-(k+c_M+1)+c_M<\abs{\Delta}-k
    \end{equation*}
    #+END_proof

    #+BEGIN_proof
    Given \(d\), let \(k=d+c_{\id}\), there is \mu s.t. \(\abs{\mu}\ge 2^{k+c_M+1}+k+c_M+1\)
    and \(C(\mu)\ge\mu\), by Lemma, there is \(\sigma\prec\mu\) s.t. \(C(\sigma)<\abs{\sigma}-k\). Let \(\mu=\sigma\tau\).

    \(\forall\tau\) there is \(C(\tau)\le\abs{\tau}+c_{\id}\),
    therefore \(C(\mu)\ge\abs{\mu}=\abs{\sigma}+\abs{\tau}\ge\abs{\sigma}+C(\tau)-c_{\id}>C(\sigma)+C(\tau)-c_{\id}+k=C(\sigma)+C(\tau)+d\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c\) s.t. \(\forall\sigma,\tau\in 2^{<\omega}\)
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma,\tau)+c
    \end{equation*}
    #+END_proposition

    Therefore there is no \(c\) s.t. \(C(\sigma,\tau)\le C(\sigma)+C(\tau)+c\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    There is \(c\) s.t. \(\forall\sigma,\tau\in 2^{<\omega}\)
    \begin{equation*}
    C(\sigma,\tau)\le C(\sigma)+C(\tau)+2\log C(\sigma)+c
    \end{equation*}
    and there is \(c\) s.t.
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma)+C(\tau)+2\log C(\sigma)+c
    \end{equation*}
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    *Kolmogorov complexity of \sigma relative to \tau*
    \begin{equation*}
    C(\sigma|\tau)=\min\{\abs{\mu}:U^{\bar{\tau}}(\mu)=\sigma\}
    \end{equation*}
    where \(\bartau=\tau_0\tau_0\dots\tau_{\abs{\tau}-1}\tau_{\abs{\tau}-1}01\)
    #+END_definition

    We wish that \(C(\sigma\mid\sigma)\) is a constant

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. \(C\le_{wtt}0'\)
    2. \(B=\{\sigma\in 2^{<\omega}\mid C(\sigma)<\abs{\sigma}\}\) is simple set and \(wtt\)-complete (\(0'\le_{wtt}B\))
    3. \(C\) is not computable
    #+END_proposition

    #+BEGIN_proof
    1. \(C(x)\) can be approximated from top to
       down. \(C_s(x)=\min\{\abs{\sigma}\mid U_s(\sigma)\downarrow=x\}\cup\{\abs{x}+c_{\id}\}\)

       therefore the value of \(C_s(x)\) can change \(\abs{x}+c_{\id}\) times.

       Let \(R=\{(x,i)\mid C_s(x)\text{ has changed $i+1$ times}\}\), \(R\) is c.e., and \(C\le_TR\le_m0'\)

       In \(C\le_TR\), we ask whether \((x,i)\in R\) at most \(\abs{x}+c_{\id}\) times, therefore \(c\le_{wtt}R\)

    2. \(B\) is c.e. \(\N\setminus B\) is infinite since for any \(n\), there is \(\sigma\), \(\abs{\sigma}=n\)
       and \(C(\sigma)\ge n=\abs{\sigma}\), therefore \(\sigma\notin B\)

       Suppose \(\N\setminus\) contains an infinite c.e. set \(A\), there
       is \(A_0=\{a_0,a_1,\dots\}\subseteq A\), \(\la a_i\ra_{i\in\N}\) computable,
       and \(a_0<a_1<\dots\), \(\log a_0<\log a_1<\dots\), therefore \(\forall i\in\N\), \(\abs{a_i}=\log a_i\ge i\).
       There is \(c,d\) s.t. \(C(a_i)\le C(i)+c\le\log i+d\).

       Note that for a\(a_i\in A_0\subseteq A\subseteq\N\setminus\), \(C(a_i)\ge\abs{a_i}\)

        for sufficiently large \(i\), \(C(a_i)\le\log i+d<i\le\abs{a_i}=\log a_i\)

        construct a c.e. request set \(W\): if \(n\in 0'_s\setminus 0'_{s-1}\), then \((n,x)\in W\) where \(x\)
        is the leftest string s.t. \(\abs{x}=2n\) and \(C_s(x)\ge 2n\) (there is \(\abs{x}=2n\)
        s.t.\(C(x)\ge 2n\)). \(W\) is a valid request set. Let \(M\) be the program implementing \(W\).

        In  order to compute \(0'(n)\), we use \(B\) to compute a \(s\) s.t. for any \(x\),
        if \(\abs{x}=2n\), then \(B_s(x)=B(x)\)

        Then we claim that \(0'_s(n)=0'(n)\). Suppose there is \(t>s\) s.t. \(n\in 0'_t\setminus 0'_{t-1}\),
       then there is \(x\) s.t. \(\abs{x}=2n\) and \(C_s(x)\ge 2n\) but \(C(x)\le C_M(x)+C_M=n+c_M\).
       If \(n\) is sufficiently large, then \(C(x)=n+c_M<2n\), \(x\in B(x)\setminus B_s(x)\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(M\) is prefix-free if its domain is prefix-free
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    there is an effective enumeration \(\{\Psi_e\}_{e\in\N}\) for all prefix-free machine, therefore there is
    a universal prefix-free machine \(U^{\pf}\) s.t.
    \begin{equation*}
    U^{\pf}(\underbrace{1\dots 1}_{e}0\sigma)=\Psi_e(\sigma)
    \end{equation*}
    #+END_theorem

    #+BEGIN_proof
    If \(\{\Phi_e\}_{e\in\N}\) is an enumeration of all machine and suppose \(\abs{\dom\Phi_{e,s}\setminus\Phi_{e,s-1}}\le 1\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    prefix Kolmogorov complexity
    \begin{equation*}
    K(\sigma)=K_{U^{\pf}}(\sigma)=C_{U^{\pf}}(\sigma)
    \end{equation*}
    and
    \begin{equation*}
    K(\tau|\sigma)=\min\{\abs{\mu}\mid(U^{\pf})^{\barsigma}=\tau\}
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c\), \(\forall \tau_1,\tau_2\in 2^{<\omega}\)
    \begin{equation*}
    K(\tau_1,\tau_2)\le K(\tau_1)+K(\tau_2)+c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    Consider \(M\): \(\forall\sigma_1\sigma_2\), \(M(\sigma_1,\sigma_2)=\la U^{\pf}(\sigma_1),U^{\pf}(\sigma_2)\ra\), if \(\mu\prec\mu'\)
    and \(M(\mu)\downarrow\), \(M(\mu')\downarrow\), then there is \(\sigma_1\prec\mu\), \(\sigma_1'\prec\mu'\), \(U^{\pf}(\sigma_1)\downarrow\)
    #+END_proof

    \(C(\sigma)\le K(\sigma)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    If \(h:2^{<\omega}\to 2^{<\omega}\) is computable, then \(\exists c\) for all \sigma, \(K(h(\sigma))\le K(\sigma)+c\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(\exists c_1,c_2\in\N\), \(\forall\sigma\)
    \begin{equation*}
    K(\sigma)\le K(\abs{\sigma})+\abs{\sigma}+c_1\le 2\log\abs{\sigma}+\abs{\sigma}+c_2
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(M(\ove{\abs{\sigma}}\sigma)=\sigma\)
    #+END_proof


    #+BEGIN_proof
    take \(M(\ove{\abs{\sigma}}\sigma)=\sigma\). If \(M\) is not prefix free,
    suppose \(\ove{\abs{\sigma}}\sigma\prec\ove{\abs{\tau}}\tau\), then \(\abs{\sigma}=\abs{\tau}\), then \(\sigma=\tau\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(\forall d\exists\sigma\)
    \begin{equation*}
    K(\sigma)>\abs{\sigma}+\log\abs{\sigma}+d
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    if there is \(d\), \(\forall \sigma\), \(K(\sigma)\le\abs{\sigma}+\log\abs{\sigma}+d\)
    \begin{equation*}
    \sum_{\sigma\in 2^{<\omega}}2^{-K(\sigma)}\le\sum_{\tau\in\dom U^{\pf}}2^{-\abs{\tau}}=\lambda([\dom U^{\pf}]^{\prec})\le 1
    \end{equation*}
    现在
    \begin{equation*}
    \sum_{\sigma\in 2^{<\omega}}2^{-K(\sigma)}\ge\sum_{\sigma\in 2^{<\omega}}2^{-(\abs{\sigma}+\log\abs{\sigma}+d)}=
    \sum_{n=1}^\infty 2^n\cdot 2^{-(n+\log n+d)}=2^{-d}\sum_{i=1}^n\frac{1}{n}
    \end{equation*}
    #+END_proof

    *Chaitin's constant*
    \begin{equation*}
    \Omega=\lambda([\dom U^{\pf}]^{\prec})
    \end{equation*}
    for any prefix machine \(M\), let \(\Omega_M=\lambda([\dom M]^{\prec})\)为\(M\)的停机概率

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    sequence \(\{\la d_i,\tau_i\ra\}_{i\in\N}\) computable, \(d_i\in\N\), \(\tau_i\in 2^{<\omega}\), if \(\sum_{i\in\N}2^{-d_i}\le 1\),
    then \(\{\la d_i,\tau_i\ra\}_{i\in\N}\)is a 请求序列, where \(\sum_{i\in\N}^{-d_i}\le 1\) is *weight condition*
    #+END_definition

    #+ATTR_LATEX: :options [Chaitin]
    #+BEGIN_lemma
    for any 请求序列\(\{\la d_i,\tau_i\ra\}_{i\in\N}\), there is a prefix free machine \(M\) satisfying the sequence,
    i.e., there is prefix free set \(\{\sigma_i:i\in\N\}=\dom M\), and for all \(i\in\N\), \(M(\sigma_i)=\tau_i\), \(\abs{\sigma_i}=d_i\)
    #+END_lemma

    #+BEGIN_proof
    define \(S_i\) and \(S_i^*\) 记录可分配的 “号码库”与已分配的号码

    /step 0/: let \(S_0=\{\emptyset\}\), \(S^*_0=\emptyset\)

    recursively define \(S_i\) and \(S_i^*\) s.t.
    1. \(S_i^*\cup S_i\) is prefix-free
    2. \(S_i^*\cup S_i\)  is finite
    3. \(\lambda([S_i^*\cup S_i]^{\prec})=1\)
    4. \(\forall n\in\N\), there is at most one \(\sigma\in S_i\) s.t. \(\abs{\sigma}=n\)


    /Step 1/: let \(\sigma_0=0^{d_0}\), let \(S_1=\{1,01,\dots,0^{d_0-1}1\}\), \(S_1^*=\{0^{d_0}\}\)

    /Step \(i+1\)/: hope to satisfy \((d_i,\tau_i)\),
    1. there is \(\sigma\in S_i\) s.t. \(\abs{\sigma}=d_i\), let \(\sigma_i=\sigma\), \(S_{i+1}=S_i\setminus\{\sigma_i\}\), \(S_i^*=S_i^*\cup\{\sigma_i\}\)
    2. if not, find largest \(n\) s.t. \(n<d_i\) and there is \(\sigma\in S_i\), \(\abs{\sigma}=n\)

       *Claim*: we can always find such \(n\) and \sigma

       Otherwise \(\lambda([S_i]^{\prec})<\sum_{n>d_i}2^{-n}=2^{-d_i}\) (by 2 and 4),
       then \(\lambda([S_i^*]^{\prec})=\sum_{j<i}2^{-d_j}>1-2^{-d_i}\), then \(\sum_{j\le i}2^{-d_j}>1\), contradicing
       请求序列

       let \(\sigma_i=\sigma 0^{d_i-n}\), \(S_{i+1}^*=S_i^*\cup\{\sigma_i\}\), \(S_{i+1}=S_i\setminus\{\sigma\}\cup\{\sigma 1,\dots,\sigma 0^{d_i-n-1}1\}\)


    Now let \(\dom M=\bigcup_i S_i\) and \(M(\sigma_i)=\tau_i\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    If there is 请求序列\(\{\la d_i,\tau_i\ra:i\in\N\}\), then there is \(c\in\N\) for all \(i\in\N\)
    \begin{equation*}
    K(\tau_i)\le d_i+c
    \end{equation*}
    #+END_corollary

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    * for a fixed \(d\in\N\), \sigma is *\(d\)-\(K\)-random* iff
      \begin{equation*}
      K(\sigma)\ge\abs{\sigma}-d
      \end{equation*}
    * \(Z\in 2^\omega\) is *1-random* iff \(\exists d\in\N\) s.t. any finite initial segment of \(Z\) is \(d\)-random,
      i.e., \(\forall n\in\N\)
      \begin{equation*}
      K(Z\uhr n)\ge n-d
      \end{equation*}
    #+END_definition

    this is impossible for \(C\)

    for \(s\in\N\), let
    \begin{equation*}
    \Omega_s=\lambda([\{\sigma:U_s^{\pf}(\sigma)\downarrow\}]^\prec)
    \end{equation*}
    \(s\mapsto\Omega_s\) is computable, \(\Omega_s\le\Omega_{s+1}\le\Omega\) and \(\Omega=\lim_{s\to\infty}\Omega_s\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(Z\in 2^\omega\), let \(L(Z)=\{\sigma\in 2^{<\omega}:\sigma<_LZ\}\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    View \Omega in binary extension, then \(L(\Omega)\) is c.e.
    #+END_proposition

    #+BEGIN_proof
    \(L(\Omega)=\bigcup[\Omega_s\cup L(\Omega_s)]\)

    Let \(A_s=\{\sigma\in 2^{<s}\mid\sigma<_L\Omega_s\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(Z\in 2^\omega\) (real \(r=z.Z\), \(z\in\Z\))is *left c.e.* iff \(L(Z)\) is c.e.
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. TFAE
       1. \(Z\) left c.e.
       2. there is computable \(\sigma_0<_L\sigma_1<\dots\) s.t. \(\lim_n\sigma_n=Z\), that is, \(\forall m\in\N\) there is \(\sigma_n\)
          s.t. \(\sigma_n\uhr m=Z\uhr M\)
    2. if \(Z\) (as a characteristic function) is c.e., then \(Z\) is left c.e.
    #+END_proposition

    \(0\le_L00\), \(\sigma\prec\tau\Rightarrow\sigma\le_L\tau\)

    #+BEGIN_proof
    1. \(\Rightarrow\):

       \(\Leftarrow\): let \(A_s=\{\tau\in 2^{<s}\mid\tau<_L\sigma_s\}\), then \(\bigcup_sA_s=L(Z)\)
    #+END_proof

    not all left c.e. set is c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    let
    \begin{equation*}
    A_0=010101\cdots
    \end{equation*}
    run \(\Phi_{e,s}(2e+1)\), assume for all \(s\in\N\), there is at most one \(e\le s\) s.t. \(\Phi_e(2e+1)\)
    runs. If \(A_s\) is defined, then \(A_{s+1}\) is: if \(\Phi_{e,s}(2e+1)\downarrow\),
    then \(A_{s+1}(2e)=1\), \(A_{s+1}(2e+1)=0\), the rest is the same as \(A_s\),
    let \(A=\lim_sA_s\)

    If \(A=W_e\), \(2e+1\in W_e\), then \(A(2e)=1\), \(A(2e+1)=0\), \(A\neq W_e\)

    If \(2e+1\notin W_e\), then \(A(2e+1)=1\), \(A\neq W_e\)
    #+END_examplle

    actually \(A\) is 2-c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. if \(Z\) is left c.e., then \(Z\le_T0'\)
    2. \(\Omega\equiv_T0'\)
    #+END_proposition

    #+BEGIN_proof
    1. input \(n\), to determine whether \(n\in Z\), ask \(0'\) whether those 01-string of
       length \(n+1\) are belong to \(L(Z)\)

       if there is \tau of length \(n\) and \(\tau 0\in L(Z)\), \(\tau 1\notin L(Z)\), then output \(n\in Z\),
       otherwise \(n\notin Z\)

       therefore \(Z\le_{tt}0'\Rightarrow\) \(Z\) is \omega-c.e.

    2. Goal: \(0'\le_T\Omega\)

       Consider: input \(0^e1\), run \(\Phi_e(e)\), if \(\Phi_e(e)\downarrow\), let \(M(0^e1)=\la\ra\), otherwise \(M\)
       doesn't stop, \(\dom M\subseteq\{0^e1\mid e\in 0'\}\), therefore \(M\) is prefix-free, assume \(M=\Psi_d\),
       let \(\rho=0^d1\) be \(M\)'s coding string, then \(U^{\pf}(\rho 0^e1)=M(0^e1)\),

       then to determine whether \(e\in 0'\), we only need to know whether \(\rho 0^e1\in\dom U^{\pf}\).
       Compute \(s\) s.t. \(\Omega\setminus\Omega_s<2^{-\abs{\rho}-e-1}\). Since \(\lim_s\Omega_s=\Omega\), we can always find
       such \(s\), then \(U_s^{\pf}(\rho 0^e1)\downarrow\Leftrightarrow U^{\pf}(\rho 0^e1)\downarrow\Leftrightarrow e\in 0'\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \Omega is 1-random, that is there is \(c\in\N\), for all \(n\in\N\)
    \begin{equation*}
    K(\Omega\uhr n)\ge n-c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    for any \tau, if \(\abs{\tau}<n-c\), then \(U^{\pf}(\tau)\neq\Omega\uhr n\)

    if \(U^{\pf}(\tau)=\Omega\uhr n\), then there is \(s\) s.t. \(U^{\pf}_s(\tau)=\Omega_s\uhr n=\Omega\uhr n\)

    We need to eliminate all sufficiently short \tau satisfying this

    Let \(\Phi_e(\tau,d)\) compute all \(U^{\pf}_s(\tau)\) and \(\Omega_s\), if we find \(s,n\)
    s.t. \(U^{\pf}_s(\tau)=\Omega_s\uhr n\) and \(\abs{\tau}<n-d-1\), then output smallest \(\mu\notin\ran U^{\pf}_s\)

    By smn, there is recursive function \(g\) s.t. \(\Phi_{g(e,d)}(\tau)=\Phi_e(\tau,d)\), by fixed point
    theorem, there is a fixed point \(c_e\) of \(g(e,x)\) s.t. \(\Phi_{c_e}(\tau)=\Phi_{g(e,c_e)}(\tau)=\Phi_e(\tau,c_e)\)

    Suppose there is \(s,n\) s.t. \(U^{\pf}_s(\tau)\downarrow=\Omega_s\uhr n\) and \(\abs{\tau}<n-c_e-1\),
    then \(\Phi_{c_e}(\tau)=\mu\notin\ran U^{\pf}\). By definition, \(\dom\Phi_{c_e}\subseteq\dom U^{\pf}\),
    therefore \(\Phi_{c_e}\) is prefix-free, we may assume \(f\) is the function transform machine to
    prefix-free function, then \(\Phi_{c_e}=\Phi_{f(c_e)}=\Psi_{c_e}\), let \(\nu=1^{c_e}0\tau\),
    then \(U^{\pf}(\nu)=\Psi_{c_e}(\tau)=\Phi_{c_e}(\tau)=\mu\), but \(\mu\not\in\ran U_s^{\pf}\),
    therefore \(\nu\in\dom U^{\pf}\setminus\dom U_s^{\pf}\),
    therefore \(\Omega-\Omega_s\ge 2^{-\abs{\nu}}=2^{-(c_e+1+\abs{\tau})}>2^{-n}\), then \(\Omega_s\uhr n\neq\Omega\uhr n\)
    #+END_proof


    let \(f:\N\to\N\) be a strictly increasing computable function. 如果\(A\)每第\(f(i)\)位都是0，那
    么\(A\) *不是随机的* ，我们构造一个 *测试* 来排除这样的序列\(A\)，对每个\(k\)测试是否有对任
    意\(i\le k\)， \(A(f(i))=0\)，如果存在\(A(f(i))=1\)，\(A\) *通过测试*

    对每个\(k\)，令
    \begin{equation*}
    U_k=\bigcap_{i\le k}[\{\sigma\in 2^{f(i)+1}:\sigma(f(i))=0\}]^{\prec}
    \end{equation*}
    若存在\(k\)使得\(A\notin U_k\)，则\(A\)通过测试，若\(A\in\bigcap_kU_k\)则\(A\)未通过测试，不是随机的

    \(\lambda(U_k)=2^{-(k+1)}\)，故\(\lambda(\bigcap_kU_k)=\lim_{k\to\infty}2^{-k-1}=0\)

    随机序列应该满足大数定律，给定无论多小的正实数\(\epsilon\)，我们可以设计一个测试来排除其中1的数量占
    比\(\ge 1/2+\epsilon\)的序列，对\(m\in\N\)，定义
    \begin{equation*}
    C_m=\{\sigma\in 2^{m+1}:\frac{\sum_{i=0}^m\sigma(i)}{m+1}\ge 1/2+\epsilon\}
    \end{equation*}
    对于\(n\in\N\)，定义\(U_n=\bigcup_{m\ge n}[C_m]^{\prec}\)，
    则\(A\in\bigcap_{n\in\N}U_n\Leftrightarrow\ove{\lim}_{n\to\infty}\frac{\sum_{i=0}^nA(i)}{n}\ge 1/2+\epsilon\)

    根据Hoeffding inequality
    \begin{equation*}
    \lambda([C_m]^{\prec})\le(2^{-2\epsilon^2})^m
    \end{equation*}
    \begin{equation*}
    \lambda(U_n)\le\frac{(e^{-2\epsilon^2})^n}{1-e^{-2\epsilon^2}}
    \end{equation*}
    \(\lambda(\bigcap_nU_n)=0\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(U\subset 2^\omega\) is *c.e. open* (\(\Sigma_1^0\) set) iff there is (prefix free) \(E\subseteq 2^{<\omega}\)
    s.t. \(U=[E]^{\prec}\). \(P\) is *co-c.e. closed* iff its complement is c.e. open
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(\{U_n\}_{n\in\omega}\) of open set (\(U_n=[E_n]^{\prec}\)) is *uniformly c.e. open* iff
    \begin{equation*}
    \{\la n,\sigma\ra\mid[\sigma]\subset U_n\}
    \end{equation*}
    is c.e.

    This is equivalent to there is a sequence of \(E_n\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. \(\{U_n\}_{n<\omega}\) uniformly c.e. open, 对任意\(n\),\(\lambda(U_n)\le 2^{-n}\)，则称\(\{U_n\}_{n<\omega}\)
       是一个 *马丁-洛夫测试*
    2. \(Z\in 2^\omega\)通过马丁洛夫测试当且仅当\(Z\notin\bigcap_{n<\omega}U_n\)
    3. \(Z\in 2^\omega\)是 马丁洛夫随机的 当且仅当\(Z\)通过所有的马丁洛夫测试
    #+END_definition

    #+BEGIN_remark
    1. 马丁洛夫测试定义中的有关能行性的限制是必要的，否则所有序列都不是随机：令\(Z\in 2^\omega\)是任意序列，
       \(\lambda([Z\uhr n]^{\prec})=2^{-n}\)
    2. 可以减弱\(\lambda(U_n)\le 2^{-n}\)：存在以正有理数为值域的递归函数\(f:\N\to\Q\)且\(\lim_{n\to\infty}f(n)=0\)，使
       得对任意\(n\in\N\)，有\(\lambda(U_n)\le f(n)\)

       如果有这样的\(f\)，对每个\(n\)，找足够大的\(N\)，就是找个\(U_n\)的子序列
    3. 也可增加要求\(U_0\supset U_1\supset\dots\)
    #+END_remark

    假设\(Z\in 2^\omega\)是可计算的，令\(U_n=[Z\uhr n]\)，则\(\{U_n\}_{n<\omega}\)是统一递归可枚举的，并
    且\(\lambda(U_n)\le 2^{-n}\)，\(\bigcap_nU_n=\{Z\}\)，因此\(Z\)没有通过这个测试

    前面的例子说明，马丁-洛夫随机的序列都满足大数定律，

    #+ATTR_LATEX: :options []
    #+BEGIN_lemma
    \(M\) prefix free, \(\forall k\in\N\), let \(S_k=\{\sigma:K_M(\sigma)\le\abs{\sigma}-k\}\), then
    1. \(\lambda([S_k]^{\prec})\le 2^{-k}\lambda([\dom M]^{\prec})\)
    2. \(\forall k\in\N\),\(\lambda([S_k]^{\prec})\)可以统一图灵归约到\(\lambda([\dom M]^\prec)\)
    #+END_lemma

    #+BEGIN_proof
    1. 自然

       \(\forall\sigma\in S_k\),\(\exists\sigma^*\in\dom M\),
       \(M(\sigma^*)=\sigma\),\(\abs{\sigma^*}\le\abs{\sigma}-k\),\(\lambda([\sigma^*])\ge 2^{-\abs{\sigma}+k}\),

       \(\lambda([\dom M]^{\prec})\ge\sum_{\sigma\in S_k}\lambda([\sigma^*])\ge\sum_{\sigma\in S_k}2^{-\abs{\sigma}+k}\ge 2^k\sum_{\sigma\in S_k}2^{-\abs{\sigma}}=2^k\lambda([S_k]^{\prec})\)
    2. 要算一个实数\(\lambda([S_k]^{\prec})\)，即对任意\(c\in\N\)，能算出一个有理数\(q\in\Q\)使
       得\(\lambda([S_k]^{\prec})-q<2^{-c}\)

       考虑程序：枚举\(\dom M\)直到发现\(F\subseteq\dom M\)使得\(\lambda([\dom M]^\prec)-\lambda([F]^\prec)<2^{-c+k}\)

       令\(E_0=\{\sigma\mid\sigma^*\in F\wedge\abs{\sigma^*}\le\abs{\sigma}-k\}\subseteq S_k\)

       只需验证\(\lambda([S_k]^\prec)-\lambda([E_0]^\prec)<2^{-c}\)
       \begin{align*}
       \lambda([S_k]^\prec)-\lambda([E_0]^\prec)&\le(\lambda([\dom M]^\prec)-\lambda([F]^\prec))\cdot 2^{-k}\\
       &= 2^{-c}
       \end{align*}
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    序列\(Z\) 是马丁-洛夫随机当且仅当\(Z\)是1-随机
    #+END_theorem

    #+BEGIN_proof
    \(\Rightarrow\): 要证明存在\(d\)使得对任意\(n\)使得\(K(Z\uhr n)>n-d\)

    考虑一个test：对\(k\in\N\)，令\(U_k=\{Z\in 2^\omega:\exists nK(Z\uhr n)\le n-k\}\)，

    *Claim* ：\(\{U_k\}_{n\in\omega}\)是 uniformly c.e. open (枚举所有的\(\sigma\)使得\(K(\sigma)\le n-k\))

    \(\lambda(U_k)\le 2^{-k}\cdot\Omega\le 2^{-k}\)

    则\(Z\)能通过测试，因此\(Z\notin\bigcap_kU_k\)，即存在\(k\)，\(Z\notin U_k\)

    \(\Leftarrow\): 反设\(Z\)不是马丁洛夫随机的，要证\(Z\)不是1-随机的，则存在\(\{U_n\}_{n\in\N}\)使得\(Z\in\bigcap_nU_n\)，
    令\(\{E_n\}_{n\in\N}\)是uniformly c.e.的无前束集合使得\(U_n=[E_n]^\prec\)，记\(E_n=\{\sigma_i^n:i\in N_n\}\)其
    中\(N_n=\N\)

    考虑请求序列：\(\{(\abs{\sigma^n_i}-n,\sigma^n_i)\mid n\in\N,i<N_n\}\)

    则\(\lambda(U_k)=\sum_{i<N_n}2^{-\abs{\sigma_i^n}}\)，不妨设\(\lambda(U_k)\le 2^{-2k-1}\)，则
    \(\sum_{n\in\N,i<N_n}2^{-\abs{\sigma_i^n}+n}=\sum_{n\in\N}=\sum_{n\in\N}2^{-n}\cdot\sum_{i<N_n}2^{-\abs{\sigma_i^n}}\le \sum_{n\in\N}2^{-n-1}\le 1\)

    由无前束程序存在定理，存在无前束程序\(M\)满足该请求序列，即对任意\(\sigma_i^n\)，
    \(K_m(\sigma^n_i)\le\abs{\sigma^n_i}-n\)，对任意\(b\in\N\)令\(n=b+c_M+1\)，由\(Z\in U_n\)，存在\(\sigma_i^n\prec Z\)
    \(K(\sigma_i^n)\le K_M(\sigma_i^n)+c_M\le\abs{\sigma_i^n}-(b+c_M+1)+c_M\le\abs{\sigma^n_i}-b\)，故\(Z\)不是1-随机的
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    一个马丁洛夫测试是 *通用的马丁洛夫测试* 当且仅当对任意\(\{V_n\}_{n\in\omega}\)
    \begin{equation*}
    \bigcap_nV_n\subset\bigcap_nU_n
    \end{equation*}
    #+END_definition


    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    存在通用的马丁-洛夫测试
    #+END_theorem

    #+BEGIN_proof
    首先尝试统一地枚举所有的 ML-test

    令\(\{\la U_n^e\ra_{n\in\N}:e\in\N\}\)是 统一 c.e. open集合的统一枚举，统一枚举\(\{W_e\}_{e\in\N}\)，
    把\(W_e\)看作\(\{\la n,\sigma\ra\mid[\sigma]\subset U_n\}\)

    对每个\(U^e_n\)加一个过滤，得到\(V^e_n\)一旦出现有\((n,\sigma)\)进\(U_n^e\)使得\(\lambda(U^e_{n,s})>2^{-n}\)，
    就阻止其尽如\(V_n^e\)

    由此\(\{\{V_n^e\}_{n\in\N}:e\in\N\}\)是对所有 ML-test 的统一枚举

    令\(U_n=\bigcup_{e\in\N}V^e_{n+e+1}\)则\(\lambda(U_n)\le\sum_e\lambda(V^e_{n+e+1})\le 2^{-n}\)，不难验证\(\{U_n\}\)是通用的 ML-test
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    令MLR是所有马丁-洛夫随机序列组成的集合，则\(\lambda(MLR)=1\)，\(MLR\)是一个\(\Sigma_2^0\)的集合
    #+END_corollary

    #+ATTR_LATEX: :options [solovay randomness]
    #+BEGIN_definition
    1. \(\{S_n\}_{n\in\N}\) uniformly c.e. open set sequence and \(\sum_{n\in\N}\lambda(S_n)<\infty\),
       then \(\{S_n\}_{n\in\N}\) is a *Solovay test*
    2. \(Z\) is *Solovay random* if for any Solovay test \(\{S_n\}_{n\in\N}\) there is finitely
       many \(S_n\) containing \(Z\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    \(Z\) is Solovay random iff \(Z\) is ML-random
    #+END_theorem

    #+BEGIN_proof
    \(\Rightarrow\): if \(Z\) is not ML-random, then there is a ML-test \(\{U_n\}_{n\in\N}\) s.t. \(Z\in\bigcap_nU_n\) ,
    then \(\{U_n\}_{n\in\N}\) is a Solovay test.

    \(\Leftarrow\): if \(Z\) is not S-R, there is a S-test \(\{S_n\}_{n\in\N}\) and infinitely many \(n\)
    s.t. \(Z\in S_n\), \(\sum_{n\in\N}\lambda(S_n)<\infty\)，不妨设\(\sum_{n\in\N}\lambda(S_n)<1\)：不妨令\(m\le\sum< m+1\)，则存在有
    穷\(N\)使得\(\sum_{n\in\N}\ge m\),则存在有穷\(N\)使得\(\sum_{n\in N}\ge m\)，

    考虑\(U_k=[\{\sigma\mid\exists\ge 2^k\text{s }n.[\sigma]\subseteq S_n\}]^\prec\)，则\(\lambda(U_k)\le 2^{-k}\)，可以验证\(\{U_k\}_{n\in\N}\)是
    ML-test

    对任意\(k\)存在\(m_k\)使得\([Z\uhr m_k]\)包含于至多\(2^k\)个\(S_n\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    令\(d:2^{<\omega}\to\R^{\ge 0}\)函数
    * \(d\)是一个 *鞅* (martingale)当且仅当对任意\(\sigma\)有
      \begin{equation*}
      d(\sigma)=\frac{d(\sigma 0)+d(\sigma 1)}{2}
      \end{equation*}
    * 称\(d\)是一个 *上鞅* （supermartingale）当且仅当
      \begin{equation*}
      d(\sigma)\ge\frac{d(\sigma 0)+d(\sigma 1)}{2}
      \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    * 一个（上）鞅在序列\(Z\in 2^\omega\)上 *获胜* 当且仅当
      \begin{equation*}
      \sup_{n\in\N}d(Z\uhr n)=\infty
      \end{equation*}
    * （上）鞅的 *获胜集* 为
      \begin{equation*}
      S[d]=\{A\in 2^\omega:d\text{在\(A\)上获胜}\}
      \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. 假设\(d\)是一个（上）鞅，\(r\in\R^+\)，且函数\(f:2^{<\omega}\to\R^{\ge 0}\)满足\(f=r\cdot d\)，那么\(f\)是一个
       （上）鞅，且\(S[d]=S[f]\)
    2. 若\(d_0,d_1,\dots\)是（上）鞅，且\(\sum_nd_n(\emptyset)<\infty\)，则\(\sum_nd_n\)也是（上）鞅
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_lemma
    假设\(d\)是一个（上）鞅
    1. 对任意\(\sigma\in 2^{<\omega}\)，任意由\(\sigma\)的尾节延伸组成的无前束集合\(S\)，都有
      \begin{equation*}
      \sum_{\tau\in S}2^{-\abs{\tau}}d(\tau)\le 2^{-\abs{\sigma}}d(\sigma)
      \end{equation*}
    2. 令\(E_k=\{\sigma:d(\sigma)\ge k\}\)，则\(\lambda([E_k]^\prec)\le d(\emptyset)/k\)
    #+END_lemma

    #+BEGIN_proof
    1. 考虑\(\abs{S}=1\), \(S=\{\tau\}\), \(d(\tau)\le d(\sigma)\cdot 2^{\abs{\tau}-\abs{\sigma}}\)
，
       假设\(\abs{S}=n\)时成立，对任意\(\sigma\)令\(\nu\succeq\sigma\)是最长的使得对任意\(\tau\in S\), \(\tau\succ\nu\)，考
       虑\(S_0=\{\tau\in S:\tau\succeq\nu 0\}\), \(S_1=\{\tau\in S:\tau\succeq\nu 1\}\)，于是\(S_1,S_0\neq\emptyset\)，因此\(\abs{S_0},\abs{S_1}\le n\)，
       （这里因为\(S\)是无前束的），由归纳假设\(\sum_{\tau\in S_i}2^{-\abs{\tau}}d(\tau)\le 2^{-\abs{\nu}-1}d(\nu i)\)，
       加起来就可以了

       若\(S=\{\tau_0,\tau_1,\dots\}\)且\(\sum_{\tau\in S}2^{-\abs{\tau}}d(\tau)>2^{-\abs{\sigma}}d(\sigma)\)，则存在\(N\)使
       得\(\sum_{i<N}2^{-\abs{\tau_i}}d(\tau_i)>2^{-\abs{\sigma}}d(\sigma)\)，因此\(S\)有穷
    2. 令\(F\subset E_k\)无前束，且\([F]^\prec=[E]^\prec\)，

       \(\lambda([F]^\prec)=\sum_{\tau\in F}2^{-\abs{\tau}}\),\(\sum_{\tau\in F}2^{-\abs{\tau}}d(\tau)\le d(\emptyset)\)，而\(d(\tau)/k\ge 1\)，两边除
       个\(k\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    （上）鞅是 *c.e.* 的当且仅当它的值是统一地左 c.e.的，即存在递归函数\(p:2^{<\omega}\to\N\)任给\(\sigma\in 2^{<\omega}\)，
    c.e.集合\(W_{p(\sigma)}\)可以枚举所有小于\(d(\sigma)\)的二进有理数
    #+END_definition

    #+ATTR_LATEX: :options [施诺尔]
    #+BEGIN_theorem
    序列\(Z\)是ML-R当且仅当不存在c.e.的（上）鞅在\(Z\)上获胜
    #+END_theorem

    #+BEGIN_proof
    在获胜鞅和上鞅是等价的

    \(\Rightarrow\)：给定\(Z\in 2^\omega\)是ML-R的，反设有c.e.的上鞅\(d\)使得\(Z\in S[d]\)，不妨设\(d(\emptyset)=1\)，构造一个
    ML-test\(\{U_n\}_{n\in\N}\)使得\(Z\in\bigcap_nU_n\)。

    对任意\(n\)，令\(U_n=\llb{\{\sigma\mid d(\sigma)\ge 2^n\}}^\prec\)，由于\(d\)是c.e.的，则它是可以从下往上逼进的，如果
    一个\(\sigma\)比\(2^n\)大，就可以在有穷步内发现，因此\(\{U_n\}_{n\in\omega}\)是 uniformly c.e.，由引理，
    \(\lambda(U_n)\le d(\emptyset)/n=2^{-n}\)，故\(\{U_n\}\)是ML-test

    由于\(Z\in S[d]\)，对任意\(n\)，存在\(m\)使得\(d(Z\uhr m)> 2^n\)，故\(Z\in U_n\)，因此\(Z\)不是ML-随
    机

    \(\Leftarrow\)：若\(Z\)不是ML-随机，即存在ML-test\(\{U_n\}_{n\in\N}\)使得\(Z\in\bigcap_nU_n\)，我们要找一个c.e.鞅\(d\)，
    为此设计一组c.e.鞅\(\{d_n\}_{n\in\N}\)，每个\(d_n\)分别押\(Z\in U_n\)，令\(d=\sum_nd_n\)

    设计“自下而上”逼进这些\(d_n\)的算法

    对\(n\)，初始时\(d_n,0\)是常值为0的函数，令\(U_n=\llb{E_n}^\prec\)，\(E_n\)无前束，我们枚
    举\(\{\la n,\sigma\ra\mid\sigma\in E_n\}\)，一旦发现\((n,\sigma)\)被枚举，令\(d_n(\sigma)\)的值+1，对\(\tau\succeq\sigma\)，令
    \(d_n(\tau)\)的值+1，对\(k<\abs{\sigma}\)令\(d_n(\sigma\uhr k)\)的值\(+2^{k-\abs{\sigma}}\)

    顶\(d=\sum_nd_n\)，则\(d(\emptyset)=\sum_{n\in\N}d_n(\emptyset)=\sum_{n\in\N}\sum_{\sigma\in E_n}2^{-\abs{\sigma}}=\sum_{n\in\N}\lambda(\llb{E_n}^\prec)\)
    \(=\sum_{n\in\N}\lambda(U_n)\le\sum_{n\in\N}2^{-n}<\infty\)，故\(d\)是一个 c.e.鞅，故\(Z\in S[d]\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    对任意\(\cala\subset 2^\omega\)，且\(\lambda(\cala)=0\)（即存在开集序列\(\{U_n\}_{n\in\N}\)使得\(\lambda(U_n)\le 2^{-n}\)
    且\(A\subset\bigcap_nU_n\)）当且仅当存在（上）鞅\(d\)使得\(\cala\subset S[d]\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    存在通用c.e.鞅\(d\)即对任意c.e.的鞅\(f\)都有\(S[f]\subset S[d]\)
    #+END_corollary

    #+BEGIN_proof
    令\(\{U_n\}\)是通用的ML-test
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    c.e.的（上）鞅\(d\)是 *最优的* 当且仅当对任意c.e.的（上）鞅\(f\)存在常量\(c_f\)使得对任意\(\sigma\in 2^{<\omega}\)
    有\(c_f\cdot d(\sigma)\ge f(\sigma)\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. 最优的c.e.（上）鞅都是通用c.e.（上）鞅
    2. 存在最优的递归可枚举上鞅
    3. 不存在对所有递归可枚举鞅的能行枚举，不存在最优的递归可枚举鞅
    #+END_proposition

    #+BEGIN_proof
    2. [@2] 存在最优的上鞅

       注意如果一个上鞅是c.e.的，则存在\(e\)使得\(W_e=\{(\sigma,q)\in 2^{<\omega}\times\Q_2\mid q<d(\sigma)\}\)，我们可以统一地枚
       举所有的上鞅，统一地把每个\(W_e\)改造为\(W_{f(e)}\)(\(f\)可计算)：假设已有\(W_{f(e),s}\)，对任
       意\(\sigma\in 2^{<\omega}\)令\(d_{e,s}(\sigma)=\max\{q\mid(\sigma,q)\in W_{f(e),s}\}\)，一旦发
       现\((\sigma,q)\in W_{e,s+1}\setminus W_{e,s}\)且\(q>d_{e,s}(\sigma)\)，监查是否
       有\(\frac{q+d_{e,s}(\sigma^c)}{2}\le d_{e,s}(\sigma^-)\)，其中\(\sigma\)的前驱叫\(\sigma^-\)，它对面的叫\(\sigma^c\)，
       令\(d_{e,s}(\sigma)=q\)且\((\sigma,q)\in W_{f(e),s+1}\)

       不难验证，\(\{d_e\}_{e\in\N}\)枚举了所有的c.e.上鞅，令\(d=\sum_{e\in\N}2^{-e}d_e/d_e(\emptyset)\)，则\(d\)是最优的

    3. 先证明没有对所有c.e.鞅的c.e.枚举，反设\(\{d_e\}_{e\in\N}\)是对所有c.e.鞅的枚举，由此，我们可以递归
       枚举所有非零的鞅\(\{f_i\}_{i\in\N}\)，\(f_i\)是发现的第\(i\)个非零鞅，尝试构造一个非零鞅与这些鞅不同

       令\(d(\emptyset)\)：一旦发现\(f_{0,s}(\emptyset)=q>0\)，令\(d(\emptyset)=q/2\)

       假设对每个\(\tau\in 2^n\)，\(d(\tau)\)已定义，一旦发现有\(\sigma\in 2^{n+1}\)使得\(f_{n+1,s}(\sigma)=q>0\)，
       （故\(f_{n+1}(\sigma)\ge q\)），令\(d(\sigma)=\min\{q/2,d(\sigma^-)\}<q\)，令\(d(\sigma^c)=2d(\sigma^-)-d(\sigma)\)，对其
       它\(\tau\in 2^{n+1}\)，令\(d(\tau)=d(\tau^-)\)，故\(d\neq f_i\) for all \(i\in\N\)

       下证不存在最优的c.e.鞅

       对任意c.e.鞅\(d\)，要证\(d\)不是最优的，要构造一个c.e.鞅\(f\)对任意\(c\)都存在\(\sigma\)使
       得\(f(\sigma)\ge c\cdot d(\sigma)\)

       为此构造一系列\(\{f_n\}_{n\in\N}\)使每个\(f_n(\emptyset)=1\)且存在\(\sigma\)使得\(f_n(\sigma)\ge 2^{2n}\cdot d(\sigma)\)，
       令\(f=\sum_n2^{-n}f_n\)，于是对任意\(n\)有\(\sigma\)使得\(f(\sigma)\ge 2^{2n}2^{-n}d(\sigma)=2^nd(\sigma)\)

       给定\(n\)，造\(f_n\)且找到\(\sigma\)见证\(f_n(\sigma)\ge 2^{2n}d(\sigma)\)，为了找\(\sigma\)，定义一系列\(\sigma_i\)并证
       明某个\(\sigma_i\)可行

       令\(\sigma_0=\emptyset\)，若\(d_s(\emptyset)\le 2^{-2n}\)，令\(f_n(0^s)=2^s\)(all in 0)，对任意\(\tau\in 2^s\)，
       \(\tau\neq 0^s\), \(f_n(\tau)=0\)，若发现\(d_{s_0}(\emptyset)>2^{-2n}\)（\(\sigma_0=\emptyset\)就不能用了），等待\(t_0\)使得
       \(\sum_{\tau\in 2^{s_0+1}}d_{t_0}(\tau)>2^{-2n}\cdot 2^{s_0+1}\)，由于\(d\)是鞅，\(t_0\)存在，此时比
       较\(d_{t_0}(0^{s_0}0)\)与\(d_{t_0}(0^{s_0}1)\)，若\(i\)更小，令\(\sigma_1=0^{s_0}i\)，
       \(t_n(\sigma_1)=2^{s_0+1}=2^{\abs{\sigma_1}}\)，对任意\(\tau\in 2^{s_0+1}\),\(\tau\neq\sigma_1\)，使\(f_n(\tau)=0\)

       一般地，假设\(\sigma_k\)已构造，由归纳，\(f_n(\sigma_k)=2^{\abs{\sigma_k}}\)且\(\abs{\sigma_k}=\sum_{i<k}s_i+1\)，若
       发现\(s_k\)有\(d_{s_k}(\sigma_k)>2^{-2n}\cdot f_n(\sigma_k)=2^{-2n}2^{\abs{\sigma_k}}\)，等\(t_k\)使得
       \(\sum_{\tau\in 2^{s_k+1}}d_{t_k}(\sigma_k\tau)>2^{-2n}2^{\abs{\sigma_k}}2^{s_k+1}\)，由\(d\)是鞅，\(t_k\)总存在，
       设\(d_{t_k}(\sigma_k0^{s_k}i)\le d_{t_k}(\sigma_k0^{s_k}(1-i))\)，令\(\sigma_{k+1}=\sigma_k0^{s_k}i\)，
       令\(f(\sigma_{k+1})=2^{\abs{\sigma_{k+1}}}=2^{\abs{\sigma_k}+s_k+1}=2^{\sum_{i\le k}(S_i+1)}\)，其余的\(\tau\)为0

       *Claim* 存在\(k\)，\(\sigma_k\)有定义，\(f_n(\sigma_k)\ge 2^{2n}d(\sigma_k)\)

       反设对任意\(k\)有\(\sigma_k\)且\(d(\sigma_k)>2^{-2n}f_n(\sigma_k)\)，假
       设\(d(\sigma_{k+1})>2^{-2n}f_n(\sigma_{k+1})\cdot 2^m\)，由构造，在\(t_k\)时，
       \(d_{t_k}(\sigma_{k+1})\le d_{t_k}(\sigma^c_{\sigma+1})\)，
       故\(d_{t_k}(\sigma_{k+1})\le d_{t_k}(\sigma_k)2^{s_k}\le d(\sigma_k)2^{s_k}\)，故
       \(d(\sigma_k)\ge d_{t_k}(\sigma_{k+1})\cdot 2^{-s_k}>f_n(\sigma_{k+1})2^{-2n}2^{-s_k}2^m\)

       \(d(\sigma_k)\ge\sum_{\tau\in 2^{\sigma_{k+1}}}d_{t_k}(\tau)\)
    #+END_proof
