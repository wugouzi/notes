#+TITLE: Computability and Randomness
#+AUTHOR: Andre Nies

#+EXPORT_FILE_NAME: ../latex/ComputabilityAndRandomness/ComputabilityAndRandomness.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \DeclareMathOperator{\use}{\textsf{use}}
#+LATEX_HEADER: \DeclareMathOperator{\Cop}{Cop}
#+LATEX_HEADER: \DeclareMathOperator{\pf}{pf}
#+LATEX_HEADER: \DeclareMathOperator{\non}{\textsf{non}}
#+LATEX_HEADER: \makeindex

* The complexity of sets
** The basic concepts
*** Partial computable functions
    Given expression \alpha, \beta,
    \begin{equation*}
    \alpha\simeq\beta
    \end{equation*}
    means that either both expressions are undefined, or they are defined with the same value

    The function \(\Xi(e,x)\simeq\Phi_e(x)\). A Turing program computing \Xi is called a *universal Turing program*

    #+ATTR_LATEX: :options [Parameter Theorem]
    #+BEGIN_theorem
    For each partial computable function \Theta in two variables there is a computable strictly
    increasing function \(q\) s.t.
    \begin{equation*}
    \forall e\forall x\Phi_{q(e)}(x)\simeq\Theta(e,x)
    \end{equation*}
    An index for \(q\) can be obtained effectively from an index for \Theta
    #+END_theorem

    #+ATTR_LATEX: :options [Padding Lemma]
    #+BEGIN_lemma
    For each \(e\) and each \(m\), one may effectively obtain \(e'>m\) s.t. the Turing
    program \(P_{e'}\) behaves exactly like \(P_e\)
    #+END_lemma

    #+ATTR_LATEX: :options [Recursion Theorem]
    #+BEGIN_theorem
    label:1.1.5
    Let \(g:\N\to\N\) be computable. Then there is an \(e\) s.t. \(\Phi_{g(e)}=\Phi_e\). We say that \(e\) is a
    *fixed point* for \(g\)
    #+END_theorem

    #+BEGIN_proof
    There is \(q\) s.t. \(\Phi_{q(e)}(x)\simeq\Phi_{g(\Phi_e(e))}(x)\) for all \(e,x\). Choose an \(i\)
    s.t. \(q=\Phi_i\), then
    \begin{equation*}
    \Phi_{q(i)}=\Phi_{\Phi_i(i)}=\Phi_{g(\Phi_i(i))}
    \end{equation*}
    #+END_proof

    #+ATTR_LATEX: :options [Recursion Theorem with Parameters]
    #+BEGIN_theorem
    label:1.1.6
    Let \(g:\N^2\to\N\) be computable. Then there is a computable function \(f\), which can be obtained
    effectively from \(g\), s.t. \(\Phi_{g(f(n),n)}=\Phi_{f(n)}\) for each \(n\)
    #+END_theorem

    #+BEGIN_proof
    There is \(g_n\) s.t. \(g_n(f(n))=g(f(n),n)\). Then let \(f(n)\) be the fixed point of \(\Phi_{g'(x)}\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.7
    Extend the Recursion Theorem by showing that computable function \(g\) has infinitely many fixed
    points. Conclude that the function \(f\) in Theorem ref:1.1.6 can be chosen one-one
    #+END_exercise

    #+BEGIN_proof
    There is infinite many \(i\) s.t. \(q=\Phi_i\)
    #+END_proof
*** Computably enumerable sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\subseteq\N\) is *computably enumerable* (*c.e.*) if \(A\) is the domain of some partial computable function
    #+END_definition

    Let
    \begin{equation*}
    W_e=\dom(\Phi_e)
    \end{equation*}
    Then \((W_e)_{e\in\N}\) is an effective listing of all c.e. sets. A sequence of sets \((S_e)_{e\in\N}\)
    s.t. \(\{\la e,x\ra:x\in S_e\}\) is c.e. is called *uniformly computably enumerable*

    \(A\) is called *computable* if its characteristic function is computable; otherwise \(A\) is
    called *incomputable*

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computable \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e.
    #+END_proposition

    We may obtain a c.e. incomputable set denoted \(\emptyset'\) by a direct diagonalization. We
    define \(\emptyset'\) in such a way that \(\N-\emptyset'\) differs from \(W_e\) at \(e\): let
    \begin{equation*}
    \emptyset'=\{e:e\in W_e\}
    \end{equation*}
    The set \(\emptyset'\) is called the *halting problem*, since \(e\in\emptyset'\) iff program \(P_e^1\) halts on input \(e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    The set \(\emptyset'\) is c.e. but not computable
    #+END_proposition

    #+BEGIN_proof
    \(\emptyset'\) is c.e. since \(\emptyset'=\dom(J)\), where \(J\) is the partial computable function given
    by \(J(e)\simeq\Phi_e(e)\). If \(\emptyset'\) is computable then there is \(e\) s.t. \(\N-\emptyset'=W_e\).
    Then \(e\in\emptyset'\leftrightarrow e\in W_e\leftrightarrow e\in\emptyset'\), a contradiction
    #+END_proof

    The sequence \((W_e)_{e\in\N}\) is universal for uniformly c.e. sequences

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    For each uniformly c.e. sequence \((A_e)_{e\in\N}\) there is a computable function \(q\)
    s.t. \(A_e=W_{q(e)}\) for each \(e\)
    #+END_corollary

    #+BEGIN_proof
    Define the partial computable function \Theta by \(\Theta(e,x)\simeq 0\) iff \(x\in A_e\), and \(\Theta(e,x)\) is
    undefined otherwise. Then the function \(q\) obtained by the Parameter Theorem is as required.
    #+END_proof

    #+BEGIN_exercise
    label:1.1.12
    Suppose \((\hatW_e)_{e\in\N}\) is a further universal uniformly c.e. sequence. Assume
    that \((\hatW_e)_{e\in\N}\) also has the padding property, one may effectively obtain \(e'>m\)
    s.t. \(\hatW_e'=\hatW_e\). Show that there is a computable permutation \pi of \(\N\)
    s.t. \(\hatW_e=W_{\pi(e)}\) for each \(e\)
    #+END_exercise

    #+BEGIN_proof
    there is \(q\) s.t. \(W_{q(e)}=\hatW_e\), there is \(p\) s.t. \(\hatW_{p(e)}=W_e\)
    Find
    1. \(q'(e)>e\)
    2. \(q'\) is 1-1
    3. \(W_{q'(e)}=\hatW_e\)


    padding \(\pi(m,e)>m\). \(W_{\pi(e,q(e))}=W_{q(e)}\)

    similar to cantor-bernstein

    or back-and-forth
    #+END_proof
*** Indices and approximations
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write
    \begin{equation*}
    \Phi_{e,s}(x)=y
    \end{equation*}
    if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\) yields \(y\) in at
    most \(s\) computation steps. Let \(W_{e,s}=\dom(\Phi_{e,s})\)
    #+END_definition

    At stage \(s\) we have complete information about \(\Phi_{e,s}\) and \(W_{e,s}\). To state this
    more formally, we need to specify an effective listing \(D_0,D_1,\dots\) of the finite subsets of \(\N\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(D_0=\emptyset\). If \(n>0\) has the form \(2^{x_1}+\dots+2^{x_r}\), where \(x_1<\dots<x_r\), then
    let \(D_n=\{x_1,\dots,x_r\}\). We say that \(n\) is a *strong index* for \(D_n\). For instance, \(D_5=\{0,2\}\)
    #+END_definition

    There is a computable function \(f\) s.t. \(f(e,s)\) is a strong index for \(W_{e,s}\). We think
    of a computable enumeration of a set \(A\) as an effective listing \(a_0,a_1,\dots\) of the elements
    of \(A\) in some order. To include the case that \(A\) is finite, we formalize this via an
    effective union of finite sets \((A_s)\). We view \(A_s\) as the set of elements enumerated by
    the end of stage \(s\). At certain stages we may decide not to enumerate any element

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *computable enumeration* of a set \(A\) is an effective sequence \((A_s)_{s\in\N}\) of (strong
    indices for) finite sets s.t. \(A_s\subseteq A_{s+1}\) for each \(s\) and \(A=\bigcup_sA_s\)
    #+END_definition

    Each c.e. set \(W_e\) has the computable enumeration \((W_{e,s})_{s\in\N}\). Conversely, if \(A\)
    has a computable enumeration then \(A\) is c.e., for \(A=\dom(\Phi)\) where \(\Phi\) is the partial
    computable function given by the following procedure: at stage \(s\) we let \(\Phi(x)=0\)
    if \(x\in A_s\). An *index for a c.e. set* \(A\) is a number \(e\) s.t. \(A=W_e\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each computable function \Phi, \(\ran(\Phi)\) is c.e.
    #+END_proposition

    #+BEGIN_proof
    Suppose \(\Phi=\Phi_e\) and we enumerate \(A=\ran(\Phi)\). Since we have complete information
    about \(\Phi_s\) at stage \(s\), we can compute from \(s\) a strong index for \(A_s=\ran(\Phi_s)\).
    Then \((A_s)_{s\in\N}\) is the required computable enumeration of \(A\)
    #+END_proof

    #+BEGIN_exercise
    label:1.1.17
    #+END_exercise

    #+BEGIN_exercise
    label:1.1.19

    #+END_exercise

    #+BEGIN_proof
    find a subsequence with increasing required steps
    #+END_proof
** Relative computational complexity of sets


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(X\) is *many-one reducible* to \(Y\), denoted \(X\le_mY\), if there is a computable function \(f\)
    s.t. \(n\in X\leftrightarrow f(n)\in Y\) for all \(n\)
    #+END_definition

    If \(X\) is computable, \(Y\neq\emptyset\), and \(Y\neq\N\), then \(X\le_mY\): choose \(y_0\in Y\) and \(y_1\notin Y\).
    Let \(f(n)=y_0\) if \(n\in X\) and \(f(n)=y_1\) otherwise. Then \(X\le_mY\) via \(f\).

    For each set \(Y\) the class \(\{X:X\le_mY\}\) is countable. In particular, there is no greatest
    many-one degree

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.2
    \(A\) is c.e. \(\Leftrightarrow\) \(A\le_m\emptyset'\)

    An index for the many-one reduction as a computable function can be obtained effectively from a
    c.e. index for \(A\), and conversely
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): We claim that there is a computable function \(g\) s.t.
    \begin{equation*}
    W_{g(e,n)}=
    \begin{cases}
    \{e\}&n\in A\\
    \emptyset
    \end{cases}
    \end{equation*}
    For let \(\Theta(e,n,x)\) converge if \(x=e\) and \(n\in A\). Then there is a computable function \(g\)
    s.t. \(\forall e,n,x[\Theta(e,n,x)\simeq\Phi_{g(e,n)}(x)]\). By Theorem ref:1.1.6, there is a computable
    function \(h\) s.t. \(W_{g(h(n),n)}=W_{h(n)}\) for each \(n\). Then
    \begin{align*}
    &n\in A\Rightarrow W_{h(n)}=\{h(n)\}\Rightarrow h(n)\in\emptyset'\\
    &n\notin A\Rightarrow W_{h(n)}=\emptyset\Rightarrow h(n)\notin\emptyset
    \end{align*}
    \(\Leftarrow\): If \(A\le_m\emptyset'\) via \(h\), then \(A=\dom(\Psi)\) where \(\Psi(x)\simeq J(h(x))\) (recall
    that \(J(e)\simeq\Phi_e(e)\))
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A c.e. set \(C\) is called *\(r\)-complete* if \(A\le_rC\) for each c.e. set \(A\)
    #+END_definition

    we say that \(X\le_1Y\) if \(X\le_mY\) via a one-one function \(f\)

    #+BEGIN_exercise
    label:1.2.4
    The set \(\emptyset'\) is \(1\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.5
    \(X\equiv_1 Y\Leftrightarrow\) there is a computable permutation \(p\) of \(\N\) s.t. \(Y=p(X)\)
    #+END_exercise

    Our intuitive understanding of "\(Y\) is at least as complex as \(X\)" is: \(X\) can be computed
    with the help of \(Y\). To formalize more general ways of relative computation, we extend the
    machine model by a one-way infinite "oracle" tape which holds all the answers to oracle
    questions of the form "is \(k\) in \(Y\)".

    We write \(\Phi_e^Y(n)\downarrow\) if the program \(P_e\) halts when the oracle is \(Y\) and the input
    is \(n\); we write \(\Phi_e(Y;n)\) or \(\Phi_e^Y(n)\) for this output. The \(\Phi_e\) are called *Turing
    functionals*. And we let \(W_e^Y=\dom(\Phi_e^Y)\). \(W_e\) is a *c.e. operator*

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A total function \(f:\N\to\N\) is called *Turing reducible* to \(Y\), or *computable relative to* \(Y\),
    or *computable in* \(Y\), if there is an \(e\) s.t. \(f=\Phi_e^Y\). We denote this by \(f\le_TY\). We
    also say that \(Y\) *computes* \(f\). For a set \(A\), we write \(A\le_TY\) if the characteristic
    function of \(A\) is Turing reducible to \(Y\)
    #+END_definition

    For a total functions \(g\), \(f\le_Tg\) means that \(f\) is Turing reducible to the *graph*
    of \(g\), that is, to \(\{\la n,g(n)\ra:n\in\N\}\)

    #+BEGIN_exercise
    label:1.2.7
    \(\le_m\) and \(\le_T\) are preorderings of the subsets of \(\N\)
    #+END_exercise

    A set \(A\) is *c.e. relative to* \(Y\) if \(A=W_e^Y\) for some \(e\). We view \(\Phi_e\)as \(\Phi_e^{\emptyset}\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.8
    \(A\) is computable in \(Y\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(Y\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(J^Y(e)\simeq\Phi_e^Y(e)\). The set \(Y'=\dom(J^Y)\) is the *Turing jump* of \(Y\). The
    map \(Y\to Y'\) is called the *jump operator*
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    For each computable binary function \(g\) there is a computable function \(f\) s.t. \(\Phi_{g(f(n),n)}^Y=\Phi_{f(n)}^Y\)
    #+END_theorem

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.11
    \(A\) is c.e. in \(Y\) iff \(A\le_mY'\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.12
    For each \(Y\), the set \(Y'\) is c.e. relative to \(Y\). Also, \(Y\le_mY'\) and \(Y'\not\le_TY\),
    and therefore \(Y<_TY'\)
    #+END_proposition

    #+BEGIN_proof
    \(Y'\) is c.e. in \(Y\) since \(Y'=\dom(J^Y)\). As \(Y\) is c.e. relative to itself, by
    Proposition ref:1.2.11 \(Y\le_mY'\). If \(Y'\le_TT\) then there is \(e\) s.t. \(\N-Y'=W_e^Y\).
    Then \(e\in Y'\leftrightarrow e\in W_e^Y\leftrightarrow e\notin Y'\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We define \(Y^{(n)}\) inductively by \(Y^{(0)}=Y\) and \(Y^{(n+1)}=(Y^{(n)})'\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For each \(Y,Z\) we have \(Y\le_TZ\Leftrightarrow Y'\le_mZ'\)
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): \(Y'\) is c.e. in \(Y\) and hence c.e. in \(Z\). Therefore \(Y'\le_mZ'\) by Proposition ref:1.2.11

    \(\Leftarrow\):By Proposition ref:1.2.8, \(Y\) and \(\N-Y\) are c.e. in \(Y\). So \(Y,\N-Y\le_mY'\le_mZ'\),
    whence both \(Y\) and \(\N-Y\) are c.e. in \(Z\). Hence \(Y\le_TZ\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    From a Turing functional \(\Phi=\Phi_e\) one can effectively obtain a computable strictly increasing
    function \(p\), called a *reduction function* for \Phi, s.t. \(\forall Y\forall x\Phi^Y(x)\simeq J^Y(p(x))\)
    #+END_fact

    #+BEGIN_proof
    Let \(\Theta^Y(x,y)\simeq\Phi^Y(x)\), by the oracle version of the Parameter Theorem there is a computable
    strictly increasing function \(p\) s.t. \(\forall Y\forall y\Phi_{p(x)}^Y(y)\simeq\Theta^Y(x,y)\simeq\Phi^Y(x)\).
    Letting \(y=p(x)\) we obtain \(J^Y(p(x))=\Phi^Y_{p(x)}(p(x))=\Phi^Y(x)\)
    #+END_proof

    We identify \(\sigma\in\{0,1\}^*\) with \(n\in\N\) s.t. the binary representation of \(n+1\) is 1\sigma. For
    instance, 000 is 7

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We write \(\Phi_{e,s}^Y(x)=y\) if \(e,x,y<s\) and the computation of program \(P_e\) on input \(x\)
    yields \(y\) in at most \(s\) computation steps, with all oracle queries less than \(s\).
    #+END_definition

    The *use principle* is the fact that a terminating oracle computation only asks finitely many
    oracle questions. Hence \((\Phi_{e,s}^Y)_{s\in\N}\) approximates \(\Phi_e^Y\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *use* of \(\Phi_e^Y(x)\), denoted \(\use\Phi_e^Y(x)\), is defined if \(\Phi_e^Y(x)\downarrow\), where its value is
    1+the largest oracle query asked during this computation.
    #+END_definition

    We write
    \begin{equation*}
    \Phi_e^\sigma(x)=y
    \end{equation*}
    if \(\Phi_e^F(x)\) yields the output \(y\), where \(F=\{i<\abs{\sigma}:\sigma(i)=1\}\), and the use is at
    most \(\abs{\sigma}\). Then for each set \(Y\)
    \begin{equation*}
    \Phi_e^Y(x)=y\leftrightarrow\Phi_e^{Y\uhr u}(x)=y
    \end{equation*}
    where \(u=\use\Phi_e^Y(x)\)

    If a Turing functional \(\Phi_e\) is given then \(\lambda Yx.\use\Phi_e^Y\) is also a Turing functional
    (namely there is \(i\) s.t. \(\Phi_i^Y(x)\simeq\use\Phi_e^Y(x)\) for each \(Y\) and \(x\)). Thus if \(Y\)
    is an oracle s.t. \(f=\Phi_e^Y\) is total, the function \(\use\Phi_e^Y\) is computable in \(Y\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *weak truth-table* reducible to \(Y\), denoted \(f\le_{wtt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    and \(\forall n\use\Phi_e^Y(n)\le r(n)\).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A function \(f:\N\to\N\) is *truth-table* reducible to \(Y\), denoted \(f\le_{tt}Y\), if there is
    a Turing functional \(\Phi_e\) and a computable bound \(r\) s.t. \(f=\Phi_e^Y\)
    \(f=\Phi_e^Y\) and \(\Phi_e^Z\) is total for each oracle \(Z\) (we call such a \(\Phi_e\) a truth table reduction).
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. \(X\le_{tt}Y\Leftrightarrow\) there is a computable function \(g\) s.t. for each \(n\),
       \begin{equation*}
       n\in X\Leftrightarrow\bigvee_{\sigma\in D_{g(n)}}[\sigma\preceq Y]
       \end{equation*}
    2. \(X\le_{tt}Y\) implies \(X\le_{wtt}Y\)
    #+END_proposition

    #+BEGIN_proof
    1. \(\Rightarrow\): Suppose \(X\le_{tt}Y\) via a truth-table reduction \(\Phi=\Phi_e\). The
       tree \(T_n=\{\sigma:\Phi^\sigma_{\abs{\sigma}}(n)\uparrow\}\) is finite for each \(n\), for otherwise it has an infinite
       path \(Z\) by Kőnig's Lemma and \(\Phi^Z(n)\uparrow\). Given \(n\) one can compute a strong
       index \(\tilg(n)\) for the finite set of minimal string \sigma s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow\). Hence
       one can compute a strong index \(g(n)\) for the set of all minimal strings \sigma
       s.t. \(\Phi_{\abs{\sigma}}^\sigma(n)\downarrow=1\). Then \(D_{g(n)}\) is as required

       \(\Leftarrow\):Consider the following procedure relative to an oracle \(Z\): on input \(n\), first
       compute \(D_{g(n)}\). If \(\sigma\preceq Z\) for some \(\sigma\in D_{g(n)}\), output 1, otherwise output 0

    2. For each \(Z\) \(\use\Phi_e^Z(n)\) is bounded by \(\max\{\abs{\sigma}:\sigma\in D_{g(n)}\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:1.2.22
    \(f\le_{tt}A\Leftrightarrow\) there is a Turing functional \Phi and a computable function \(t\) s.t. \(f=\Phi^A\) and
    the number of steps needed to compute \(\Phi^A(n)\) is bounded by \(t(n)\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): Let \(\tilPhi\) be the Turing functional s.t. \(\tilPhi^Z(n)=\Phi^Z_{t(n)}(n)\) if the
    latter is defined and \(\tilPhi^Z(n)=0\) otherwise
    #+END_proof

    \begin{equation*}
    \le_m\Rightarrow\le_{tt}\Rightarrow\le_{wtt}\Rightarrow\le_T
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *effective disjoint union* of sets \(A\) and \(B\) is
    \begin{equation*}
    A\oplus B=\{2n:n\in A\}\cup\{2n+1:n\in B\}
    \end{equation*}
    #+END_definition

    #+BEGIN_exercise
    label:1.2.23
    1. \(A,B\le_mA\oplus B\)
    2. Let \(\le_r\) be one of the reducibilities above. Then for any set \(X\)
       \begin{equation*}
       A,B\le_rX\Leftrightarrow A\oplus B\le_rX
       \end{equation*}
    #+END_exercise

    #+BEGIN_exercise
    label:1.2.24
    Let \(C=A_0\cup A_1\) where \(A_0,A_1\) are c.e. and \(A_0\cap A_1=\emptyset\). Then \(C\equiv_{wtt}A_0\oplus A_1\)
    #+END_exercise

    #+BEGIN_proof
    Since \(A_0,A_1\) are c.e., for each \(n\in C\), we can determine if \(n\in A_0\cup A_1\) in finite steps.
    #+END_proof

    #+BEGIN_exercise
    label:1.2.25
    Show that \(\exists Zf\le_{tt}Z\Leftrightarrow\) there is a computable \(h\) s.t. \(\forall nf(n)\le h(n)\)
    #+END_exercise

    #+BEGIN_proof
    Trivial
    #+END_proof
** Descriptive complexity of sets
    In a computable enumeration \((Z_s)_{s\in\N}\) of a set \(Z\), for each \(x\), \(Z_s(x)\) can
    change at most once, namely from 0 to 1. Which sets \(Z\) are described if we allow an arbitrary
    finite number of changes


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    We say that a set \(Z\) is \(\Delta_2^0\) if there is a computable sequence of strong
    indices \((Z_s)_{s\in\N}\) s.t. \(Z_s\subseteq[0,s)\) and \(Z(x)=\lim_sZ_s(x)\). We say
    that \((Z_s)_{s\in\N}\) is a *computable approximation* of \(Z\)
    #+END_definition

    Given an expression \(E\) that is approximated during stages \(s\),
    \begin{equation*}
    E[s]
    \end{equation*}
    denotes its value at the *end of* stage \(s\). For instance, given a \(\Delta_2^0\) set \(Z\) with a
    computable approximation, instead of \(\Phi_{e,s}^{Z_s}(x)\) we simply write \(\Phi_e^Z(x)[s]\). We say
    that the expression \(E\) is *stable at* \(s\) if \(E[t]=E[s]\)for all \(t\ge s\)

    #+ATTR_LATEX: :options [Shoenfield Limit Lemma]
    #+BEGIN_lemma
    label:1.4.2
    \(Z\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(Z\le_T\emptyset'\). The equivalence is uniform
    #+END_lemma

    #+BEGIN_proof
    \(\Leftarrow\): Fix a Turing functional \(\Phi_e\) s.t. \(Z=\Phi_e^{\emptyset'}\). Since \(\emptyset'\) is c.e.,
    let \(\la \emptyset'_s\ra_{s\in\N}\) be a computable enumeration of \(\emptyset'\). Define
    \begin{equation*}
    Z_s(x)=
    \begin{cases}
    1&\Phi_{e,s}^{\emptyset'_s\downarrow}=1\\
    0&\text{otherwise}
    \end{cases}
    \end{equation*}
    Let \(u=\use\Phi_e^{\emptyset'}(x)\), there is \(s\) s.t. \(\emptyset'_s\uhr u=\emptyset'\uhr u\), thus there is \(s\ge t\)
    s.t. \(Z_s(x)=Z(x)\)

    Then the required approximation is
    given by \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\)

    \(\Rightarrow\): We define a c.e. set \(C\) s.t. \(Z\le_TC\). This is sufficient because \(C\le_m\emptyset'\) by
    Proposition ref:1.2.2. The set \(C\) is called the *change set* because it records the changes of
    the computable approximation. If \(Z_s(x)\neq Z_{s+1}(x)\) we put \(\la x,i\ra\) into \(C_{s+1}\),
    where \(i\) is the least s.t. \(\la x,i\ra\notin C_s\). To show that \(Z\le_TC\), on input \(x\), using the
    oracle \(C\) compute the least \(i\) s.t. \(\la x,i\ra\notin C\). If \(i\) is even then \(Z(y)=Z_0(y)\),
    otherwise \(Z(y)=1-Z_0(y)\)

    We have obtained \(C\) and the Turing reduction of \(Z\) to \(C\) effectively from the
    computable approximation of \(Z\). Proposition ref:1.2.2 is also effective
    #+END_proof

    If \(Z=\Phi_e^{\emptyset'}\) we say that \(e\) is a *\(\Delta_2^0\)-index* for \(Z\). A number \(e\) is
    a \(\Delta_2^0\) index only if \(\Phi_e^{\emptyset'}\) is total

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. We say that a set \(Z\) is *\omega-c.e.* if there is a computable
       approximation \((Z_s)_{s\in\N}\) of \(Z\) and a computable function \(b\) s.t.
       \begin{equation*}
       b(x)\ge\#\{s>x:Z_x(x)\neq Z_{s-1}(x)\}\text{ for each }x
       \end{equation*}
    2. If \(Z_s(s-1)=0\) for each \(s>0\) and \(b(x)\) can be chosen constant of value \(n\), then
       we say \(Z\) is \(n\)-c.e.
    #+END_definition

    Thus \(Z\) is 1-c.e. iff \(Z\) is c.e., and \(Z\)  is 2-c.e. iff \(Z=A-B\) for c.e. sets \(A,B\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\omega\)-c.e. \(\Leftrightarrow\) \(Z\le_{wtt}\emptyset'\) \(\Leftrightarrow\) \(Z\le_{tt}\emptyset'\)

    The equivalence are effective
    #+END_proposition

    #+BEGIN_proof
    First suppose that \(Z_{wtt}\emptyset'\) via a functional \(\Phi_e\) with computable use bound \(f\). To
    show that \(Z\) is \omega-c.e., let \(Z_s=\{x<s:\Phi_e^{\emptyset'}(x)[s]=1\}\). Since \(\Phi_e^{\emptyset'}(x)[s]\) only
    becomes undefined when a number less than \(f(x)\) enters \(\emptyset'\), the number of changes
    of \(Z_s(x)\) is bounded by \(2f(x)\)

    Now suppose that \(Z\) is \omega-c.e. via the computable approximation \((Z_s)_{s\in\N}\) and the
    function \(b\) bounding the number of changes. We show that \(Z\le_{tt}\emptyset'\). Let \(C\) be the
    change set. Since \(b(x)\ge\min\{i:\la x,i\ra\notin C\}\), the reduction of \(Z\) to \(C\) given there can be
    carried out by computing a truth-table from the input \(x\) and evaluating it on the answers to
    oracle questions to \(C\)
    #+END_proof

    #+ATTR_LATEX: :width .9\textwidth
    #+NAME:
    #+CAPTION:
    [[../images/ComputabilityAndRandomness/1.jpg]]


    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    label:1.4.14
    \(A\) is \(\Delta_2^0\) \(\Leftrightarrow\) \(A\) is both \(\Sigma_2^0\) and \(\Pi_2^0\)
    #+END_corollary

    #+BEGIN_proof
    \begin{align*}
    A\in\Delta_2^0&\Leftrightarrow A\le_T\emptyset'\\
    &\Leftrightarrow A\text{ and }\N-A\text{ are c.e. in }\emptyset'\\
    &\Leftrightarrow A\in\Sigma_2^0\cap\Pi_2^0
    \end{align*}
    last iff from Theorem ref:1.4.13
    #+END_proof


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(A\subseteq\N\) and \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\)if \(x\in A\leftrightarrow\exists y_1\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\), where \(R\) is a symbol for a
       computable relation
    2. \(A\) is \(\Pi_n^0\) if \(\N-A\) is \(\Sigma_n^0\)
    3. \(A\) is *arithmetical* if \(A\) is \(\Sigma_n^0\) for some \(n\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_fact
    label:1.4.12
    \(A\) is \(\Sigma_1^0\Leftrightarrow A\) is c.e.. The equivalence is uniform
    #+END_fact

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(x\in A\leftrightarrow\exists y R(x,y)\) for computable \(R\). Let \Phi be the partial computable
    function given by the Turing program that on input \(x\) looks for a witness \(y\)
    s.t. \(R(x,y)\), and halts when such a witness is found. Then \(A=\dom(\Phi)\)

    \(\Leftarrow\): Suppose \(A=\dom(\Phi)\) for a partial computable function \Phi. Let \(R\) be the computable
    relation given by \(R(x,s)\leftrightarrow\Phi(x)[s]\downarrow\). Then \(x\in A\leftrightarrow\exists sR(x,s)\), so \(A\) is \(\Sigma_1^0\)
    #+END_proof

    A \(\Sigma_n^0\) set \(C\) is *\(\Sigma_n^0\)-complete* if \(A\le_mC\) for each \(\Sigma_n^0\) set \(A\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:1.4.13
    Let \(n\ge 1\)
    1. \(A\) is \(\Sigma_n^0\) \(\Leftrightarrow\) \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)
    2. \(\emptyset^{(n)}\) is \(\Sigma_n^0\)-complete
    #+END_theorem

    #+BEGIN_proof
    Induction on \(n\).  ref:1.4.12 and ref:1.2.2. Now let \(n>1\)
    1. First suppose \(A\) is \(\Sigma_n^0\) for some computable relation \(R\). Then the set
       \begin{equation*}
       B=\{\la x,y_1\ra:\forall y_2\dots Qy_nR(x,y_1,\dots,y_n)\}
       \end{equation*}
       is \(\Pi_{n-1}^0\) and \(A\) is c.e. relative to \(B\). By (2) for \(n-1\) we
       have \(B\le_m\N-\emptyset^{(n-1)}\). So \(A\) is c.e. relative to \(\emptyset^{(n-1)}\)

       Now suppose \(A\) is c.e. relative to \(\emptyset^{(n-1)}\). Then there is a Turing functional \Phi
       s.t. \(A=\dom(\Phi^{\emptyset^{(n-1)}})\). By the use principle
       \begin{equation*}
       x\in A\Leftrightarrow\exists\eta,s\ucorner{\Phi_s^\eta(x)\downarrow\wedge\forall i<\abs{\eta}\;\eta(i)=1\leftrightarrow i\in\emptyset^{(n-1)}}
       \end{equation*}
       The innermost part can be put into \(\Sigma_n^0\)-form, so \(A\) is \(\Sigma_n^0\).
    2. Follows by Proposition ref:1.2.11 where \(Y=\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    Let \(n\ge 1\). Then \(A\) is \(\Delta_n^0\Leftrightarrow A\le_T\emptyset^{(n-1)}\)
    #+END_proposition

    #+BEGIN_proof
    By Theorem ref:1.4.13, \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(A\) and \(\N-A\) are c.e. in \(\emptyset^{(n-1)}\). By
    Proposition ref:1.2.8, this condition is equivalent to \(A\le_T\emptyset^{(n-1)}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(Z\) is \(\Sigma_2^0\) \(\Leftrightarrow\) there is a computable sequence of strong indices \((Z_s)_{s\in\N}\)
    s.t. \(Z_s\subseteq[0,s)\) and \(x\in Z\leftrightarrow\exists s\forall t\ge s\;Z_t(x)=1\). The equivalence is uniform
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): By Theorem ref:1.4.13, there is a Turing functional \Phi s.t. \(Z=\dom(\Phi^{\emptyset'})\). Now
    let \(Z_s=\{x<s:\Phi^{\emptyset'}(x)[s]\downarrow\}\)

    \(\Leftarrow\):
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The *index set* of a class \(S\) of c.e. sets is the set \(\{i:W_i\in S\}\)
    #+END_definition


    #+BEGIN_exercise
    label:1.4.19
    \(\emptyset'\) is not an index set
    #+END_exercise

    #+BEGIN_proof
    We can find \(g\) s.t. \(W_{g(n)}=\{n\}\). Thus there is \(e\) s.t. \(W_{g(e)}=W_e=\{e\}\). By
    padding lemma, we have \(W_i=W_e\) but \(i\notin\emptyset'\)
    #+END_proof



    #+BEGIN_exercise
    label:1.4.20
    1. \(\{e:W_e\neq\emptyset\}\) is \(\Sigma_1^0\)-complete
    2. The set \(\{e:W_e\text{ finite }\}\) is \(\Sigma_2^0\)-complete.
    3. The set \(\Tot=\{e:\dom(\Phi_e)=\N\}=\{e:W_e=\N\}\) is \(\Pi_2^0\)-complete
    4. Both \(\{e:W_e\text{ cofinite}\}\) and \(\Cop=\{e:W_e\text{ computable}\}\) are \(\Sigma_3^0\)-complete
    #+END_exercise

    #+BEGIN_proof
    1. Given \(e\), \(\Phi_{f(n)}\) doesn't converge in \(\N-\{e\}\). And converges on \(e\)
       if \(\Phi_e(e)\downarrow\). Thus \(\emptyset'\le_m\{e:W_e\neq\emptyset\}\)
    2. Let \(\Fin=\{e:W_e\text{ finite}\}\). Then \(e\in\Fin\Leftrightarrow\exists s\forall t\ge s(W_{e,s}=W_{e,t})\)
    3. \(e\in\Tot\Leftrightarrow\forall n\exists s\Phi_{e,s}(n)\downarrow\)

       For any \(A\) in \(\Pi_2^0\), \(x\in A\Leftrightarrow\forall y\exists zR(x,y,z)\)

       We could define
       \begin{equation*}
       \Phi_{q(x)}(u)=
       \begin{cases}
       0&\forall y\le u\exists zR(x,y,z)\\
       \uparrow
       \end{cases}
       \end{equation*}
       Then \(x\in A\Leftrightarrow W_{q(x)}=\omega\Leftrightarrow q(x)\in\Tot\)

       \(x\in\barA\Leftrightarrow W_{q(x)}\) is finite
    4. \(e\in\Cof\Leftrightarrow\exists z\forall n\ge z\exists s\Phi_{e,s}(n)\downarrow\), thus \(\Cof\in\Sigma_3^0\)

       check fudan's textbook p120
    #+END_proof

    #+BEGIN_exercise
    label:1.4.21
    The set \(\{e:\dom\Phi_e^{\emptyset'}=\N\}\) is \(\Pi_0^3\)-complete
    #+END_exercise

    #+BEGIN_exercise
    label:1.4.22
    Let \(\cals\) be a class of c.e. sets [\omega-c.e. sets] containing all the finite sets. Suppose the
    index set of \(S\) is \(\Sigma_3^0\).  Then \(\cals\) is uniformly c.e. [uniformly c.e.]
    #+END_exercise

    #+BEGIN_proof
    Let \(I=\{e\mid\exists x\forall y\exists z\;R(e,x,y,.z)\}\), \(\cals=\{W_e\}_{e\in I}\)

    \(\cals\) is \(\Sigma_3^0\), \(\cals\le_m\Cof\)
    #+END_proof

    #+BEGIN_exercise
    label:1.4.24
    Let \(X\subseteq\N\)
    1. Each relation \(R\le_TX\) is first-order definable in the structure \((\N,+,\cdot ,X)\)
    2. The index set \(\{e:W_e\le_TX\}\) is \(\Sigma_3^0(X)\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.4.25
    \(A\) is \(\Delta_n^0\) \(\Leftrightarrow\) \(\forall x A(x)=\lim_{k_1}\dots\lim_{k_{n-1}}g(x,k_1,\dots,k_{n-1})\) for some
    computable \(\{0,1\}\)-valued function \(g\)
    #+END_exercise
** Absolute computational complexity of sets
*** Sets that are \texorpdfstring{\(low_n\)}{lown}
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(f,g:\N\to\R\). \(f\) *dominates* \(g\) if \(f(n)\ge g(n)\) for almost every \(n\)
    #+END_definition

    1. \(A\) is *low* if \(A'\le_T\emptyset'\)
    2. \(A\) is *computably dominated* if each function \(g\le_TA\) is dominated by a computable
       function
    3. \(A\) is *high* if \(\emptyset''\le_TA'\)


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(n\ge 0\). We say that \(C\) is \(low_n\) if \(C^{(n)}\equiv_T\emptyset^{(n)}\)
    #+END_definition

    If \(C\in low_1\) we simply say that \(C\) is *low*. Each low set is \(\Delta_2^0\).

    Each class \(low_n\) is closed downward under Turing reducibility, and contained in \(\Delta_{n+1}^0\)
    \begin{equation*}
    \text{computable}\subset low_1\subset low_2\subset\dots\subset\{Z:Z\not\ge_T\emptyset'\}
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(C\) is *superlow* if \(C'\equiv_{tt}\emptyset'\)
    #+END_definition

    It suffices to require that \(C'\le_{tt}\emptyset'\), because \(\emptyset'\le_mC'\) for any \(C\) by ref:1.2.14. By
    ref:1.4.4 it is equivalent to ask that \(C'\) be \omega-c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is *generalized \(low_1\)*, or in \(\GL_1\) for short, if \(A'\equiv_TA\oplus\emptyset'\)
    #+END_definition

    #+BEGIN_exercise
    label:1.5.5
    If \(C\) is superlow, there is a computable function \(h\) s.t. \(Y\le_TC\) implies \(Y\le_{tt}\emptyset'\)
    with use function bounded by \(h\) for each \(Y\)
    #+END_exercise

    #+BEGIN_proof

    #+END_proof

    #+BEGIN_exercise
    label:1.5.7
    If \(B\) is \(low_2\) then the index set \(\{e:W_e\le_TB\}\) is \(\Sigma_3^0\)
    #+END_exercise

    #+BEGIN_exercise
    label:1.5.8
    \(B\) is \(low_2\)\(\Leftrightarrow\) \(\Tot^B=\{e:\Phi_e^B\text{ total}\}\) is \(\Sigma_3^0\)
    #+END_exercise
*** Computably dominated sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(A\) is called *computably dominated* if each function \(g\le_TA\) is dominated by a computable
    function
    #+END_definition

    \(E\subseteq\N\)  is *hyperimmune* if \(E\) is infinite and \(p_E\) is not dominated by a computable
    function, where \(p_E\) is the listing of \(E\) in order of magnitude

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is not computably dominated \(\Leftrightarrow\) there is a hyperimmune set \(E\equiv_TA\)
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): immediate since \(p_E\le_TE\)

    \(\Rightarrow\): Suppose \(g\le_TA\) is not dominated by a computable function. Let \(E=\ran(h)\), where the
    function \(h\) is defined as follows: \(h(0)=0\), and for each \(n\in\N\), \(h(2n+1)=h(2n)+g(n)+1\)
    and \(h(2n+2)=h(2n+1)+p_A(n)+1\).
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(A\) is computably dominated \(\Leftrightarrow\) for each function \(f\)
    \begin{equation*}
    f\le_TA\to f\le_{tt}A
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(\Rightarrow\): Suppose \(f=\Phi^A\). Let \(g(x)=\mu s\Phi_s^A(x)\downarrow\). Then \(g\le_TA\), so there is a computable
    function \(t\) s.t. \(t(x)\ge g(x)\) for each \(x\). Thus \(t\) bounds the running time of \(\Phi^A\),
    whence \(f\le_{tt}A\) by Proposition ref:1.2.22
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    If \(A\) is \(\Delta_2^0\) and incomputable, then \(A\) is not computably dominated
    #+END_proposition

    #+BEGIN_proof
    Let \((A_s)_{s\in\N}\) be a computable approximation of \(A\). Then the following function \(g\) is
    total
    \begin{equation*}
    g(s)\simeq\mu t\ge s.A_t\uhr s=A\uhr s
    \end{equation*}
    Note that \(g\le_TA\). Assume that there is a computable function \(f\) s.t. \(g(s)\le f(s)\) for
    each \(s\). Then \(A\) is computable: for each \(n\) and each \(s>n\) we have \(A_t(n)=A(n)\)
    for some \(t\in[s,f(s))\), namely \(t=g(s)\). On the other hand, if \(s\) is sufficiently large
    then \(A_u(n)=A_s(n)\) for all \(u\ge s\). Thus to compute \(A\), on input \(n\) determine the
    least \(s>n\) s.t. \(A_u(n)=A_s(n)\) for all \(u\in[s,f(s))\). Then \(A_s(n)=A(n)\), so the
    output \(A_s(n)\) is correct
    #+END_proof
*** Sets that are \texorpdfstring{\(high_n\)}{highn}
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(n\ge 0\). A set \(C\) is \(high_n\) if \(\emptyset^{(n+1)}\le_TC^{(n)}\)
    #+END_definition

    All the classes \(high_n\) are closed upward under Turing reducibility, so the complementary
    classes \(\non-high_n=2^{\N}-high_n\) are closed downward. Therefore
    \begin{equation*}
    comp.\subset low_1\subset low_2\subset\dots\subset\non-high_2\subset\non-high_1\subset\{Z:Z\not\ge_T\emptyset'\}
    \end{equation*}

    It is easy to define a function \(f\le_T\emptyset'\) that dominates all computable functions: the
    set \(\{\la e,x\ra:\Phi_e(x)\downarrow\}\) is c.e., and hence many-one reducible to \(\emptyset'\) via a computable
    function \(h\). Let \(f(x)=\max\{\Phi_e(x):e\le x\wedge h(\la e,x\ra)\in\emptyset')\}\). If \(\Phi_e\) is total
    then \(f(x)\ge\Phi_e(x)\) for all \(x\ge e\). This property of \(\emptyset'\) in fact characterizes the high
    sets.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    \(C\) is high \(\Leftrightarrow\) some function \(f\le_TC\) dominates all computable functions
    #+END_theorem

    #+BEGIN_proof
    \(\Rightarrow\): We define a function \(f\le_TC\) that dominates each total \(\Phi_e\), extending the argument
    for the case \(C=\emptyset'\). Note that \(\Tot=\{e:\Phi_e\text{ total}\}\) is \(\Pi_2^0\), and
    hence \(\ove{\Tot}\le_m\emptyset''\le_TC'\). By the Limit Lemma ref:1.4.2, \(\Tot\) is \(\Delta_2^0(C)\), there is
    a \(A\)-computable approximation \((T_s)_{s\in\N}\) of \(\Tot\). Define \(f\le_TA\) as:
    \(\forall x\in\N\), let
    \begin{align*}
    &S_x=\mu s(\forall e\le x(\Phi_{e,s}(x)\downarrow\text{ or }T_s(e)=0))\\
    &f(x)=\max\{\Phi_{e,S_x}(x)\mid e\le x,\Phi_{e,S_x}(x)\downarrow\}
    \end{align*}
    *Claim*: \(\forall x\), \(S_x\) exists

    For any \(e\le x\), if \(\Phi_e\) is total, then \(S_x\) always exists. Otherwise, \(T_s(e)\) converges
    to 0

    *Claim*: \(f\) dominates all computable total functions

    \(\forall x\ge e\), \(\exists s\le S_x\), \(\Phi_{e,s}\downarrow\le f(x)\)

    \(\Leftarrow\): Suppose \(f\le_TC\) dominates all computable functions. We show
    that \(\N-\emptyset''=\{e:\Phi_e^{\emptyset'}(e)\uparrow\}\) is Turing reducible to \(C'\). Note that \(\Phi_e^{\emptyset'}(e)\uparrow\) iff the
    computation is undefined at infinitely many stages, that is, no computation \(\Phi_e^{\emptyset'}(e)[s]\) is
    stable. Thus \(\Phi_e^{\emptyset'}(e)\uparrow\) iff the partial computable function
    \begin{equation*}
    g(s)\simeq\mu t>s[\Phi_e^{\emptyset'}(e)[t]\uparrow]
    \end{equation*}
    is total. In that case \(g\) is dominated by \(f\), and therefore
    \begin{equation*}
    e\notin\emptyset''\Leftrightarrow\exists n_0\forall n\ge n_0\exists t[n\le t\le f(n)\wedge\Phi_e^{\emptyset'}(e)[t]\uparrow]
    \end{equation*}
    Since \(t\) is bounded by \(f(n)\) and \(f\le_T(C)\), this shows that \(\N-\emptyset''\) is \(\Sigma_2^0(C)\).
    Also \(\emptyset''\in\Sigma_2^0\subseteq\Sigma_2^0(C)\). Therefore \(\emptyset''\le_TC'\) by Proposition ref:1.4.14 relative to \(C\)
    #+END_proof
** Post's problem
*** Turing incomparable \texorpdfstring{\(\Delta_2^0\)}{Δ02}-sets
    For sets \(Y,Z\), we write \(Y\mid_TZ\) if \(Y\not\le_TZ\) and \(Z\not\le_TY\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There are sets \(Y,Z\le_T\emptyset'\) s.t. \(Y\mid_TZ\)
    #+END_theorem

    #+BEGIN_proof
    Noe that \(Y\mid_TZ\) is equivalent to the conjunction of the statements \(R_i\) for all \(i\) where
    \begin{align*}
    R_{2e}&:\exists n\neg Y(n)=\Phi_e^Z(n)\\
    R_{2e+1}&:\exists n\neg Z(n)=\Phi_e^Y(n)
    \end{align*}
    Thus we may divide the overall task that \(Y\mid_TZ\) into subtasks, called *requirements*. To *meet* a
    requirement means to make its statement true.

    The construction of \(Y\) and \(Z\) is relative to \(\emptyset'\). We meet the requirements one by one
    in the given order. We define sequences \(\sigma_0\prec\sigma_1\prec\dots\) and \(\tau_0\prec\tau_1\prec\dots\) and let \(Y=\bigcup_i\sigma_i\)
    and \(Z=\bigcup_i\tau_i\). As stage \(i+1\) we meet \(R_i\) by defining \(\sigma_{i+1}\) and \(\tau_{i+1}\)
    appropriately. Since we have \(\emptyset'\) at our disposal as an oracle, we may ask whether \(\Phi_e^Z(n)\)
    can be made defined for a particular number \(n\). Then we may define \(Y(n)\) in such a way
    that it differs from \(\Phi_e^Z(n)\). This method of providing a counterexample to an equality of
    sets is called *diagonalization*

    *Construction*. Let \(\sigma_0=\tau_0=\emptyset\)

    _Stage \(i+1\), \(i=2e\)_. Let \(n=\abs{\sigma_i}\). Using \(\emptyset'\) as an oracle, check whether there
    is \(\tau\succ\tau_i\) s.t. \(y=\Phi_e^\tau(n)\downarrow\). (Note that this is a \(\Sigma_0^1\) question, so it can be answered
    by \(\emptyset\).) It so, let \(\tau_{i+1}=\tau\) and \(\sigma_{i+1}=\sigma_ix\) where \(x=\max(1-y,0)\). Otherwise
    let \(\sigma_{i+1}=\sigma_i0\) and \(\tau_{i+1}=\tau_i0\)

    _Stage \(i+1\), \(i=2e+1\)_. Similar

    *Verification*. Clearly \(Y,Z\le_T\emptyset'\). Each requirement \(R_{2e}\) is met: if we cannot find an
     extension \(\tau\succ\tau_i\) s.t. \(\Phi^\tau_e(n)\downarrow\), then by use principle \(\Phi_e^Z(n)\uparrow\). Otherwise we ensure
     that \(Y(n)\neq\Phi_e^Z(n)\). Either way \(R_{2e}\) is met
    #+END_proof
*** Simple sets
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A c.e. set \(A\) is *simple* if \(\N-A\) is infinite and \(A\cap W\neq\emptyset\) for each infinite c.e. set \(W\)
    #+END_definition

    In particular, \(\N-A\) is not c.e., so \(A\) is not computable.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There is a simple set
    #+END_theorem

    #+BEGIN_proof
    Let \(A=\ran(\psi)\) where
    \begin{equation*}
    \psi(i)\simeq\text{ the first element }\ge 2i\text{ enumerated into }W_i
    \end{equation*}
    Since \psi is partial computable, \(A\) is c.e. If \(x<2i\) is in \(A\) then \(x=\psi(k)\) for
    some \(k<i\). Hence \(\#A\cap[0,2i)\le i\), so \(A\) is co-infinite. By definition \(A\) is simple
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There is a low simple set \(A\)
    #+END_theorem

    #+BEGIN_proof
    Let
    \begin{align*}
    S_e&:\#W_e=\infty\Rightarrow W_e\cap A\neq\emptyset\\
    L_e&:\exists^\infty sJ^A(e)[s-1]\downarrow\Rightarrow J^A(e)\downarrow
    \end{align*}
    that restrict \(A\). If \(L_e\) is met then \(A'(e)=\lim_sf(e,s)\) where
    \begin{equation*}
    f(e,s)=
    \begin{cases}
    1&J^A(e)[s]\downarrow\\
    0
    \end{cases}
    \end{equation*}
    So \(A'\le_T\emptyset'\) by the Limit Lemma ref:1.4.2. That is \(A\) is low.

    The strategy for \(L_e\) is as follows. When \(J^A(e)[s-1]\) newly converges then \(L_e\)
    *restrains* \(A\) up to \(s\); in other words, \(L_e\) attempts to prevent numbers \(<s\) from
    entering \(A\)

    The conflict between the \(A\)-positive requirements \(S_i\) and the \(A\)-restricting
    requirements \(L_e\) is resolved by imposing an effective *priority ordering*, for instance
    \begin{equation*}
    S_0>L_0>S_1>L_1>\dots
    \end{equation*}

    If a requirement is initialized at stage \(s\), it can afterwards only put numbers \(\ge s\)
    into \(A\). Since oracle questions occurring in the computation \(J^A(e)[s-1]\) are less
    than \(s\), an enumeration of such numbers cannot injure \(L_e\)

    *Construction*. Let \(A_0=\emptyset\)

    /Stage \(s>0\)/
    1. For each \(e<s\), if \(J^A(e)[s-1]\downarrow\) but \(J^A(e)[s-2]\uparrow\) in case \(s>1\), then initialize the
       requirements \(S_i\) for \(i>e\). We say that \(L_e\) *acts*
    2. For each \(e<s\), if \(A_{s-1}\cap W_{e,s-1}=\emptyset\) and there is \(x\in W_{e,s}\) s.t. \(x\ge 2e\)
       and \(x\) is no less than the last stage when \(S_e\) was initialized, then enumerate the
       least such \(x\) into \(A\). We say that \(S_e\) *acts*

    #+END_proof
** Cantor Space
*** Cantor space
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    For any finite 01 string \(\sigma\in 2^{<\omega}\), *cylinder set* is
    \begin{equation*}
    [\sigma]=\{Z\in 2^\omega\mid\sigma\prec Z\}
    \end{equation*}

    And for \(E\subset 2^{<\omega}\), define
    \begin{equation*}
    [E]^\prec=\bigcup\{[\sigma]\mid\sigma\in E\}=\{Z\in 2^\omega\mid\exists \sigma\in E(\sigma\prec Z)\}
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    *Cantor space* is the space with base set the cylinder sets. \(U\subset 2^\omega\) is open (or \(\Sigma_0^1\)) iff there
     is \(E\subset 2^{<\omega}\) s.t. \(U=[E]^{\prec}\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(E\subset 2^{<\omega}\) is *prefix-free* iff \(\forall \sigma,\tau\in E(\sigma\neq\tau\to\sigma\mid\tau)\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(U\subset 2^\omega\) is open iff there is prefix-free \(E\subset 2^{<\omega}\) s.t. \(U=[E]^{\prec}\)
    #+END_proposition

    #+BEGIN_proof
    Given \(E'\) with \(U=[E']^{\prec}\), let \(E'=\{\sigma_i:i<N\}\), \(N\in\omega\) or \(N​=\omega\). Let \(E_0​=\emptyset\)

    If \([\sigma_i]\subset[E_i]^\prec\), let \(E_{i+1}=E_i\)

    If not, and \(\{\sigma_i\}\cup E_i\) is prefix-free, then \(E_{i+1}=E_i\)

    If not, then there is \(\{\tau_1,\dots,\tau_m\}\subset E_i\), \(\sigma\prec\tau_j\), \(1\le j\le m\), then let \(E_{i+1}=\{\sigma\}\cup E_i\setminus\{\tau_1,\dots,\tau_m\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. Cantor space is a closed in \(\R\)
    2. Cantor space is the infinite product of discrete space \(\{0,1\}\), that is, \(\{0,1\}^\omega\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. Every cylinder set is clopen
    2. Cantor space and every cylinder subspace is compact (closed subspace of a compact subspace is
       compact)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. For subtree \(B\) of \(2^{<\omega}\), \(Paths(B)=\{Z\in 2^\omega\mid Z\text{ is a path in }B\}\) is closed
    2. If \(P\subset 2^\omega\) is closed, \(T_P=\{\sigma\mid[\sigma]\cap P\neq\emptyset\}\) is a tree without dead branch and \(Paths(T_P)=P\)
    3. If \(B\) is a tree without dead branch, then \(B=T_{Paths(B)}\)
    #+END_proposition

    #+BEGIN_proof
    2. [@2] \(T_P\) is a tree. \(\sigma\in T_P\Leftrightarrow[\sigma]\cap P\neq\emptyset\), let \(z\in[\sigma]\cap P\),
       then \(\forall n\), \([z\uhr n]\cap P\neq\emptyset\), therefore \([z\uhr n]\in T_P\).

       \(z\in Paths(T_P)\Leftrightarrow\forall n[z\uhr n]\in T_P\Leftrightarrow\forall n[z\uhr n]\cap P\neq\emptyset\Leftrightarrow z\in P\) since \(P\) is closed

    3. \(\sigma\in B\Rightarrow[\sigma]\cap Paths(B)\neq\emptyset\)
    #+END_proof

    For open set \(U\subset 2^\omega\), let \(P=2^\omega\setminus U\), define
    \begin{equation*}
    A_U=2^{<\omega}\setminus T_P=\{\sigma\mid[\sigma]\subset U\}
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. If \(U\) is open, then \(A_U\) is an ideal: if \(\sigma\in A_U\) and \(\sigma\prec\tau\), then \(\tau\in A_U\);
       if \(\sigma0,\sigma1\in A_U\), then \(\sigma\in A_U\)
    2. If \(I\) is an ideal, then \(I=A_{[I]^{\prec}}\)
    #+END_proposition

    #+BEGIN_proof
    2. [@2] \(\sigma\in I\), \([\sigma]\subset[I]^\prec\), \(\sigma\in A_{[I]^\prec}\).

       \(\sigma\in A_{[I]^\prec}\), \([\sigma]\subset[I]^\prec\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(X\subset 2^\omega\) is clopen iff there is finite \(F\subset 2^{<\omega}\), \(X=[F]^\prec\)
    #+END_proposition

    #+BEGIN_proof
    \(X\) is compact
    #+END_proof

    There is a *measure* in cantor space:
    * \(\forall\sigma\in 2^{<\omega}\), \(\lambda([\sigma])=2^{-\abs{\sigma}}\)
    * for \(U=[E]^\prec\), where \(E\) is prefix-free, \(\lambda(U)=\sum_{\sigma\in E}\lambda([\sigma])\)
    * \(\lambda(2^\omega\setminus U)=1-\lambda(U)\)


    \(M:2^{<\omega}\to 2^{<\omega}\) is a

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    given 解压缩程序\(M:2^{<\omega}\to 2^{<\omega}\), the *Kolmogorov complexity* of \tau on \(M\) is
    \begin{equation*}
    C_M(\tau)=\min\{\abs{\sigma}:M(\sigma)=\tau\}
    \end{equation*}
    #+END_definition

    If \(\tau\notin\ran M\), then \(C_M(\tau)=\infty\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    For any \(M:2^{<\omega}\to 2^{<\omega}\)
    \begin{equation*}
    U(\rho_M\sigma)=M(\sigma)
    \end{equation*}
    \(\rho_M\) is coding of \(M\), \(\abs{\rho_M}\) is the coding constant of \(M\) in \(U\)
    #+END_definition

    #+BEGIN_proof
    Every universal program \(U\) is *optimal*, that is, for any \(M\) there is coding
    constant \(c_M\) s.t. for any \tau,
    \begin{equation*}
    C_U(\tau)\le C_M(\tau)+c_M
    \end{equation*}
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    there is a universal machine
    #+END_theorem

    #+BEGIN_proof
    Let \(\{\Phi_e\}_{e\in\N}\) is a computable enumeration of all machines, let
    \begin{equation*}
    U(\underbrace{0\dots 0}_{e\text{ times}}1\sigma)=\Phi_e(\sigma)
    \end{equation*}
    therefore \(c_e=e+1\)
    #+END_proof

    Fix a universal machine
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    The Kolmogorov complexity of \tau is
    \begin{equation*}
    C(\tau)=C_U(\tau)
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c_1,c_2,c_3\), for any \(\tau\)
    1. \(C(\tau)\le\abs{\tau}+c_1\)
    2. \(C(\tau\tau)\le C(\tau)+c_2\)
    3. \(C(h(\tau))\le C(\tau)+c_3\), \(h\) is computable
    #+END_proposition

    #+BEGIN_proof
    1. suppose \(M(\sigma)=\sigma\), then for any \tau, \(C_U(\tau)\le C_M(\tau)+c_M=\abs{\tau}+c_M\)
    2. suppose \(M'(\tau)=\tau\tau\), \(M''(\sigma)=M'(U(\sigma))\), if \(U(\sigma)=\tau\), then \(M''(\sigma)=\tau\tau\)

       \(C(\tau\tau)\le C(\tau)+c_{M''}\)
    3. \(M(\tau)=h(\tau)\), \(M'(\sigma)=M(U(\sigma))\)
    #+END_proof

    \(C(\tau)\le\abs{\tau}+c_{\id}\) gives us an upper bound, therefore we can give a computable
    approximation:
    for any \(\tau\in 2^{<\omega}\), \(s\in\N\),
    \begin{equation*}
    C_s(\tau)=\min(\{\abs{\sigma}:U_s(\sigma)\downarrow=\sigma\}\cup\{\abs{\tau}+c_{\id}\})
    \end{equation*}

    we call \(\la n,\tau\ra\in\N\times 2^{<\omega}\) is a compression request

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    let \(W\) be a c.e. compression request sets, and \(\forall n\), there is at most \(2^n\) \(\tau\in 2^{<\omega}\)
    s.t. \(\la n,\tau\ra\in W\), then there is a \(M\)
    \begin{equation*}
    \la n,\tau\ra\in W\Leftrightarrow\exists\sigma(\abs{\sigma}=n\wedge M(\sigma)=\tau)
    \end{equation*}
    #+END_theorem

    Let \(\log n=\floor{\log_2n}\)

    let \(n=string(n)\), therefore there is \(c\) s.t.
    \begin{equation*}
    C(n)\le\log n+c
    \end{equation*}

    if \(C(\tau)=n\), there is a leftest \(\sigma\in 2^n\) s.t. \(U(\sigma)=\tau\), denoted by \(\tau^*_C\)

    Let \(C(\sigma,\tau)\) denote \(C(\la\sigma,\tau\ra)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is a constant \(c\)
    \begin{equation*}
    C(\tau,C(\tau))\le C(\tau_C^*)+c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(M(\sigma)=\la U(\sigma),\abs{\sigma}\ra\), suppose \(U(\sigma)=\tau^*_C\),
    then \(M(U(\sigma))=\la U(\tau^*_C),\abs{\tau_C^*}\ra=\la\tau,C(\tau)\ra\)

    \(M'=M(U(\sigma))\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    given \(d\in\omega\), \tau is *\(d\)-\(C\)-random* iff
    \begin{equation*}
    C(\tau)\ge\abs{\tau}-d
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. for any \(n\), there is \tau s.t. \(\abs{\tau}=n\) and \(C(\tau)\ge n\)
    2. \(\forall d\in\omega,n\in N\), there is \(2^n-2^{n-d}+1\) \(d\)-\(C\)-random strings of length n
    #+END_proposition

    #+BEGIN_proof
    1. there is \(2^n\) possibilities, but there are only \(2^n-1\) strings of length \(2^{<n}\)
    #+END_proof

    \sigma is semi-random iff \(C(\sigma)\ge\frac{\abs{\sigma}}{2}\)

    intuitively, the information of \(\sigma\tau\) shouldn't greater than the sum of \sigma of \tau. Therefore we
    wish that
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma)+C(\tau)+c
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    \(\forall d\in\N\) there is \mu s.t. \(C(\mu)\ge\abs{\mu}\) and for all such \mu, there is \(\sigma\prec\mu\), \(\mu=\sigma\tau\) and
    \begin{equation*}
    C(\mu)>C(\sigma)+C(\tau)+d
    \end{equation*}
    #+END_theorem

    #+ATTR_LATEX: :options []
    #+BEGIN_lemma
    \(\exists c_M\in\N\),\(\forall k\in\N\), there is \(\mu\) (\(\abs{\mu}\ge 2^{k+c_M+1}+k+c_M+1\)) there is \(\sigma\prec\mu\) s.t. \(C(\sigma)<\abs{\sigma}-k\)
    #+END_lemma

    #+BEGIN_proof
    Consider \(M\): input \rho, output \(M(\rho)=\nu\rho\) where \nu is the binary form
    of \(\abs{\rho}\), \(\forall\sigma\in\ran M\), we can write \sigma as \(\nu\rho\)
    and \(C(\sigma)\le C_M(\sigma)+c_M=\abs{\rho}+c_M=\abs{\sigma}-\abs{\nu}+c_M\). Given \(k\in\N\) and a sufficiently long
    \mu, let \(\nu=\mu\uhr k+c_M+1\), let \(n\) be the integer represented by \nu,
    let \(\rho=\mu\uhr[k+c_M+1,k+c_M+1+n)\), since \(\abs{\sigma}=k+c_M+1\),
    therefore \(n\in[2^{k+c_M},2^{k+c_M+1})\), therefore definition of \rho is valid. Finally
    let \(\sigma=\nu\rho\), then
    \begin{equation*}
    C(\sigma)\le\abs{\sigma}-\abs{\nu}+c_M=\abs{\Delta}-(k+c_M+1)+c_M<\abs{\Delta}-k
    \end{equation*}
    #+END_proof

    #+BEGIN_proof
    Given \(d\), let \(k=d+c_{\id}\), there is \mu s.t. \(\abs{\mu}\ge 2^{k+c_M+1}+k+c_M+1\)
    and \(C(\mu)\ge\mu\), by Lemma, there is \(\sigma\prec\mu\) s.t. \(C(\sigma)<\abs{\sigma}-k\). Let \(\mu=\sigma\tau\).

    \(\forall\tau\) there is \(C(\tau)\le\abs{\tau}+c_{\id}\),
    therefore \(C(\mu)\ge\abs{\mu}=\abs{\sigma}+\abs{\tau}\ge\abs{\sigma}+C(\tau)-c_{\id}>C(\sigma)+C(\tau)-c_{\id}+k=C(\sigma)+C(\tau)+d\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c\) s.t. \(\forall\sigma,\tau\in 2^{<\omega}\)
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma,\tau)+c
    \end{equation*}
    #+END_proposition

    Therefore there is no \(c\) s.t. \(C(\sigma,\tau)\le C(\sigma)+C(\tau)+c\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    There is \(c\) s.t. \(\forall\sigma,\tau\in 2^{<\omega}\)
    \begin{equation*}
    C(\sigma,\tau)\le C(\sigma)+C(\tau)+2\log C(\sigma)+c
    \end{equation*}
    and there is \(c\) s.t.
    \begin{equation*}
    C(\sigma\tau)\le C(\sigma)+C(\tau)+2\log C(\sigma)+c
    \end{equation*}
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    *Kolmogorov complexity of \sigma relative to \tau*
    \begin{equation*}
    C(\sigma|\tau)=\min\{\abs{\mu}:U^{\bar{\tau}}(\mu)=\sigma\}
    \end{equation*}
    where \(\bartau=\tau_0\tau_0\dots\tau_{\abs{\tau}-1}\tau_{\abs{\tau}-1}01\)
    #+END_definition

    We wish that \(C(\sigma\mid\sigma)\) is a constant

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. \(C\le_{wtt}0'\)
    2. \(B=\{\sigma\in 2^{<\omega}\mid C(\sigma)<\abs{\sigma}\}\) is simple set and \(wtt\)-complete (\(0'\le_{wtt}B\))
    3. \(C\) is not computable
    #+END_proposition

    #+BEGIN_proof
    1. \(C(x)\) can be approximated from top to
       down. \(C_s(x)=\min\{\abs{\sigma}\mid U_s(\sigma)\downarrow=x\}\cup\{\abs{x}+c_{\id}\}\)

       therefore the value of \(C_s(x)\) can change \(\abs{x}+c_{\id}\) times.

       Let \(R=\{(x,i)\mid C_s(x)\text{ has changed $i+1$ times}\}\), \(R\) is c.e., and \(C\le_TR\le_m0'\)

       In \(C\le_TR\), we ask whether \((x,i)\in R\) at most \(\abs{x}+c_{\id}\) times, therefore \(c\le_{wtt}R\)

    2. \(B\) is c.e. \(\N\setminus B\) is infinite since for any \(n\), there is \(\sigma\), \(\abs{\sigma}=n\)
       and \(C(\sigma)\ge n=\abs{\sigma}\), therefore \(\sigma\notin B\)

       Suppose \(\N\setminus\) contains an infinite c.e. set \(A\), there
       is \(A_0=\{a_0,a_1,\dots\}\subseteq A\), \(\la a_i\ra_{i\in\N}\) computable,
       and \(a_0<a_1<\dots\), \(\log a_0<\log a_1<\dots\), therefore \(\forall i\in\N\), \(\abs{a_i}=\log a_i\ge i\).
       There is \(c,d\) s.t. \(C(a_i)\le C(i)+c\le\log i+d\).

       Note that for a\(a_i\in A_0\subseteq A\subseteq\N\setminus\), \(C(a_i)\ge\abs{a_i}\)

        for sufficiently large \(i\), \(C(a_i)\le\log i+d<i\le\abs{a_i}=\log a_i\)

        construct a c.e. request set \(W\): if \(n\in 0'_s\setminus 0'_{s-1}\), then \((n,x)\in W\) where \(x\)
        is the leftest string s.t. \(\abs{x}=2n\) and \(C_s(x)\ge 2n\) (there is \(\abs{x}=2n\)
        s.t.\(C(x)\ge 2n\)). \(W\) is a valid request set. Let \(M\) be the program implementing \(W\).

        In  order to compute \(0'(n)\), we use \(B\) to compute a \(s\) s.t. for any \(x\),
        if \(\abs{x}=2n\), then \(B_s(x)=B(x)\)

        Then we claim that \(0'_s(n)=0'(n)\). Suppose there is \(t>s\) s.t. \(n\in 0'_t\setminus 0'_{t-1}\),
       then there is \(x\) s.t. \(\abs{x}=2n\) and \(C_s(x)\ge 2n\) but \(C(x)\le C_M(x)+C_M=n+c_M\).
       If \(n\) is sufficiently large, then \(C(x)=n+c_M<2n\), \(x\in B(x)\setminus B_s(x)\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(M\) is prefix-free if its domain is prefix-free
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    there is an effective enumeration \(\{\Psi_e\}_{e\in\N}\) for all prefix-free machine, therefore there is
    a universal prefix-free machine \(U^{\pf}\) s.t.
    \begin{equation*}
    U^{\pf}(\underbrace{1\dots 1}_{e}0\sigma)=\Psi_e(\sigma)
    \end{equation*}
    #+END_theorem

    #+BEGIN_proof
    If \(\{\Phi_e\}_{e\in\N}\) is an enumeration of all machine and suppose \(\abs{\dom\Phi_{e,s}\setminus\Phi_{e,s-1}}\le 1\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    prefix Kolmogorov complexity
    \begin{equation*}
    K(\sigma)=K_{U^{\pf}}(\sigma)=C_{U^{\pf}}(\sigma)
    \end{equation*}
    and
    \begin{equation*}
    K(\tau|\sigma)=\min\{\abs{\mu}\mid(U^{\pf})^{\barsigma}=\tau\}
    \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    there is \(c\), \(\forall \tau_1,\tau_2\in 2^{<\omega}\)
    \begin{equation*}
    K(\tau_1,\tau_2)\le K(\tau_1)+K(\tau_2)+c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    Consider \(M\): \(\forall\sigma_1\sigma_2\), \(M(\sigma_1,\sigma_2)=\la U^{\pf}(\sigma_1),U^{\pf}(\sigma_2)\ra\), if \(\mu\prec\mu'\)
    and \(M(\mu)\downarrow\), \(M(\mu')\downarrow\), then there is \(\sigma_1\prec\mu\), \(\sigma_1'\prec\mu'\), \(U^{\pf}(\sigma_1)\downarrow\)
    #+END_proof

    \(C(\sigma)\le K(\sigma)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    If \(h:2^{<\omega}\to 2^{<\omega}\) is computable, then \(\exists c\) for all \sigma, \(K(h(\sigma))\le K(\sigma)+c\)
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(\exists c_1,c_2\in\N\), \(\forall\sigma\)
    \begin{equation*}
    K(\sigma)\le K(\abs{\sigma})+\abs{\sigma}+c_1\le 2\log\abs{\sigma}+\abs{\sigma}+c_2
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    \(M(\ove{\abs{\sigma}}\sigma)=\sigma\)
    #+END_proof


    #+BEGIN_proof
    take \(M(\ove{\abs{\sigma}}\sigma)=\sigma\). If \(M\) is not prefix free,
    suppose \(\ove{\abs{\sigma}}\sigma\prec\ove{\abs{\tau}}\tau\), then \(\abs{\sigma}=\abs{\tau}\), then \(\sigma=\tau\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \(\forall d\exists\sigma\)
    \begin{equation*}
    K(\sigma)>\abs{\sigma}+\log\abs{\sigma}+d
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    if there is \(d\), \(\forall \sigma\), \(K(\sigma)\le\abs{\sigma}+\log\abs{\sigma}+d\)
    \begin{equation*}
    \sum_{\sigma\in 2^{<\omega}}2^{-K(\sigma)}\le\sum_{\tau\in\dom U^{\pf}}2^{-\abs{\tau}}=\lambda([\dom U^{\pf}]^{\prec})\le 1
    \end{equation*}
    现在
    \begin{equation*}
    \sum_{\sigma\in 2^{<\omega}}2^{-K(\sigma)}\ge\sum_{\sigma\in 2^{<\omega}}2^{-(\abs{\sigma}+\log\abs{\sigma}+d)}=
    \sum_{n=1}^\infty 2^n\cdot 2^{-(n+\log n+d)}=2^{-d}\sum_{i=1}^n\frac{1}{n}
    \end{equation*}
    #+END_proof

    *Chaitin's constant*
    \begin{equation*}
    \Omega=\lambda([\dom U^{\pf}]^{\prec})
    \end{equation*}
    for any prefix machine \(M\), let \(\Omega_M=\lambda([\dom M]^{\prec})\)为\(M\)的停机概率

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    sequence \(\{\la d_i,\tau_i\ra\}_{i\in\N}\) computable, \(d_i\in\N\), \(\tau_i\in 2^{<\omega}\), if \(\sum_{i\in\N}2^{-d_i}\le 1\),
    then \(\{\la d_i,\tau_i\ra\}_{i\in\N}\)is a 请求序列, where \(\sum_{i\in\N}^{-d_i}\le 1\) is *weight condition*
    #+END_definition

    #+ATTR_LATEX: :options [Chaitin]
    #+BEGIN_lemma
    for any 请求序列\(\{\la d_i,\tau_i\ra\}_{i\in\N}\), there is a prefix free machine \(M\) satisfying the sequence,
    i.e., there is prefix free set \(\{\sigma_i:i\in\N\}=\dom M\), and for all \(i\in\N\), \(M(\sigma_i)=\tau_i\), \(\abs{\sigma_i}=d_i\)
    #+END_lemma

    #+BEGIN_proof
    define \(S_i\) and \(S_i^*\) 记录可分配的 “号码库”与已分配的号码

    /step 0/: let \(S_0=\{\emptyset\}\), \(S^*_0=\emptyset\)

    recursively define \(S_i\) and \(S_i^*\) s.t.
    1. \(S_i^*\cup S_i\) is prefix-free
    2. \(S_i^*\cup S_i\)  is finite
    3. \(\lambda([S_i^*\cup S_i]^{\prec})=1\)
    4. \(\forall n\in\N\), there is at most one \(\sigma\in S_i\) s.t. \(\abs{\sigma}=n\)


    /Step 1/: let \(\sigma_0=0^{d_0}\), let \(S_1=\{1,01,\dots,0^{d_0-1}1\}\), \(S_1^*=\{0^{d_0}\}\)

    /Step \(i+1\)/: hope to satisfy \((d_i,\tau_i)\),
    1. there is \(\sigma\in S_i\) s.t. \(\abs{\sigma}=d_i\), let \(\sigma_i=\sigma\), \(S_{i+1}=S_i\setminus\{\sigma_i\}\), \(S_i^*=S_i^*\cup\{\sigma_i\}\)
    2. if not, find largest \(n\) s.t. \(n<d_i\) and there is \(\sigma\in S_i\), \(\abs{\sigma}=n\)

       *Claim*: we can always find such \(n\) and \sigma

       Otherwise \(\lambda([S_i]^{\prec})<\sum_{n>d_i}2^{-n}=2^{-d_i}\) (by 2 and 4),
       then \(\lambda([S_i^*]^{\prec})=\sum_{j<i}2^{-d_j}>1-2^{-d_i}\), then \(\sum_{j\le i}2^{-d_j}>1\), contradicing
       请求序列

       let \(\sigma_i=\sigma 0^{d_i-n}\), \(S_{i+1}^*=S_i^*\cup\{\sigma_i\}\), \(S_{i+1}=S_i\setminus\{\sigma\}\cup\{\sigma 1,\dots,\sigma 0^{d_i-n-1}1\}\)


    Now let \(\dom M=\bigcup_i S_i\) and \(M(\sigma_i)=\tau_i\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_corollary
    If there is 请求序列\(\{\la d_i,\tau_i\ra:i\in\N\}\), then there is \(c\in\N\) for all \(i\in\N\)
    \begin{equation*}
    K(\tau_i)\le d_i+c
    \end{equation*}
    #+END_corollary

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    * for a fixed \(d\in\N\), \sigma is *\(d\)-\(K\)-random* iff
      \begin{equation*}
      K(\sigma)\ge\abs{\sigma}-d
      \end{equation*}
    * \(Z\in 2^\omega\) is *1-random* iff \(\exists d\in\N\) s.t. any finite initial segment of \(Z\) is \(d\)-random,
      i.e., \(\forall n\in\N\)
      \begin{equation*}
      K(Z\uhr n)\ge n-d
      \end{equation*}
    #+END_definition

    this is impossible for \(C\)

    for \(s\in\N\), let
    \begin{equation*}
    \Omega_s=\lambda([\{\sigma:U_s^{\pf}(\sigma)\downarrow\}]^\prec)
    \end{equation*}
    \(s\mapsto\Omega_s\) is computable, \(\Omega_s\le\Omega_{s+1}\le\Omega\) and \(\Omega=\lim_{s\to\infty}\Omega_s\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(Z\in 2^\omega\), let \(L(Z)=\{\sigma\in 2^{<\omega}:\sigma<_LZ\}\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    View \Omega in binary extension, then \(L(\Omega)\) is c.e.
    #+END_proposition

    #+BEGIN_proof
    \(L(\Omega)=\bigcup[\Omega_s\cup L(\Omega_s)]\)

    Let \(A_s=\{\sigma\in 2^{<s}\mid\sigma<_L\Omega_s\}\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    \(Z\in 2^\omega\) (real \(r=z.Z\), \(z\in\Z\))is *left c.e.* iff \(L(Z)\) is c.e.
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. TFAE
       1. \(Z\) left c.e.
       2. there is computable \(\sigma_0<_L\sigma_1<\dots\) s.t. \(\lim_n\sigma_n=Z\), that is, \(\forall m\in\N\) there is \(\sigma_n\)
          s.t. \(\sigma_n\uhr m=Z\uhr M\)
    2. if \(Z\) (as a characteristic function) is c.e., then \(Z\) is left c.e.
    #+END_proposition

    \(0\le_L00\), \(\sigma\prec\tau\Rightarrow\sigma\le_L\tau\)

    #+BEGIN_proof
    1. \(\Rightarrow\):

       \(\Leftarrow\): let \(A_s=\{\tau\in 2^{<s}\mid\tau<_L\sigma_s\}\), then \(\bigcup_sA_s=L(Z)\)
    #+END_proof

    not all left c.e. set is c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    let
    \begin{equation*}
    A_0=010101\cdots
    \end{equation*}
    run \(\Phi_{e,s}(2e+1)\), assume for all \(s\in\N\), there is at most one \(e\le s\) s.t. \(\Phi_e(2e+1)\)
    runs. If \(A_s\) is defined, then \(A_{s+1}\) is: if \(\Phi_{e,s}(2e+1)\downarrow\),
    then \(A_{s+1}(2e)=1\), \(A_{s+1}(2e+1)=0\), the rest is the same as \(A_s\),
    let \(A=\lim_sA_s\)

    If \(A=W_e\), \(2e+1\in W_e\), then \(A(2e)=1\), \(A(2e+1)=0\), \(A\neq W_e\)

    If \(2e+1\notin W_e\), then \(A(2e+1)=1\), \(A\neq W_e\)
    #+END_examplle

    actually \(A\) is 2-c.e.

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. if \(Z\) is left c.e., then \(Z\le_T0'\)
    2. \(\Omega\equiv_T0'\)
    #+END_proposition

    #+BEGIN_proof
    1. input \(n\), to determine whether \(n\in Z\), ask \(0'\) whether those 01-string of
       length \(n+1\) are belong to \(L(Z)\)

       if there is \tau of length \(n\) and \(\tau 0\in L(Z)\), \(\tau 1\notin L(Z)\), then output \(n\in Z\),
       otherwise \(n\notin Z\)

       therefore \(Z\le_{tt}0'\Rightarrow\) \(Z\) is \omega-c.e.

    2. Goal: \(0'\le_T\Omega\)

       Consider: input \(0^e1\), run \(\Phi_e(e)\), if \(\Phi_e(e)\downarrow\), let \(M(0^e1)=\la\ra\), otherwise \(M\)
       doesn't stop, \(\dom M\subseteq\{0^e1\mid e\in 0'\}\), therefore \(M\) is prefix-free, assume \(M=\Psi_d\),
       let \(\rho=0^d1\) be \(M\)'s coding string, then \(U^{\pf}(\rho 0^e1)=M(0^e1)\),

       then to determine whether \(e\in 0'\), we only need to know whether \(\rho 0^e1\in\dom U^{\pf}\).
       Compute \(s\) s.t. \(\Omega\setminus\Omega_s<2^{-\abs{\rho}-e-1}\). Since \(\lim_s\Omega_s=\Omega\), we can always find
       such \(s\), then \(U_s^{\pf}(\rho 0^e1)\downarrow\Leftrightarrow U^{\pf}(\rho 0^e1)\downarrow\Leftrightarrow e\in 0'\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    \Omega is 1-random, that is there is \(c\in\N\), for all \(n\in\N\)
    \begin{equation*}
    K(\Omega\uhr n)\ge n-c
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    for any \tau, if \(\abs{\tau}<n-c\), then \(U^{\pf}(\tau)\neq\Omega\uhr n\)

    if \(U^{\pf}(\tau)=\Omega\uhr n\), then there is \(s\) s.t. \(U^{\pf}_s(\tau)=\Omega_s\uhr n=\Omega\uhr n\)

    We need to eliminate all sufficiently short \tau satisfying this

    Let \(\Phi_e(\tau,d)\) compute all \(U^{\pf}_s(\tau)\) and \(\Omega_s\), if we find \(s,n\)
    s.t. \(U^{\pf}_s(\tau)=\Omega_s\uhr n\) and \(\abs{\tau}<n-d-1\), then output smallest \(\mu\notin\ran U^{\pf}_s\)

    By smn, there is recursive function \(g\) s.t. \(\Phi_{g(e,d)}(\tau)=\Phi_e(\tau,d)\), by fixed point
    theorem, there is a fixed point \(c_e\) of \(g(e,x)\) s.t. \(\Phi_{c_e}(\tau)=\Phi_{g(e,c_e)}(\tau)=\Phi_e(\tau,c_e)\)

    Suppose there is \(s,n\) s.t. \(U^{\pf}_s(\tau)\downarrow=\Omega_s\uhr n\) and \(\abs{\tau}<n-c_e-1\),
    then \(\Phi_{c_e}(\tau)=\mu\notin\ran U^{\pf}\). By definition, \(\dom\Phi_{c_e}\subseteq\dom U^{\pf}\),
    therefore \(\Phi_{c_e}\) is prefix-free, we may assume \(f\) is the function transform machine to
    prefix-free function, then \(\Phi_{c_e}=\Phi_{f(c_e)}=\Psi_{c_e}\), let \(\nu=1^{c_e}0\tau\),
    then \(U^{\pf}(\nu)=\Psi_{c_e}(\tau)=\Phi_{c_e}(\tau)=\mu\), but \(\mu\not\in\ran U_s^{\pf}\),
    therefore \(\nu\in\dom U^{\pf}\setminus\dom U_s^{\pf}\),
    therefore \(\Omega-\Omega_s\ge 2^{-\abs{\nu}}=2^{-(c_e+1+\abs{\tau})}>2^{-n}\), then \(\Omega_s\uhr n\neq\Omega\uhr n\)
    #+END_proof
