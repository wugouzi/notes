#+title: Distributed Algorithms

#+AUTHOR: Nancy Lynch
#+EXPORT_FILE_NAME: ../latex/DistributedAlgorithms/DistributedAlgorithms.tex
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \makeindex
#+STARTUP: shrink
* Modelling \rom{2}: Asynchronous System Model
** I/O Automata
        A *signature* \(S\) is a triple consisting of three disjoint sets of actions: the *input actions*,
        \(in(S)\), the *output actions*, \(out(S)\), and the *internal actions*, \(int(S)\). We define the
        *external actions*, \(ext(S)\), to be \(in(S)\cup out(S)\); and *locally controlled actions*, \(local(S)\)
        to be \(out(S)\cup int(S)\); and \(acts(S)\) to be all the actions of \(S\). The *external signature*,
        \(extsig(S)\), is defined to be the signature \((in(S),out(S),\emptyset)\).

        An *I/O automaton* \(A\), which we also call simply an *automaton*, consists of five components:
        * \(sig(A)\), a signature
        * \(states(A)\)
        * \(start(A)\), a nonempty subset of \(states(A)\) known as the *start states* or *initial states*
        * \(trans(A)\), a *state-transition relation* where \(trans(A)\subseteq states(A)\times
          acts(sig(A))\times states(A)\).
        * \(tasks(A)\), a *task partition*, which is an equivalence relation on \(local(sig(A))\) having at most
          countably many equivalence classes

        We use \(acts(A)\) as shorthand for \(acts(sig(A))\), and similarly \(in(A)\), and so on.

        We call an element \((s,\pi,s')\) of \(trans(A)\) a *transition*, or *step*, of \(A\). The transition
        \((s,\pi,s')\) is called  an *input transition*, *output transition*, and so on, based on whether the
        action \(\pi\) is an input action, output action, and so on.

        If for a particular state \(s\) and action \(\pi\), \(A\) has some transition of the form
        \((s,\pi,s')\), then we say that \(\pi\) is *enabled* in \(s\). Since every input action is required to
        be enabled in every state, automata are said to be *input-enabled*. We say that state \(s\) is *quiescent*
        if the only actions that are enabled in s are input actions.

        A task \(C\) is *enabled* in a state \(s\) means somes action in \(C\) is enabled in \(s\).

        #+ATTR_LATEX: :options [Channel I/O automaton]
        #+BEGIN_examplle
        [[label:8.1.1]]
        Consider a communication channel automaton \(C_{i,j}\). Let \(M\) be a fixed message alphabet.
        * *Signature*:
          \begin{alignat*}{2}
          &\text{Input}:\hspace{3cm}&&\text{Output:}\\
          &\quad send(m)_{i,j},m\in M&&\quad receive(m)_{i,j},m\in M
          \end{alignat*}
        * *States*: \(queue\), a FIFO queue of elements of \(M\), initially empty
        * *Transitions*:
          \begin{alignat*}{2}
          &send(m)_{i,j}\hspace{3cm}&&receive(m)_{i,j}\\
          &\quad\text{Effect:}&&\quad\text{Precondition:}\\
          &\quad\quad\text{add }m\text{ to }queue&&\quad\quad m\text{ is first on }queue\\
          &&&\quad\text{Effect:}\\
          &&&\quad\quad\text{remove first element of }queue
          \end{alignat*}
        * *Tasks*: \(\{receive(m)_{i,j}:m\in M\}\)
        #+END_examplle

        #+ATTR_LATEX: :options [Process I/O automata]
        #+BEGIN_examplle
        [[label:8.1.2]]

        Consider a process automaton \(P_i\). \(V\) is a fixed value set, \(null\) is a special value not in \(V\), \(f\) is a fixed function,
        \(f:V^n\to V\)
        * *Signature*:
          * Input:
            * \(init(v)_i,v\in V\)
            * \(receive(v)_{j,i}\), \(v\in V\), \(1\le j\le n\), \(j\neq i\)
          * Output:
            * \(decide(v)_i\), \(v\in V\)
            * \(send(v)_{i,j}\), \(v\in V\), \(1\le j\le n\), \(j\neq i\)
        * *States*: \(val\), a vector indexed by \(\{1,\dots,n\}\) of elements in \(V\cup\{null\}\), all
          initially \(null\)
        * *Transitions*:
          \begin{alignat*}{2}
          &init(v)_i,v\in V\hspace{2cm}&&receive(v)_{j,i},v\in V\\
          &\quad\text{Effect:}&&\quad\text{Effect:}\\
          &\quad\quad val(i):=v&&\quad\quad val(j):=v\\\\
          &send(v)_{i,j}, v\in V&&decide(v)_i,v\in V\\
          &\quad\text{Precondition:}&&\quad\text{Precondition:}\\
          &\quad\quad val(i)=v&&\quad\quad\text{for all }j, 1\le j\le n:\\
          &\quad\text{Effect:}&&\quad\quad\quad val(j)\neq null\\
          &\quad\quad\quad\text{none}&&\quad\quad v=f(val(1),\dots,val(n))\\
          &&&\quad\text{Effect:}\\
          &&&\quad\quad\text{none}
          \end{alignat*}
        * *Tasks*: for every \(j\neq i\): \(\{send(v)_{i,j}:v\in V\}\), \(\{decide(v)_i:v\in V\}\).

        An *execution fragment* of \(A\) is either a finite sequence \(s_0,\pi_1,s_1,\pi_2,\dots,\pi_r,s_r\) or
        an infinite sequence \(s_0,\pi_1,s_1,\pi_2,\dots\), of alternating states and actions of \(A\) s.t.
        \((s_k,\pi_{k+1},s_{k+1})\) is a transition of \(A\) for every \(k\ge 0\). An execution fragment
        beginning with a start state is called an *execution*. We denote the set of executions of \(A\) by
        \(execs(A)\). A state is *reachable* if it is the final state of a finite execution of \(A\).

        If \(\alpha\) is a finite execution fragment of \(A\) and \(\alpha'\) is any execution fragment of
        \(A\) that begins with the last state of \(\alpha\), then we write \(\alpha\cdot\alpha'\) to represent
        the sequence obtained by concatenating \(\alpha\) and \(\alpha'\), eliminating the duplicate
        occurrence of the last state of \(\alpha\).
        #+END_examplle

        The *trace* of an execution \(\alpha\) of \(A\), denoted by \(trace(\alpha)\), is the subsequence of
        \(\alpha\) consisting of all the external actions. We say that \(\beta\) is a *trace* of \(A\)  if
        \(\beta\) is the trace of an execution of \(A\). We denote the set of traces of \(A\) by
        \(traces(A)\).

        #+ATTR_LATEX: :options [Executions]
        #+BEGIN_examplle
        [[label:8.1.3]]

        The following are three executions of the automaton \(C_{i,j}\) described in Example ref:8.1.1
        (assuming that the message alphabet \(M\) is equal to the set \(\{1,2\}\)). Here we indicate the
        states by putting the sequences in /queue/ in brackets; \(\lambda\) denotes the empty sequence.

        \begin{align*}
        &[\lambda],send(1)_{i,j},[1],receive(1)_{i,j},[\lambda],send(2)_{i,j},[2],receive(2)_{i,j},[\lambda]\\
        &[\lambda],send(1)_{i,j},[1],receive(1)_{i,j},[\lambda],send(2)_{i,j},[2]\\
        &[\lambda],send(1)_{i,j},[1],send(1)_{i,j},[11],send(1)_{i,j},[111],\dots
        \end{align*}
        #+END_examplle
** Operations on Automata
*** Composition
        The composition identifies actions with the same name in different component automata. When any
        component automaton performs a step involving \(\pi\), so do all component automata that have \(\pi\)
        in their signatures.

        We impose certain restrictions on the automata that may be composed.
        1. Since internal actions of an automaton \(A\) are intended to be unobservable by any other automaton
           \(B\), we do not allow \(A\) to be composed with \(B\) unless the internal actions of A are
           disjoint from the actions of B.

           Otherwise, A's performance of an internal action could force B to take a step.
        2. In order that the composition operation might satisfy nice properties, we establish a convention
           that at most one component automaton "controls" the performance of any given action; that is, we do
           not allow \(A\) and \(B\) to be composed unless the sets of output actions of A and B are disjoint.
        3. We do not preclude the possibility of composing a countably infinite collection of automata, but we
           do require in this case that each action must be an action of only finitely many of the component automata.

        A countable collection \(\{S_i\}_{i\in I}\) of signatures to be *compatible* if for all \(i,j\in I\),
        \(i\neq j\), all of the following hold:
        1. \(int(S_i)\cap acts(S_j)=\emptyset\)
        2. \(out(S_i)\cap out(S_j)=\emptyset\)
        3. No action is contained in infinitely many sets \(acts(S_i)\)
        We say that a collection of automata is *compatible* if their signatures are compatible.

        The *composition* \(S=\prod_{i\in I}S_i\) of a countable compatible collection of signatures
        \(\{S_i\}_{i\in I}\) is defined to be the signature with
        * \(out(S)=\bigcup_{i\in I}out(S_i)\)
        * \(int(S)=\bigcup_{i\in I}int(S_i)\)
        * \(in(S)=\bigcup_{i\in I}in(S_i)-\bigcup_{i\in I}out(S_i)\)

        Now the *composition* \(A=\prod_{i\in I}A_i\) of a countable, compatible collection of I/O automata
        \(\{A_i\}_{i\in I}\) can be defined. It is the automaton defined as:
        * \(sig(A)=\prod_{i\in I}sig(A_i)\)
        * \(states(A)=\prod_{i\in I}states(A_i)\)
        * \(start(A)=\prod_{i\in I}start(A_i)\)
        * \(trans(A)\) is the set of triples \((s,\pi,s')\) s.t., for all \(i\in I\), if \(\pi\in acts(A_i)\),
          then \((s_i,\pi,s_i')\in trans(A_i)\); otherwise \(s_i=s_i'\).


        Note that an action \(\pi\) that is an output of one component and an input of another is classified
        as an output action in the composition, not as an internal action. This is because we want to permit
        the possibility of further communication using \(\pi\).

        #+ATTR_LATEX: :options [Composition of automata]
        #+BEGIN_examplle
        [[label:8.2.1]]
        Consider a fixed index set \(I=\{1,\dots,n\}\) and let \(A\) be the composition of all the process
        automata \(P_i\), \(i\in I\) from Example [[ref:8.1.2]]. In order to compose them, we must assume that the
        message alphabet \(M\) for the channel automata contains the value set \(V\) for the process automata.
        #+ATTR_LATEX: :width .8\textwidth :float nil
        #+NAME: 8.3
        #+CAPTION: Composition of \(P_i\)s and \(C_{i,j}\)s
        [[../images/DistributedAlgorithms/3.png]]

        1. An \(init(v)_i\) input action, which deposits a value in \(P_i\)'s \(val(i)\) variable, \(val(i)_i\).
        2. A \(send(v)_{i,j}\) output action, by which \(P_i\)'s value \(val(i)_i\) gets put into channel \(C_{i,j}\).
        3. A \(receive(v)_{i,j}\) output action, by which the first message in \(C_{i,j}\) is removed and
           simultaneously placed into \(P_j\)'s variable \(val(i)_j\).
        4. A \(decide(v)_i\) output action, by which \(P_i\) announcs its current computed value.

        #+END_examplle

        Given an execution \(\alpha=s_0,\pi_1,s_1,\dots\), of \(A\), let \(\alpha|A_i\) be the sequence
        obtained by deleting each pair \(pi_r,s_r\) for which \(\pi_r\) is not an action of \(A_i\) and
        replacing each remaining \(s_r\) by \((s_r)_i\).

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        1. If \(\alpha\in execs(A)\), then \(\alpha|A_i\in execs(A_i)\) for every \(i\in I\).
        2. If \(\beta\in traces(A)\), then \(\beta|A_i\in traces(A_i)\) for every \(i\in I\).
        #+END_theorem

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\alpha_i\) is an execution of \(A_i\) for every \(i\in I\), and suppose \(\beta\) is a
        sequence of actions in \(ext(A)\) s.t. \(\beta|A_i=traces(\alpha_i)\) for every \(i\in I\). Then there
        is an execution \(\alpha\) of \(A\) s.t. \(\beta=trace(\alpha)\) and \(\alpha_i=\alpha|A_i\) for every
        \(i\in I\).
        #+END_theorem

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\)  be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\beta\) is a sequence of actions in \(ext(A)\). If \(\beta|A_i\in traces(A_i)\) for every
        \(i\in I\), then \(\beta\in traces(A)\).
        #+END_theorem
*** Hiding
        If \(S\) is a signature and \(\Phi\subset out(S)\), then \(hide_\phi(S)\) is defined to be the new
        signature \(S'\), where \(in(S')=in(S)\), \(out(S')=out(S)-\Phi\) and \(int(S')=int(S)\cup\Phi\).

        If \(A\) is an automaton and \(\Phi\subseteq out(A)\), then \(hide_\Phi(A)\) is the automaton \(A'\)
        obtained from \(A\) by replacing \(sig(A)\) with \(sig(A')=hide_\Phi(sig(A))\).
*** Fairness
        An execution fragment \(\alpha\) of an I/O automaton \(A\) is said to be *fair* if the following
        conditions hold for each class \(C\) of \(tasks(A)\):
        1. If \(\alpha\) is finite, then \(C\) is not enabled in the final state of \(\alpha\)
        2. If \(\alpha\) is infinite, then \(\alpha\) contains either infinitely many events from \(C\) or
           infinitely many occurrences of states in which \(C\) is not enabled.

        We use the term *event* to denote the occurrence of an action in a sequence.

        * We can understand the definition of fairness as saying that infinitely often, each task \(C\) is
          given a turn. Whenever this happens, either an action of \(C\) gets performed or no action from
          \(C\) could possibly be performed since no such action is enabled.
        * We can think of a finite fair execution as an execution at the end of which the automaton
          repeatedly gives turns to all the tasks in round-robin order, but never succeeds in performing any
          action since none are enabled in the final state. <<P1>>

        We denote the set of fair executions of \(A\) by \(fairexecs(A)\). We say that \(\beta\) is a *fair
        trace* of \(A\) if \(\beta\) is the trace of a fair execution of \(A\), and we denote the set of fair
        traces of \(A\) by \(fairtraces(A)\).

        #+ATTR_LATEX: :options [Fairness]
        #+BEGIN_examplle
        In Example [[ref:8.1.3]], the first execution given is fair, because no \(receive\) action is enabled in
        its final state. The second is not fair, because it is finite and a \(receive\) action is enabled in
        the final state. The third is not fair, because it is infinite, contains no \(receive\) events, and
        has \(receive\) actions enabled at every point after the first step.
        #+END_examplle

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        1. If \(\alpha\in fairexecs(A)\), then \(\alpha|A_i\in fairexecs(A_i)\) for every \(i\in I\).
        2. If \(\beta\in fairtraces(A)\), then \(\beta|A_i\in fairtraces(A_i)\) for every \(i\in I\).
        #+END_theorem

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\alpha_i\) is a fair execution of \(A_i\) for every \(i\in I\), and suppose \(\beta\) is a
        sequence of actions in \(ext(A)\) s.t. \(\beta|A_i=trace(\alpha_i)\) for every \(i\in I\). Then there
        is a fair execution \(\alpha\) of \(A\) s.t. \(\beta=trace(\alpha)\) and \(\alpha_i=\alpha|A_i\) for
        every \(i\in I\).
        #+END_theorem

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\beta\) is a sequence of actions in \(ext(A)\). If \(\beta|A_i\in fairexecs(A_i)\)  for
        every \(i\in I\), then \(\beta\in fairexecs(A)\).
        #+END_theorem

        #+ATTR_LATEX: :options [Fairness]
        #+BEGIN_examplle
        Consider the fair executions of the system of three processes and three channels in Example ref:8.2.1.
        In every fair execution, every message that is sent is eventually received.

        In every fair execution containing least one \(init_i\) event for each \(i\), each process sends
        infinitely many messages to each other processes and each process performs infinitely many \(decide\) steps

        In every fair execution that does not contain at least one \(init\) event for each process, no process
        ever performs a \(decide\) step.
        #+END_examplle

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(A\) be any I/O automaton.
        1. If \(\alpha\) is a finite execution of \(A\), then there is a fair execution of \(A\) that starts
           with \(\alpha\).
        2. If \(\beta\) is a finite trace of \(A\), then there is a fair trace of \(A\) that starts with \(\beta\).
        3. If \(\alpha\) is a finite execution of \(A\) and \(\beta\) is any sequence of input actions of
           \(A\), then there is a fair execution \(\alpha\cdot\alpha'\) of \(A\) s.t. the sequence of input
           actions in \(\alpha'\) is exactly \(\beta\)
        4. If \(\beta\) is a finite trace of \(A\) and \(\beta'\) is any sequence of input actions of \(A\),
           then there is a fair execution \(\alpha\cdot\alpha'\) of \(A\) s.t. \(trace(\alpha)=\beta\) and
           s.t. the sequence of input actions in \(\alpha'\) is exactly \(\beta'\)
        #+END_theorem
** Inputs and Outputs for Problems
** Properties and Proof Methods
*** Invariant Assertions
*** Trace Properties
        A *trace property* \(P\) consists of the following:
        * \(sig(P)\), a signature containing no internal actions
        * \(traces(P)\), a set of (finite or infinite) sequences of actions in \(acts(sig(P))\)

        That is, a trace property specifies both an external interface and a set (in other words, a property)
        of sequences observed at that interface. We write \(acts(P)\) as shorthand for \(acts(sig(P))\), and
        similarly \(in(P)\), and so on.

        The statement that an I/O automaton \(A\) satisfies a trace property \(P\) can be mean either of two
        different things:
        1. \(extsig(A)=sig(P)\) and \(traces(A)\subseteq traces(P)\)
        2. \(extsig(A)=sig(P)\) and \(fairtraces(A)\subseteq traces(P)\)
        The fact that \(A\) is input-enabled ensures that \(fairtraces(A)\) contains a response by \(A\) to
        each possible sequence of input actions. If \(fairtraces(A)\subseteq traces(P)\), then all of the
        resulting sequences must be included in the property \(P\).

        #+ATTR_LATEX: :options [Automata and trace properties]
        #+BEGIN_examplle
        Consider automata and trace properties with input set \(\{0\}\) and output set \(\{1,2\}\). First
        suppose that
        #+END_examplle
* Mutual Exclusion
** Asynchronous Shared Memory Model
        The system is modelled as a collection of processes and shared variables,
        with interactions. Each process \(i\) is a kind of state machine, with a set statesi of states and a subset \(start\) of \(states_i\) indicating the
        start states, just as in the synchronous setting. However, now process \(i\) also has labelled
        \(actions\), describing the activities in which it participates. These are classified as either
        \(input\), \(output\), or \(internal\) actions. We further distinguish between two different kinds of
        internal actions: those that involve the shared memory and those that involve strictly local
        computation. If an action involves the shared memory, we assumethat it only involves one shared
        variable.

        There is a transition relation \(trans\) for the entire system, which is a set of \((s,\pi,s')\)
        triples, where \(s\) and \(s'\) are *automaton states*, that is, combinations of states for all the
        processes and values for all the shared variables, and where \(\pi\)  is the label of an input,
        output, or internal action. We call these combinations of process states and variable values
        "automaton states" because  the entire system is modelled as a single automaton. The statement that
        \((s,\pi,s')\in trans\) says that from automaton state \(s\) it is possible to go to automaton state
        \(s'\) as a result of performing action \(\pi\).

        We assume that input actions can always happen, that is, that the system is input-enabled. Formally,
        this means that for every automaton state \(s\) and input action \(\pi\), there exists \(s'\) such
        that \((s,\pi,s')\in trans\). In contrast, output and internal steps might be enabled only in a subset
        of the states. The intuition behind the input-enabling property is that the input actions are
        controlled by an arbitrary external user, while the internal and output actions are controlled by the
        system itself.


** The Problem
        The mutual exclusion problem involves the allocation of a single, indivisible, nonshareable resource
        among \(n\) *users*, \(U_1,\dots,U_n\).

        A user with access to the resource is modelled as being in a *critical region*, which is simply a
        designated subset of its states. When a user is not involved in any way with the resource, it is said
        to be in the *remainder region*. In order to gain admittance to its critical region, a user executes a
        *trying protocol*, and after it is done with the resource, it executes an (often trivial) *exit protocol*.
        This procedure can be repeated, so that each user follows a cycle, moving from its
        /remainder region/ (R) to its /trying region/ (T), then to its /critical region/ (C), then to its /exit
        region/ (E), and then back again to its remainder region.  

        #+ATTR_LATEX: :width .2\textwidth :float nil
        #+NAME: 10.2
        #+CAPTION: The cycle of regions of a single user
        [[../images/DistributedAlgorithms/1.png]]

        Each of the users \(U_i\), \(1\le i\le n\), is modelled as a state machine (formally, an *I/O
        automaton*) that communicates with its agent process using the \(try_i\), \(crit_i\), \(exit_i\) and
        \(rem_i\) actions:
        #+ATTR_LATEX: :width .2\textwidth :float nil
        #+NAME: 10.3
        #+CAPTION: External interface of user \(U_i\)
        [[../images/DistributedAlgorithms/2.png]]

        We define a sequence of \(try_i\), \(crit_i\), \(exit_i\) and \(rem_i\) actions to be *well-formed* for
        user \(i\) if it is a prefix of the cyclically ordered sequence
        \(try_i,crit_i,exit_i,rem_i,try_i,\dots\). Then we require that \(U_i\) *preserve* the *trace property*
        defined by the set of sequences that are well-ordered for user \(i\).
* Q&A
        1. [[P1]]. Need think.
