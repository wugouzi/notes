#+title: Distributed Algorithms

#+AUTHOR: Nancy Lynch
#+EXPORT_FILE_NAME: ../latex/DistributedAlgorithms/DistributedAlgorithms.tex
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \makeindex
#+LATEX_HEADER: \SetKw{KwShared}{Shared variables:}
#+LATEX_HEADER: \SetKw{KwProcess}{Process $i$:\\}
#+LATEX_HEADER: \SetKwData{KwRem}{\ruleline{Remainder region}\\}
#+LATEX_HEADER: \SetKwData{KwCrit}{\ruleline{Critical region}\\}
#+LATEX_HEADER: \SetKwData{KwTry}{\ruleline{Trying region}\\}
#+LATEX_HEADER: \SetKwData{KwExit}{\ruleline{Exit region}\\}
#+LATEX_HEADER: \SetKw{KwGoTo}{go to}
#+STARTUP: shrink
* Modelling \rom{2}: Asynchronous System Model
** I/O Automata
        A *signature* \(S\) is a triple consisting of three disjoint sets of actions: the *input actions*,
        \(in(S)\), the *output actions*, \(out(S)\), and the *internal actions*, \(int(S)\). We define the
        *external actions*, \(ext(S)\), to be \(in(S)\cup out(S)\); and *locally controlled actions*, \(local(S)\)
        to be \(out(S)\cup int(S)\); and \(acts(S)\) to be all the actions of \(S\). The *external signature*,
        \(extsig(S)\), is defined to be the signature \((in(S),out(S),\emptyset)\).

        An *I/O automaton* \(A\), which we also call simply an *automaton*, consists of five components:
        * \(sig(A)\), a signature
        * \(states(A)\)
        * \(start(A)\), a nonempty subset of \(states(A)\) known as the *start states* or *initial states*
        * \(trans(A)\), a *state-transition relation* where \(trans(A)\subseteq states(A)\times
          acts(sig(A))\times states(A)\).
        * \(tasks(A)\), a *task partition*, which is an equivalence relation on \(local(sig(A))\) having at most
          countably many equivalence classes

        We use \(acts(A)\) as shorthand for \(acts(sig(A))\), and similarly \(in(A)\), and so on.

        We call an element \((s,\pi,s')\) of \(trans(A)\) a *transition*, or *step*, of \(A\). The transition
        \((s,\pi,s')\) is called  an *input transition*, *output transition*, and so on, based on whether the
        action \(\pi\) is an input action, output action, and so on.

        If for a particular state \(s\) and action \(\pi\), \(A\) has some transition of the form
        \((s,\pi,s')\), then we say that \(\pi\) is *enabled* in \(s\). Since every input action is required to
        be enabled in every state, automata are said to be *input-enabled*. We say that state \(s\) is *quiescent*
        if the only actions that are enabled in s are input actions.

        A task \(C\) is *enabled* in a state \(s\) means somes action in \(C\) is enabled in \(s\).

        #+ATTR_LATEX: :options [Channel I/O automaton]
        #+BEGIN_examplle
        [[label:8.1.1]]
        Consider a communication channel automaton \(C_{i,j}\). Let \(M\) be a fixed message alphabet.
        * *Signature*:
          \begin{alignat*}{2}
          &\text{Input}:\hspace{3cm}&&\text{Output:}\\
          &\quad send(m)_{i,j},m\in M&&\quad receive(m)_{i,j},m\in M
          \end{alignat*}
        * *States*: \(queue\), a FIFO queue of elements of \(M\), initially empty
        * *Transitions*:
          \begin{alignat*}{2}
          &send(m)_{i,j}\hspace{3cm}&&receive(m)_{i,j}\\
          &\quad\text{Effect:}&&\quad\text{Precondition:}\\
          &\quad\quad\text{add }m\text{ to }queue&&\quad\quad m\text{ is first on }queue\\
          &&&\quad\text{Effect:}\\
          &&&\quad\quad\text{remove first element of }queue
          \end{alignat*}
        * *Tasks*: \(\{receive(m)_{i,j}:m\in M\}\)
        #+END_examplle

        #+ATTR_LATEX: :options [Process I/O automata]
        #+BEGIN_examplle
        [[label:8.1.2]]

        Consider a process automaton \(P_i\). \(V\) is a fixed value set, \(null\) is a special value not in \(V\), \(f\) is a fixed function,
        \(f:V^n\to V\)
        * *Signature*:
          * Input:
            * \(init(v)_i,v\in V\)
            * \(receive(v)_{j,i}\), \(v\in V\), \(1\le j\le n\), \(j\neq i\)
          * Output:
            * \(decide(v)_i\), \(v\in V\)
            * \(send(v)_{i,j}\), \(v\in V\), \(1\le j\le n\), \(j\neq i\)
        * *States*: \(val\), a vector indexed by \(\{1,\dots,n\}\) of elements in \(V\cup\{null\}\), all
          initially \(null\)
        * *Transitions*:
          \begin{alignat*}{2}
          &init(v)_i,v\in V\hspace{2cm}&&receive(v)_{j,i},v\in V\\
          &\quad\text{Effect:}&&\quad\text{Effect:}\\
          &\quad\quad val(i):=v&&\quad\quad val(j):=v\\\\
          &send(v)_{i,j}, v\in V&&decide(v)_i,v\in V\\
          &\quad\text{Precondition:}&&\quad\text{Precondition:}\\
          &\quad\quad val(i)=v&&\quad\quad\text{for all }j, 1\le j\le n:\\
          &\quad\text{Effect:}&&\quad\quad\quad val(j)\neq null\\
          &\quad\quad\quad\text{none}&&\quad\quad v=f(val(1),\dots,val(n))\\
          &&&\quad\text{Effect:}\\
          &&&\quad\quad\text{none}
          \end{alignat*}
        * *Tasks*: for every \(j\neq i\): \(\{send(v)_{i,j}:v\in V\}\), \(\{decide(v)_i:v\in V\}\).

        [[index:execution]]
        An *execution fragment* of \(A\) is either a finite sequence \(s_0,\pi_1,s_1,\pi_2,\dots,\pi_r,s_r\) or
        an infinite sequence \(s_0,\pi_1,s_1,\pi_2,\dots\), of alternating states and actions of \(A\) s.t.
        \((s_k,\pi_{k+1},s_{k+1})\) is a transition of \(A\) for every \(k\ge 0\). An execution fragment
        beginning with a start state is called an *execution*. We denote the set of executions of \(A\) by
        \(execs(A)\). A state is *reachable* if it is the final state of a finite execution of \(A\).

        If \(\alpha\) is a finite execution fragment of \(A\) and \(\alpha'\) is any execution fragment of
        \(A\) that begins with the last state of \(\alpha\), then we write \(\alpha\cdot\alpha'\) to represent
        the sequence obtained by concatenating \(\alpha\) and \(\alpha'\), eliminating the duplicate
        occurrence of the last state of \(\alpha\).
        #+END_examplle


        [[index:trace]]
        The *trace* of an execution \(\alpha\) of \(A\), denoted by \(trace(\alpha)\), is the subsequence of
        \(\alpha\) consisting of all the external actions. We say that \(\beta\) is a *trace* of \(A\)  if
        \(\beta\) is the trace of an execution of \(A\). We denote the set of traces of \(A\) by
        \(traces(A)\).

        #+ATTR_LATEX: :options [Executions]
        #+BEGIN_examplle
        [[label:8.1.3]]

        The following are three executions of the automaton \(C_{i,j}\) described in Example ref:8.1.1
        (assuming that the message alphabet \(M\) is equal to the set \(\{1,2\}\)). Here we indicate the
        states by putting the sequences in /queue/ in brackets; \(\lambda\) denotes the empty sequence.

        \begin{align*}
        &[\lambda],send(1)_{i,j},[1],receive(1)_{i,j},[\lambda],send(2)_{i,j},[2],receive(2)_{i,j},[\lambda]\\
        &[\lambda],send(1)_{i,j},[1],receive(1)_{i,j},[\lambda],send(2)_{i,j},[2]\\
        &[\lambda],send(1)_{i,j},[1],send(1)_{i,j},[11],send(1)_{i,j},[111],\dots
        \end{align*}
        #+END_examplle
** Operations on Automata
*** Composition
        The composition identifies actions with the same name in different component automata. When any
        component automaton performs a step involving \(\pi\), so do all component automata that have \(\pi\)
        in their signatures.

        We impose certain restrictions on the automata that may be composed.
        1. Since internal actions of an automaton \(A\) are intended to be unobservable by any other automaton
           \(B\), we do not allow \(A\) to be composed with \(B\) unless the internal actions of A are
           disjoint from the actions of B.

           Otherwise, A's performance of an internal action could force B to take a step.
        2. In order that the composition operation might satisfy nice properties, we establish a convention
           that at most one component automaton "controls" the performance of any given action; that is, we do
           not allow \(A\) and \(B\) to be composed unless the sets of output actions of A and B are disjoint.
        3. We do not preclude the possibility of composing a countably infinite collection of automata, but we
           do require in this case that each action must be an action of only finitely many of the component automata.

        A countable collection \(\{S_i\}_{i\in I}\) of signatures to be *compatible* if for all \(i,j\in I\),
        \(i\neq j\), all of the following hold:
        1. \(int(S_i)\cap acts(S_j)=\emptyset\)
        2. \(out(S_i)\cap out(S_j)=\emptyset\)
        3. No action is contained in infinitely many sets \(acts(S_i)\)
        We say that a collection of automata is *compatible* if their signatures are compatible.

        The *composition* \(S=\prod_{i\in I}S_i\) of a countable compatible collection of signatures
        \(\{S_i\}_{i\in I}\) is defined to be the signature with
        * \(out(S)=\bigcup_{i\in I}out(S_i)\)
        * \(int(S)=\bigcup_{i\in I}int(S_i)\)
        * \(in(S)=\bigcup_{i\in I}in(S_i)-\bigcup_{i\in I}out(S_i)\)

        Now the *composition* \(A=\prod_{i\in I}A_i\) of a countable, compatible collection of I/O automata
        \(\{A_i\}_{i\in I}\) can be defined. It is the automaton defined as:
        * \(sig(A)=\prod_{i\in I}sig(A_i)\)
        * \(states(A)=\prod_{i\in I}states(A_i)\)
        * \(start(A)=\prod_{i\in I}start(A_i)\)
        * \(trans(A)\) is the set of triples \((s,\pi,s')\) s.t., for all \(i\in I\), if \(\pi\in acts(A_i)\),
          then \((s_i,\pi,s_i')\in trans(A_i)\); otherwise \(s_i=s_i'\).
        * \(tasks(A)=\bigcup_{i\in I}tasks(A_i)\)


        Note that an action \(\pi\) that is an output of one component and an input of another is classified
        as an output action in the composition, not as an internal action. This is because we want to permit
        the possibility of further communication using \(\pi\).

        #+ATTR_LATEX: :options [Composition of automata]
        #+BEGIN_examplle
        [[label:8.2.1]]
        Consider a fixed index set \(I=\{1,\dots,n\}\) and let \(A\) be the composition of all the process
        automata \(P_i\), \(i\in I\) from Example [[ref:8.1.2]]. In order to compose them, we must assume that the
        message alphabet \(M\) for the channel automata contains the value set \(V\) for the process automata.
        #+ATTR_LATEX: :width .8\textwidth :float nil
        #+NAME: 8.3
        #+CAPTION: Composition of \(P_i\)s and \(C_{i,j}\)s
        [[../images/DistributedAlgorithms/3.png]]

        1. An \(init(v)_i\) input action, which deposits a value in \(P_i\)'s \(val(i)\) variable, \(val(i)_i\).
        2. A \(send(v)_{i,j}\) output action, by which \(P_i\)'s value \(val(i)_i\) gets put into channel \(C_{i,j}\).
        3. A \(receive(v)_{i,j}\) output action, by which the first message in \(C_{i,j}\) is removed and
           simultaneously placed into \(P_j\)'s variable \(val(i)_j\).
        4. A \(decide(v)_i\) output action, by which \(P_i\) announcs its current computed value.

        #+END_examplle

        Given an execution \(\alpha=s_0,\pi_1,s_1,\dots\), of \(A\), let \(\alpha|A_i\) be the sequence
        obtained by deleting each pair \(pi_r,s_r\) for which \(\pi_r\) is not an action of \(A_i\) and
        replacing each remaining \(s_r\) by \((s_r)_i\).

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.1]]
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        1. If \(\alpha\in execs(A)\), then \(\alpha|A_i\in execs(A_i)\) for every \(i\in I\).
        2. If \(\beta\in traces(A)\), then \(\beta|A_i\in traces(A_i)\) for every \(i\in I\).
        #+END_theorem

        #+BEGIN_proof
        1. Execution of any automaton \(A_j\) where \(j\neq i\) doesn't affect automaton \(A_i\).
        2. Immediately
        #+END_proof

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.2]]
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\alpha_i\) is an execution of \(A_i\) for every \(i\in I\), and suppose \(\beta\) is a
        sequence of actions in \(ext(A)\) s.t. \(\beta|A_i=traces(\alpha_i)\) for every \(i\in I\). Then there
        is an execution \(\alpha\) of \(A\) s.t. \(\beta=trace(\alpha)\) and \(\alpha_i=\alpha|A_i\) for every
        \(i\in I\).
        #+END_theorem


        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.3]]
        Let \(\{A_i\}_{i\in I}\)  be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\beta\) is a sequence of actions in \(ext(A)\). If \(\beta|A_i\in traces(A_i)\) for every
        \(i\in I\), then \(\beta\in traces(A)\).
        #+END_theorem
*** Hiding
        If \(S\) is a signature and \(\Phi\subset out(S)\), then \(hide_\phi(S)\) is defined to be the new
        signature \(S'\), where \(in(S')=in(S)\), \(out(S')=out(S)-\Phi\) and \(int(S')=int(S)\cup\Phi\).

        If \(A\) is an automaton and \(\Phi\subseteq out(A)\), then \(hide_\Phi(A)\) is the automaton \(A'\)
        obtained from \(A\) by replacing \(sig(A)\) with \(sig(A')=hide_\Phi(sig(A))\).
*** Fairness
        [[index:fair]]
        An execution fragment \(\alpha\) of an I/O automaton \(A\) is said to be *fair* if the following
        conditions hold for each class \(C\) of \(tasks(A)\):
        1. If \(\alpha\) is finite, then \(C\) is not enabled in the final state of \(\alpha\)
        2. If \(\alpha\) is infinite, then \(\alpha\) contains either infinitely many events from \(C\) or
           infinitely many occurrences of states in which \(C\) is not enabled.

        We use the term *event* to denote the occurrence of an action in a sequence.

        * We can understand the definition of fairness as saying that infinitely often, each task \(C\) is
          given a turn. Whenever this happens, either an action of \(C\) gets performed or no action from
          \(C\) could possibly be performed since no such action is enabled.
        * We can think of a finite fair execution as an execution at the end of which the automaton
          repeatedly gives turns to all the tasks in round-robin order, but never succeeds in performing any
          action since none are enabled in the final state. <<P1>>

        We denote the set of fair executions of \(A\) by \(fairexecs(A)\). We say that \(\beta\) is a *fair
        trace* of \(A\) if \(\beta\) is the trace of a fair execution of \(A\), and we denote the set of fair
        traces of \(A\) by \(fairtraces(A)\).

        #+ATTR_LATEX: :options [Fairness]
        #+BEGIN_examplle
        In Example [[ref:8.1.3]], the first execution given is fair, because no \(receive\) action is enabled in
        its final state. The second is not fair, because it is finite and a \(receive\) action is enabled in
        the final state. The third is not fair, because it is infinite, contains no \(receive\) events, and
        has \(receive\) actions enabled at every point after the first step.
        #+END_examplle

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.4]]
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        1. If \(\alpha\in fairexecs(A)\), then \(\alpha|A_i\in fairexecs(A_i)\) for every \(i\in I\).
        2. If \(\beta\in fairtraces(A)\), then \(\beta|A_i\in fairtraces(A_i)\) for every \(i\in I\).
        #+END_theorem

        #+BEGIN_proof
        1. If \(\alpha\in fairexecs(A)\).
           * If \(\alpha\) is finite, then for each task \(C\), \(C\) is not enabled in the final state of
             \(\alpha\), therefore each \(C|A_i\) is not enabled in the final state of \(\alpha|A_i\) too.
           * If \(\alpha\) is infinite, then blabla
           Therefore \(\alpha|A_i\in fairexecs(A_i)\)
        2. same
        #+END_proof

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.5]]
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\alpha_i\) is a fair execution of \(A_i\) for every \(i\in I\), and suppose \(\beta\) is a
        sequence of actions in \(ext(A)\) s.t. \(\beta|A_i=trace(\alpha_i)\) for every \(i\in I\). Then there
        is a fair execution \(\alpha\) of \(A\) s.t. \(\beta=trace(\alpha)\) and \(\alpha_i=\alpha|A_i\) for
        every \(i\in I\).
        #+END_theorem

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        [[label:8.6]]
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\).
        Suppose \(\beta\) is a sequence of actions in \(ext(A)\). If \(\beta|A_i\in fairexecs(A_i)\)  for
        every \(i\in I\), then \(\beta\in fairexecs(A)\).
        #+END_theorem

        #+ATTR_LATEX: :options [Fairness]
        #+BEGIN_examplle
        Consider the fair executions of the system of three processes and three channels in Example ref:8.2.1.
        In every fair execution, every message that is sent is eventually received.

        In every fair execution containing least one \(init_i\) event for each \(i\), each process sends
        infinitely many messages to each other processes and each process performs infinitely many \(decide\) steps

        In every fair execution that does not contain at least one \(init\) event for each process, no process
        ever performs a \(decide\) step.
        #+END_examplle

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(A\) be any I/O automaton.
        1. If \(\alpha\) is a finite execution of \(A\), then there is a fair execution of \(A\) that starts
           with \(\alpha\).
        2. If \(\beta\) is a finite trace of \(A\), then there is a fair trace of \(A\) that starts with \(\beta\).
        3. If \(\alpha\) is a finite execution of \(A\) and \(\beta\) is any sequence of input actions of
           \(A\), then there is a fair execution \(\alpha\cdot\alpha'\) of \(A\) s.t. the sequence of input
           actions in \(\alpha'\) is exactly \(\beta\)
        4. If \(\beta\) is a finite trace of \(A\) and \(\beta'\) is any sequence of input actions of \(A\),
           then there is a fair execution \(\alpha\cdot\alpha'\) of \(A\) s.t. \(trace(\alpha)=\beta\) and
           s.t. the sequence of input actions in \(\alpha'\) is exactly \(\beta'\)
        #+END_theorem
** Inputs and Outputs for Problems
** Properties and Proof Methods
*** Invariant Assertions
*** Trace Properties
        A *trace property* \(P\) consists of the following:
        * \(sig(P)\), a signature containing no internal actions
        * \(traces(P)\), a set of (finite or infinite) sequences of actions in \(acts(sig(P))\)

        That is, a trace property specifies both an external interface and a set (in other words, a property)
        of sequences observed at that interface. We write \(acts(P)\) as shorthand for \(acts(sig(P))\), and
        similarly \(in(P)\), and so on.

        The statement that an I/O automaton \(A\) satisfies a trace property \(P\) can be mean either of two
        different things:
        1. \(extsig(A)=sig(P)\) and \(traces(A)\subseteq traces(P)\)
        2. \(extsig(A)=sig(P)\) and \(fairtraces(A)\subseteq traces(P)\)
        The fact that \(A\) is input-enabled ensures that \(fairtraces(A)\) contains a response by \(A\) to
        each possible sequence of input actions. If \(fairtraces(A)\subseteq traces(P)\), then all of the
        resulting sequences must be included in the property \(P\).

        #+ATTR_LATEX: :options [Automata and trace properties]
        #+BEGIN_examplle
        Consider automata and trace properties with input set \(\{0\}\) and output set \(\{1,2\}\). First
        suppose that \(traces(P)\) is the set of sequences over \(\{0,1,2\}\) that include at least 1. Then
        \(fairtraces(A)\subseteq traces(P)\) means that in every fair execution, \(A\) must output at least
        one.

        It is easy to design an I/O automaton for which this is the case - for example, it can include a task
        whose entire job is to output 1. The fairness condition is used to ensure that this task actually does
        get a change to output 1. On the other hand, there does not exist any automaton \(A\) for which
        \(traces(A)\subseteq traces(P)\), because \(traces(A)\) always includes the empty string \(\lambda\),
        which does not contain a 1.

        Now suppose that \(traces(P)\) is the set of sequences over \(\{0,1,2\}\) that include at least one 0.
        In this case, there is no I/O automaton \(A\) for which \(fairtraces(A)\subseteq traces(P)\), because
        \(fairtraces(A)\) must contain some sequence that includes no inputs.
        #+END_examplle

        A countable collection \(\{P_i\}_{i\in I}\) of trace properties is *compatible* if their signatures are
        compatible. Then the *composition* \(P=\prod_{i\in I}P_i\) is the trace property s.t.
        * \(sig(P)=\prod_{i\in I}sig(P_i)\).
        * \(traces(P)\) is the set of sequences \(\beta\) of external actions of \(P\) s..t
          \(\beta|acts(P_i)\in traces(P_i)\) for all \(i\in I\).
*** Safety and Liveness Properties
        #+ATTR_LATEX: :options []
        #+BEGIN_definition
        A trace property \(P\) is a *trace safety property*, or a *safety property* for short, provided that \(P\)
        satisfies the following conditions:
        1. \(traces(P)\) is nonempty
        2. \(traces(P)\) is *prefix-closed*, that is, if \(\beta\in traces(P)\) and \(\beta'\) is a finite
           prefix of \(\beta\), then \(\beta'\in traces(P)\)
        3. \(traces(P)\) is *limit-closed*, that is, if \(\beta_1,\beta_2,\dots\) is an infinite sequence of
           finite sequences in \(traces(P)\), and for each \(i\), \(\beta_i\) is a prefix of \(\beta_{i+1}\),
           then \(\beta=\bigcup_{i\in\omega}\beta_i\in traces(P)\).
        #+END_definition

        #+ATTR_LATEX: :options [Trace safety property]
        #+BEGIN_examplle
        Suppose \(sig(P)\) consists of inputs \(init(v)\), \(v\in V\) and outputs \(decide(v)\), \(v\in V\).
        Suppose \(traces(P)\) is the set of sequences of \(init\) and \(decide\) actions in which no
        \(decide(v)\) occurs without a preceding \(init(v)\) (for the same \(v\)). Then \(P\) is a safety property.
        #+END_examplle

        #+ATTR_LATEX: :options []
        #+BEGIN_proposition
        If \(P\) is a safe property, TFAE:
        1. \(traces(A)\subseteq traces(P)\)
        2. \(fairtraces(A)\subseteq traces(P)\)
        3. finite traces of \(A\) are all in traces \(P\).
        #+END_proposition

        #+BEGIN_proof
        \((2\Rightarrow(3)\): For any finite trace \(\beta\in traces(A)\), there is
        \(\beta'\in fairtraces(A)\)  that starts in \(\beta\). Thus \(\beta\in traces(P)\) because of
        prefix-closedness.

        \((3)\Rightarrow(1)\): For any infinite trace \(\beta\in traces(A)\), we can have such a infinite
        sequence of traces \(\beta_1,\beta_2,\dots\) of \(A\), where \(\beta_i\) is a prefix of
        \(\beta_{i+1}\) for any \(i\), and \(\beta=\bigcup_{i\in\omega}\beta_i\). Therefore
        \(\beta\in traces(P)\) because of limit-closedness.
        #+END_proof

        #+ATTR_LATEX: :options []
        #+BEGIN_definition
        A trace property \(P\) is a *trace liveness property*, or a *liveness property* for short, provided that
        every finite sequence over \(acts(P)\) has some extension in \(traces(P)\).
        #+END_definition

        #+ATTR_LATEX: :options []
        #+BEGIN_examplle
        Suppose \(sig(P)\) consists of input \(init(v)\), \(v\in V\) and outputs \(decide(v)\), \(v\in V\).
        Suppose \(traces(P)\) is the set of sequences \(\beta\) of \(init\) and \(decide\) actions in which,
        for every \(init\) event in \(\beta\), there is some \(decide\) event occuring later in \(\beta\).
        Then \(P\)  is a liveness property.
        #+END_examplle

        Often one wants to prove that \(fairtraces(A)\subseteq traces(P)\) for some automaton \(A\) and
        liveness property \(P\). Methods based on *temporal logic* work well in practice for proving such
        claims. Another method for proving liveness claims, which we call the *progress function method*, is
        specially designed for proving that some particular goal is eventually reached.

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        If \(P\) is both a safety property and a liveness property, then \(P\) is the set of all (finite and
        infinite) sequence of actions in \(acts(P)\).
        #+END_theorem

        #+BEGIN_proof
        Suppose that \(P\) is both a safety and a liveness property and let \(\beta\) be an arbitrary sequence
        of elements of \(acts(P)\). If \(\beta\) is finite, then since \(P\) is a liveness property, \(\beta\)
        has some extension \(\beta'\) in \(traces(P)\). Then since \(P\) is a safety property, \(\beta\in
        traces(P)\).

        If \(\beta\) is infinite, then for each \(i\ge 1\), define \(\beta_i\) to be the length \(i\) prefix
        of \(\beta\). Then \(\beta\in traces(P)\).
        #+END_proof

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        If \(P\) is an arbitrary trace property with \(traces(P)\neq\emptyset\), then there exist a safety
        property \(S\) and a liveness property \(L\) s.t.
        1. \(sig(S)=sig(L)=sig(P)\).
        2. \(traces(P)=traces(S)\cap traces(L)\)
        #+END_theorem

        #+BEGIN_proof
        Let \(traces(S)\) be the prefix- and limit-closure of \(traces(P)\). Let
        \begin{align*}
        traces(L)=&traces(P)\\
        &\cup\{\beta:\beta\text{ is a finite sequence and no extension of $\beta$ is in }traces(P)\}
        \end{align*}
        #+BEGIN_claim
        \(L\) is a liveness property
        #+END_claim
        Now \(traces(P)\subseteq traces(S)\cap traces(L)\). If there is \(\beta\in traces(S)\cap
        traces(L)\setminus traces(P)\),
        then \(\beta\) is a finite sequence and no extension of \(\beta\) is in \(traces(P)\). <<P2>>
        #+END_proof
*** Compositional Reasoning
        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        label:8.10
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\). Let
        \(\{P_i\}_{i\in I}\) be a (compatible) collection of trace properties and let \(P=\prod_{i\in I}P_i\)
        1. If \(extsig(A_i)=sig(P_i)\) and \(traces(A_i)\subseteq traces(P_i)\) for every \(i\), then
           \(extsig(A)=sig(P)\) and \(traces(A)\subseteq traces(P)\).
        2. If \(extsig(A_i)=sig(P_i)\) and \(fairtraces(A_i)\subseteq traces(P_i)\) for every \(i\), then
           \(extsig(A)=sig(P)\) and \(fairtraces(A)\subseteq traces(P)\).
        #+END_theorem

        #+BEGIN_proof
        1. If \(\beta\in traces(A)\), then by Theorem ref:8.1,
           \(\beta|A_i\in traces(A_i)\subseteq traces(P_i)\) for every \(i\in I\). Then by Theorem ref:8.3,
           \(\beta\in traces(P)\).
        2.
           
        #+END_proof

        #+ATTR_LATEX: :options [Satisfying a product trace property]
        #+BEGIN_examplle
        Consider the composed system of Example ref:8.2.1. Each process automaton \(P_i\) satisfies a trace
        safety property that asserts that any \(decide_i\) event has a preceding \(init_i\) event. Also, each
        channel automaton \(C_{i,j}\)  satisfies a trace safety property that asserts taht the sequence of
        messages in \(receive_{i,j}\) events is a prefix of athe sequence of messages in \(send_{i,j}\)
        events.

        Then it follows from Theorem ref:8.10 that the composed system satisfies the product trace safety
        property. This means that in an trace of the combined system, the following hold:
        1. For every \(i\), any \(decide_i\) event has a preceding \(init_i\) event
        2. For every \(i\) and \(j\), \(i\neq j\), the sequence of messages in \(receive_{i,j}\) events is a
           prefix of the sequence of messages in \(send_{i,j}\) events.
        #+END_examplle

        Second, suppose that we want to show that a particular sequence of actions is a trace of a composed
        system \(A=\prod_{i\in I}A_i\).  Theorem ref:8.3 shows that it is enough to show taht the projection
        of the sequence on each of the system components is a trace of that component. Theorem ref:8.6 implies
        an analogous result for fair traces.

        Third, consider the compositional proof of safety properties. Suppose we want to show that a composed
        system \(A=\prod_{i\in I}A_i\) satisfies a safety property \(P\). One strategy is to show that none of
        the components \(A_i\) is the first to violate \(P\).

        Let \(A\) be an I/O automaton and let \(P\) be a safety property with \(acts(P)\cap int(A)=\emptyset\)
        and \(in(P)\cap out(A)=\emptyset\). We say that \(A\) *preserves* \(P\) if for every finite sequence
        \(\beta\) of actions that does not include any internal actions of \(A\), and every \(\pi\in out(A)\),
        the following holds: If \(\beta|acts(P)\in traces(P)\) and \(\beta\pi|A\in traces(A)\), then
        \(\beta\pi|acts(P)\in traces(P)\). This says that \(A\) is not the first to violate \(P\), as long as
        \(A\)'s environment only provides inputs to \(A\) in such a way that the cumulative behaviour
        satisfies \(P\), then \(A\) will only perform outputs s.t. the cumulative behaviour satisfies \(P\).

        The key fact about preservation of safety properties is that if all the components in a composed
        system preserve a safety property, then so does the entire system. Moreover, if the composed system is
        closed, then it actually satisfies the safety property.

        #+ATTR_LATEX: :options []
        #+BEGIN_theorem
        Let \(\{A_i\}_{i\in I}\) be a compatible collection of automata and let \(A=\prod_{i\in I}A_i\). Let
        \(P\) be a safety property with \(acts(P)\cap int(A)=\emptyset\) and \(in(P)\cap out(A)=\emptyset\).
        1. If \(A_i\) preserves \(P\) for every \(i\in I\), then \(A\) preserves \(P\)
        2. If \(A\) is a closed automaton, \(A\) preserves \(P\), and \(acts(P)\subseteq ext(A)\), then
           \(traces(A)|acts(P)\subseteq traces(P)\)
        3. If \(A\) is a closed automaton, \(A\) preserves \(P\), and \(acts(P)=ext(A)\), then
           \(traces(A)\subseteq traces(P)\).
        #+END_theorem
*** Hierarchical Proofs
** Complexity Measures
* Modelling \rom{3}: Asynchronous Shared Memory Model
** Shared Memory Systems
        We mode lthe entire system as one big I/O automaton \(A\).

        As in the synchronous network model, we assume that the processes in the system are indexed by
        \(1,\dots,n\). Suppose that each process \(i\) has an associated set of *states*, \(states_i\), among
        which some are designated as *start states*, \(start_i\). Also suppose that each shared variable \(x\)
        in the system has an associated set of *values*, \(values_x\), among which some are designated as the
        *initial values*, \(initial_x\). Then each state in \(states(A)\) (the set of states of the system
        automaton \(A\)) consists of a state in \(states_i\) for each process \(i\), plus a value in
        \(values_x\) for each shared variable \(x\). Each state in \(start(A)\) consists of a state in
        \(start_i\) for each process \(i\), plus a value in \(initial_x\) for each shared variable \(x\).

        We assume that each action in \(acts(A)\) is associated with one of the processes. In addition, some
        of the internal actions in \(int(A)\) may be associated with a shared variable. The input actions and
        output actions associated with process \(i\) are used for interaction between process \(i\) and the
        outside world; we say they occur on *port* \(i\). The internal actions of process \(i\) that do not have
        an associated shared variable are used for local computation, while the internal actions of \(i\) that
        are associated with shared variable \(x\) are used for performing operations on \(x\).

        The set \(trans(A)\) of transitions has some locality restrictions, which model the process and shared
        variable structure of the system.
        1. Consider an action \(\pi\) that is associated with process \(i\) but with no variable; as we noted
           above, \(\pi\) is used for local computation. Then only the state of \(i\) can be involved in any
           \(\pi\) step. That is, the set of \(\pi\) transitions can be generated from some set of triples of
           the form \((s,\pi,s')\), where \(s,s'\in states_i\), by attaching any combination of states for the
           other processes and values for the shared variables to both \(s\) and \(s'\) 
        2. Consider an action \(\pi\) that is associated with both a process \(i\) and a variable \(x\);
           \(\pi\) is used by \(i\) to perform an operation on \(x\). The set of \(\pi\) transitions can be
           generated from some set of triples of the form \((s,v),\pi,(s',v')\), where \(s,s'\in states_i\)
           and \(v,v'\in values_x\), by attaching any combination of states for the other processes and values
           for the other shared variables. There is a _technicality_: if \(\pi\) is associated with process
           \(i\) and variable \(x\), then whether or not \(\pi\) is enabled should depend only on the state of
           process \(i\)

        The task partitioon \(tasks(A)\) must be consistent with the process structure: that is, each
        equivalence class (task) should include locally controlled actions of only one process.

        #+ATTR_LATEX: :options [Shared memory system]
        #+BEGIN_examplle
        Let \(V\) be a fixed value set. Consider a shared memory system \(A\) consisting of \(n\) processes,
        numbered \(1,\dots,n\), and a single shared variable \(x\) with values in \(V\cup\{unknown\}\),
        initially \(unknown\). The inputs are of the form \(init(v)_i\), where \(v\in V\) and \(i\) is a
        process index. The outputs are of the form \(decide(v)_i\), The internal actions are of the form
        \(access_i\). All the actions with subscript \(i\) are associated with process \(i\), and in addition,
        the \(access\) actions are associated with variable \(x\).

        After process \(i\) receives an \(init(v)_i\) input, it accesses \(x\). If it finds \(x=unknown\),
        then it writes its value \(v\) into \(x\) and decides \(v\). If it finds \(x=w\), where \(w\in V\),
        then it does not write anything into \(x\), but decides \(w\).

        Formally:

        *States of \(i\)*:
        \begin{align*}
        &status\in\{idle,access,decide,done\}, \text{ initially } idle\\
        &input\in V\cup\{unknown\},  \text{ initially } unknown\\
        &output\in V\cup\{unknown\}, \text{ initially } unknown
        \end{align*}
        *Transitions of \(i\)*:
        \begin{alignat*}{2}
        &init(v)_i\hspace{3.5cm}&&decide(v)_i\\
        &\quad\text{Effect:}&&\quad\text{Precondition:}\\
        &\quad\quad input:=v&&\quad\quad status=decide\\
        &\quad\quad\text{if }status=idle\text{ then}&&\quad\quad output=v\\
        &\quad\quad\quad status:=access&&\quad\text{Effect:}\\
        &&&\quad\quad status:=done\\
        &access_i\\
        &\quad\text{Precondition:}\\
        &\quad\quad status=access\\
        &\quad\text{Effect:}\\
        &\quad\quad\text{if }x=unknown\text{ then }x:=input\\
        &\quad\quad output:=x\\
        &\quad\quad status:=decide
        \end{alignat*}

        There is one task per process, which contains all the \(access\) and \(decide\) actions for that
        process.

        It is not hard to see that in every fair execution \(\alpha\) of \(A\), any process that receives an
        \(init\) input eventually performs a \(decide\) output. Moreover, every execution satisfies the
        "agreement property" that no two processes decide on different values, and the "validity property"
        that every decision value is the initial value of some process.
        #+END_examplle
* Mutual Exclusion
** Asynchronous Shared Memory Model
        The system is modelled as a collection of processes and shared variables,
        with interactions. Each process \(i\) is a kind of state machine, with a set statesi of states and a subset \(start\) of \(states_i\) indicating the
        start states, just as in the synchronous setting. However, now process \(i\) also has labelled
        \(actions\), describing the activities in which it participates. These are classified as either
        \(input\), \(output\), or \(internal\) actions. We further distinguish between two different kinds of
        internal actions: those that involve the shared memory and those that involve strictly local
        computation. If an action involves the shared memory, we assumethat it only involves one shared
        variable.

        There is a transition relation \(trans\) for the entire system, which is a set of \((s,\pi,s')\)
        triples, where \(s\) and \(s'\) are *automaton states*, that is, combinations of states for all the
        processes and values for all the shared variables, and where \(\pi\)  is the label of an input,
        output, or internal action. We call these combinations of process states and variable values
        "automaton states" because  the entire system is modelled as a single automaton. The statement that
        \((s,\pi,s')\in trans\) says that from automaton state \(s\) it is possible to go to automaton state
        \(s'\) as a result of performing action \(\pi\).

        We assume that input actions can always happen, that is, that the system is input-enabled. Formally,
        this means that for every automaton state \(s\) and input action \(\pi\), there exists \(s'\) such
        that \((s,\pi,s')\in trans\). In contrast, output and internal steps might be enabled only in a subset
        of the states. The intuition behind the input-enabling property is that the input actions are
        controlled by an arbitrary external user, while the internal and output actions are controlled by the
        system itself.


** The Problem
        The mutual exclusion problem involves the allocation of a single, indivisible, nonshareable resource
        among \(n\) *users*, \(U_1,\dots,U_n\).

        A user with access to the resource is modelled as being in a *critical region*, which is simply a
        designated subset of its states. When a user is not involved in any way with the resource, it is said
        to be in the *remainder region*. In order to gain admittance to its critical region, a user executes a
        *trying protocol*, and after it is done with the resource, it executes an (often trivial) *exit protocol*.
        This procedure can be repeated, so that each user follows a cycle, moving from its
        /remainder region/ (R) to its /trying region/ (T), then to its /critical region/ (C), then to its /exit
        region/ (E), and then back again to its remainder region.  

        #+ATTR_LATEX: :width .2\textwidth :float nil
        #+NAME: 10.2
        #+CAPTION: The cycle of regions of a single user
        [[../images/DistributedAlgorithms/1.png]]

        The inputs to process \(i\) are the \(try_i\) action, which models a request by user \(U_i\) for
        access to the resource, and the \(exit_i\) action, which models an annoucement by user \(U_i\) that it
        is done with the resource. The outputs of process \(i\) are \(crit_i\), which models the granting of
        the resource to \(U_i\) and \(rem_i\), which tells \(U_i\) that it can continue with the reset of its
        work. The \(try\), \(crit\), \(exit\), and \(rem\) actions are the only external actions of the shared
        memory system. The processes are responsible for performing the trying and exit protocols. Each
        process \(i\) acts as an "agent" on behalf of user \(U_i\).

        Each of the users \(U_i\), \(1\le i\le n\), is modelled as a state machine (formally, an *I/O
        automaton*) that communicates with its agent process using the \(try_i\), \(crit_i\), \(exit_i\) and
        \(rem_i\) actions:
        #+ATTR_LATEX: :width .2\textwidth :float nil
        #+NAME: 10.3
        #+CAPTION: External interface of user \(U_i\)
        [[../images/DistributedAlgorithms/2.png]]
        The only thing that we assume about \(U_i\) is that it obeys the cyclic region protocol.
        We define a sequence of \(try_i\), \(crit_i\), \(exit_i\) and \(rem_i\) actions to be *well-formed* for
        user \(i\) if it is a prefix of the cyclically ordered sequence
        \(try_i,crit_i,exit_i,rem_i,try_i,\dots\). Then we require that \(U_i\) *preserve* the *trace property*
        defined by the set of sequences that are well-ordered for user \(i\).

        In executions of \(U_i\) that do observe the cyclic order of actions, we say that \(U_i\) is
        * in its *remainder region* initially and in between any \(rem_i\) event and the following \(try_i\) event
        * in its *trying region* in between \(try_i\) event and the following \(crit_i\) event
        * in its *critical region* in between any \(crit_i\) event and the following \(exit_i\) event. During
          the time, \(U_i\) should be thought of as being free to use the resource
        * in its *exit region* in between any \(exit_i\) event and the following \(rem_i\) event


        #+ATTR_LATEX: :width .9\textwidth :float nil
        #+NAME: 10.4
        #+CAPTION: Interactions between components for the mutual exclusion problem
        [[../images/DistributedAlgorithms/4.png]]

        The combination of \(A\) and the users must satisfy the following conditions:
        * *Well-formedness*: In any execution, and for any \(i\), the subsequence describing the interactions
          between \(U_i\) and \(A\) is well-formed for \(i\).
        * *Mutual exclusion*: There is no reachable system state where more than one user is in the critical
          region \(C\)
        * *Progress*: At any point in a /fair execution/
          1. (Progress for the trying region) If at least one user is in \(T\) and no user is in \(C\), then
             at some later point some user enters \(C\)
          2. (Progress for the exit region) If at least one user is in \(E\), then at some later point some
             user enters \(R\).

        We say that a shared memory system \(A\) *solves the mutual exclusion problem* provided that it solves
        it for every collection of users.


        #+ATTR_LATEX: :options []
        #+BEGIN_lemma
        [[label:10.1]]
        Let \(A\) be an algorithm that solves the mutual exclusion problem. Let \(U_1,\dots,U_n\) be any
        particular collection of users, and let \(B\) be the combination of \(A\) and the given collection of
        users. Let \(s\) be a reachable state of \(B\).

        If process \(i\) is in its trying or exit region in state \(s\), then some locally controlled action
        of process \(i\) is enabled in \(s\).
        #+END_lemma

        #+BEGIN_proof
        WLOG, we may assume that each of the users always returns the resource.

        Let \(\alpha\) be a finite execution of \(B\) ending in \(s\), and assume that process \(i\) is in
        either its trying or exit region in state \(s\), and no locally controlled action of process \(i\) is
        enabled in \(s\). Then we claim that no events involving \(i\) occur in any execution of \(B\) that
        extends \(\alpha\), after the prefix \(\alpha\). This follows from the fact that enabling of locally
        controlled actions is determined only by the local process state, plus the fact that well-formedness
        prevents inputs to process \(i\) while process \(i\) is in \(T\) or \(E\).

        Now let \(\alpha'\) be a fair execution of \(B\) that extends \(\alpha\), in which no \(try\) events
        occur after the prefix \(\alpha\). Repeated use of the progress assumption, plus the fact that the
        users always return the resource, imply that process \(i\) must eventually perform either a \(crit_i\)
        or a \(rem_i\) action. But this contradicts the fact that \(\alpha'\) contains no further actions of \(i\).
        #+END_proof

** Dijkstra's Mutual Exclusion Algorithm
*** The Algorithm
        \begin{algorithm}
        \caption{DijkstraME algorithm}
        \KwShared{\\\quad\(turn\in\{1,\dots,n\}\), initally arbitrary, writable and readable by all processes\\
                for every \(i\), \(1\le i\le n\):\\
                \quad\(flag(i)\in\{0,1,2\}\), initially 0, writable by process \(i\) and readable by all processes}\;
        \KwProcess
        \KwRem
        \(try_i\)\;
        \nlset{L}\label{zzzL}\(flag(i):=1\)\;
        \While{\(turn\neq i\)}{
                \uIf{\(flag(turn)=0\)}{\(turn:=i\)\;}
        }
        \(flag(i):=2\)\;
        \For{\(j\neq i\)}{
                \uIf{\(flag(j)=2\)}{\KwGoTo \ref{zzzL}\;}
        }
        \(crit_i\)\;
        \KwCrit
        \(exit_i\)\;
        \(flag(i):=0\)\;
        \(rem_i\)\;
        \end{algorithm}
* Q&A
        1. [[P1]]. Need think.
        2. [[P2]]
