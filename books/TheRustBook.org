#+title: The Rust Book

#+AUTHOR: NONE

#+EXPORT_FILE_NAME: ../latex/TheRustBook/TheRustBook.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \setminted{fontsize=\footnotesize,baselinestretch=1}
#+LATEX_HEADER: \makeindex
#+LATEX_HEADER: \let\OldTexttt\texttt
#+LATEX_HEADER: \renewcommand{\texttt}[1]{\OldTexttt{\color{MidnightBlue} #1}}

* Programming a Guessing Game
    #+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
    #+end_src

    Result's variants are ~Ok~ and ~Err~. The ~Ok~ variant indicates the operation was successful, and
    inside ~Ok~ is the successfully generated value. The ~Err~ variant means the operation failed, and
    Err contains information about how or why the operation failed.

    An instance of ~Result~ has an expect method that you can call. If this instance of ~Result~ is an
    ~Err~ value, expect will cause the program to crash and display the message that you passed as an
    argument to expect.

    If the ~read_line~ method returns an ~Err~, it would likely be the result of an error coming from
    the underlying operating system. If this instance of ~Result~ is an ~Ok~ value, expect will take the
    return value that ~Ok~ is holding and return just that value to you so you can use it. In this
    case, that value is the number of bytes in the user’s input.

    If you don’t call ~expect~, the program will compile, but you’ll get a warning:

    The ~{}~ set of curly brackets is a placeholder.

    #+begin_src rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
    #+end_src

    A crate is a collection of Rust source code files. The project we’ve been building is a *binary
    crate*, which is an executable. The ~rand~ crate is a *library crate*, which contains code intended
    to be used in other programs and can't be executed on its own.

    When we include an external dependency, Cargo fetches the latest versions of everything that
    dependency needs from the ~registry~, which is a copy of data from [[https://crates.io/][Crates.io]]. Crates.io is where
    people in the Rust ecosystem post their open source Rust projects for others to use.

    Cargo has a mechanism that ensures you can rebuild the same artifact every time you or anyone
    else builds your code: Cargo will use only the versions of the dependencies you specified until
    you indicate otherwise.

    When you build a project for the first time, Cargo figures out all the versions of the
    dependencies that fit the criteria and then writes them to the ~Cargo.lock~ file. When you build
    your project in the future, Cargo will see that the ~Cargo.lock~ file exists and use the versions
    specified there rather than doing all the work of figuring out versions again. This lets you
    have a reproducible build automatically.

    When you do want to update a crate, Cargo provides the command ~update~, which will ignore the
    ~Cargo.lock~ file and figure out all the latest versions that fit your specifications in
    ~Cargo.toml~.

    #+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100);

    println!("The secret number is: {secret_number}");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
    #+end_src

    ~rand::thread_rng~ function gives us the particular random number generator that we’re going to
    use: one that is local to the current thread of execution and seeded by the operating system.
    Then we call the ~gen_range~ method on the random number generator. This method is defined by the
    ~Rng~ trait that we brought into scope with the ~use rand::Rng~ statement. The ~gen_range~ method takes
    a range expression as an argument and generates a random number in the range. The kind of range
    expression we’re using here takes the form ~start..=end~ and is inclusive on the lower and upper
    bounds, so we need to specify ~1..=100~ to request a number between 1 and 100.

    #+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {guess}");

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
    #+end_src

    A ~match~ expression is made up of *arms*. An arm consists of a *pattern* to match against, and the
    code that should be run if the value given to ~match~ fits that arm’s pattern.

     Unless otherwise specified, Rust defaults to an ~i32~.

     Ultimately, we want to convert the ~String~ the program reads as input into a real number type so
     we can compare it numerically to the secret number. We do so by adding this line to the ~main~
     function body:
     #+begin_src rust
let guess: u32 = guess.trim().parse().expect("Please type a number!");
     #+end_src

     We create a variable named ~guess~. But wait, doesn’t the program already have a variable named
     ~guess~? It does, but helpfully Rust allows us to *shadow* the previous value of ~guess~ with a new
     one. This feature is often used when you want to convert a value from one type to another type.

     The ~trim~ method on a ~String~ instance will eliminate any whitespace at the beginning and end,
     which we must do to be able to compare the string to the ~u32~, which can only contain numerical
     data. The user must press enter to satisfy ~read_line~ and input their guess, which adds a
     newline character to the string.

     The ~parse~ [[https://doc.rust-lang.org/std/primitive.str.html#method.parse][method]] on strings converts a string to another type. Here, we use it to convert from
     a string to a number. We need to tell Rust the exact number type we want by using ~let guess: u32~.
     The colon (~:~) after guess tells Rust we’ll annotate the variable’s type.

     The ~parse~ method will only work on characters that can logically be converted into numbers and
     so can easily cause errors. Because it might fail, the ~parse~ method returns a ~Result~ type, much
     as the ~read_line~ method does
