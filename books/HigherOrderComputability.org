#+TITLE: Higher Order Computability
#+AUTHOR: John Longley & Dag Normann

#+EXPORT_FILE_NAME: ../latex/HigherOrderComputability/HigherOrderComputability.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \newcommand{\ssmile}[1]{\mathord{\stackrel{\smallsmile}{#1}}}
#+LATEX_HEADER: \DeclareMathOperator{\lv}{lv}
#+LATEX_HEADER: \newcommand{\FF}{f\mspace{-7mu}f}
#+LATEX_HEADER: \newcommand{\TT}{t\mspace{-3mu}t}
#+LATEX_HEADER: \newcommand{\IF}{i\mspace{-4mu}f}
#+LATEX_HEADER: \DeclareMathOperator{\Asm}{\mathcal{A}sm}
#+LATEX_HEADER: \DeclareMathOperator{\nMod}{\mathcal{M}od}
#+LATEX_HEADER: \DeclareMathOperator{\PC}{\textsf{PC}}
#+LATEX_HEADER: \DeclareMathOperator{\PCF}{PCF}
#+LATEX_HEADER: \DeclareMathOperator{\eff}{eff}
#+LATEX_HEADER: \DeclareMathOperator{\tT}{T}
#+LATEX_HEADER: \makeindex

* COMMENT Introduction and Motivations

* COMMENT Historical Survey
* COMMENT Lecture 2
* COMMENT Lecture 1 - Introduction to recursion theory
    computability / complexity / definability aspects modulo relatively computability

    #+ATTR_LATEX: :options [Encoding/decoding pairs]
    #+BEGIN_examplle
    \begin{equation*}
    e(n,m)=
    \begin{cases}
    (m-1)^2+n&n<m\\
    n^2-(n-m)
    \end{cases}
    \end{equation*}
    (0,1)=1,(1,0)=2,
    bijection between \(\N\times\N\) and \(\N\)

    \(d_1(p)=\)
    #+END_examplle

    Gödel's recursive functions

    #+ATTR_LATEX: :options [Parameter theorem]
    #+BEGIN_theorem
    For any binary partial computable function \Theta there is an increasing computable \(q:\N\to\N\) s.t.
    \begin{equation*}
    \forall x\forall y\Phi_{q(x)}(y)=\Theta(x,y)
    \end{equation*}
    Moreover, a program compute \(q\) can be uniformly effectively obtained from a program that
    computes \Theta
    #+END_theorem

    #+ATTR_LATEX: :options [\(s\)-\(m\)-\(n\) theorem]
    #+BEGIN_theorem
    For any \(m,n\ge 1\), there is an 1-1 computable \(s:\N^{m+1}\to\N\) s.t. for
    any \(e\in\N\), \(\barx\in\N^m\) and \(\bary\in\N^n\), we have
    \begin{equation*}
    \Phi_{s(e,\barx)}(\bary)=\Phi_e(\barx,\bary)
    \end{equation*}
    #+END_theorem

    #+ATTR_LATEX: :options [Recursive theorem (fixed point theorem)]
    #+BEGIN_theorem
    For any computable function \(g:\N\to\N\) there is a fixed point \(e\) of \(g\)
    s.t. \(\Phi_{g(e)}=\Phi_e\). Moreover, an \(e\) can be computed from an index of \(g\)
    #+END_theorem

    #+BEGIN_proof
    Consider a partial computable function
    \begin{equation*}
    \Theta(z,x)=\Phi_{g(\Phi_z(z))}(x)
    \end{equation*}
    By parameter theorem, there is a computable \(q:\N\to\N\) s.t.
    \begin{equation*}
    \forall x\forall z\Theta(z,x)=\Phi_{q(z)}(x)=\Phi_{g(\Phi_z(z))}{x}
    \end{equation*}
    Let \(d\) be an index of the T.M. computing \(q\), i.e., \(q(z)=\Phi_d(z)\) for all \(z\). Let \(e=q(d)\)
    #+END_proof

    #+ATTR_LATEX: :options [Recursion theorem with parameters]
    #+BEGIN_theorem
    Let \(g:\N^2\to\N\) be computable, then there is a computable \(f:\N\to\N\) s.t. for every \(n\in\N\),
    \begin{equation*}
    \Phi_{g(f(n),n)}=\Phi_{f(n)}
    \end{equation*}
    Moreover an index of \(f\) can be computed from an index of \(q\)
    #+END_theorem
* Theory of Computability Models
** COMMENT Notations
    * \(e\downarrow\) 'the value of \(e\) is defined'
    * \(e\uparrow\) 'the value of \(e\) is undefined'
    * \(e=e'\) 'the values of both \(e\) and \(e'\) are defined and they are equal'
    * \(e\simeq e'\) 'if either \(e\) or \(e'\) is defined then so is the other and they are equal'
    * \(e\succeq e'\) 'if \(e'\) is defined then so is \(e\) and they are equal'


    if \(e\) is a mathematical expression possibly involving the variable \(x\), we write \(\Lambda x.e\)
    to mean the ordinary (possibly partial) function \(f\) defined by \(f(x)\simeq e\)

    Finite sequences of length \(n\) starts from index 0.
** COMMENT Higher-Order Computability Models
*** Computability Models
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:3.1.1
    A *computability model* \(\bC\)  over a set \(\sfT\) of *type names* consists of
    * an indexed family \(\abs{\bC}=\{\bC(\tau)\mid\tau\in\sfT\}\) of sets, called the *datatypes* of \(\bC\)
    * for each \(\sigma,\tau\in\sfT\), a set \(\bC[\sigma,\tau]\) of partial functions \(f:\bC(\sigma)\rhu\bC(\tau)\), called the
      *operations* of \(\bC\)


    s.t.
    1. for each \(\tau\in\sfT\), the identity function \(\id:\bC(\tau)\to\bC(\tau)\) is in \(\bC(\tau,\tau)\)
    2. for any \(f\in\bC[\rho,\sigma]\) and \(g\in\bC[\sigma,\tau]\) we have \(g\circ f\in\bC[\rho,\tau]\) where \(\circ\) denotes ordinary
       composition of partial functions
    #+END_definition

    We shall use uppercase letters \(A,B,C,\dots\) to denote *occurrences* of sets within \(\abs{\bC}\):
    that is, sets \(\bC(\tau)\) implicitly tagged with a type name \tau. We shall write \(\bC[A,B]\)
    for \(\bC[\sigma,\tau]\) if \(A=\bC(\sigma)\) and \(B=\bC(\tau)\)

    In typical cases of interest, the operations of \(\bC\) will be 'computable' maps of some kind between datatypes

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A computability model \(\bC\) is *total* if every operation \(f\in\bC[A,B]\) is a total
    function \(f:A\to B\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A computability model \(\bC\) has *weak (binary cartesian) products* if there is an operation
    assigning to each \(A,B\in\abs{\bC}\) a datatype \(A\bowtie B\in\abs{\bC}\) along with
    operations \(\pi_A\in\bC[A\bowtie B,A]\) and \(\pi_B\in\bC[A\bowtie B,B]\) (known as *projections*) s.t. for
    any \(f\in\bC[C,A]\) and \(g\in\bC[C,B]\) there exists \(\la f,g\ra\in\bC[C,A\bowtie B]\) satisfying the following for
    all \(c\in C\)
    1. \(\la f,g\ra(c)\downarrow\) iff \(f(c)\downarrow\) and \(g(c)\downarrow\)
    2. \(\pi_A(\la f,g\ra(c))=f(c)\) and \(\pi_B(\la f,g\ra(c))=g(c)\)


    We say that \(d\in A\bowtie B\) *represents* the pair \((a,b)\) if \(\pi_A(d)=a\) and \(\pi_B(d)=b\)
    #+END_definition

    In contrast to the usual definition of categorical products, the operation \(\la f,g\ra\) need not be
    unique, since many elements of \(A\bowtie B\) may represent the same pair \((a,b)\). We do not formally
    require that every \((a,b)\) is represented in \(A\bowtie B\), though in all cases of interest this will be
    so. The reader is also warned that \(\pi_A\circ\la f,g\ra\) will not in general coincide with \(f\) .

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *weak terminal* in a computability model \(\bC\) consists of a datatype \(I\in\abs{\bC}\) and an
    element \(i\in I\) s.t. for any \(A\in\abs{\bC}\) the constant function \(\Lambda a.i\) is in \(\bC[A,I]\)
    #+END_definition

    If \(\bC\) has weak products and a weak terminal \((I,i)\), then for any \(A\in\abs{\bC}\) there is an
    operation \(t_A\in\bC[A,I\bowtie A]\) s.t. \(\pi_A\circ t_A=\id_A\)
*** Examples of Computability Models
    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    label:3.1.5
    Model with single datatype \(\N\) and whose operations \(\N\rightharpoonup\N\) are precisely the
    Turing-computable partial functions. The model has standard products, since the well-known
    computable pairing operation
    \begin{equation*}
    \la m,n\ra=(m+n)(m+n+1)/2+m
    \end{equation*}
    defines a bijection \(\N\times\N\to\N\). Any element \(i\in\N\) may serve as a weak terminal,
    since \(\Lambda n.i\) is computable
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    label:3.1.6
    untyped \lambda-calculus

    Terms \(M\) of the \lambda-calculus are generated from a set of variable symbols \(x\) by means of the following
    grammar:
    \begin{equation*}
    M::=x\mid MM'\mid\lambda x.M
    \end{equation*}
    Writing \(\sfL\) for the quotient set \(\Lambda/=_\beta\)

    We write \(M[x\mapsto N]\) for the result of substituting \(N\) for all free occurrences of \(x\)
    within \(M\)

    We define \Lambda  to be the set of untyped \lambda-terms modulo \alpha-equivalence.

    Let \(\sim\) be any equivalence relation on \Lambda with the following properties:
    \begin{equation*}
    (\lambda x.M)N\sim M[x\mapsto N],\quad M\sim N\Rightarrow PM\sim PN
    \end{equation*}
    1. \((\lambda x.x)M\sim M\)
    2. If \(M\sim N\), then \((\lambda x.N)M\sim(\lambda x.M)N\) and hence \(N\sim M\).
    3. If \(M\sim N\) and \(N\sim O\), then

    Then we have \(M\sim N\Rightarrow MP\sim NP\) since \((\lambda y.yP)M\sim(\lambda y.yP)N\Rightarrow MP\sim NP\).

    As a example, we may define \(=_\beta\) to be the smallest equivalence relation \(\sim\) satisfying the
    above properties and also
    \begin{equation*}
    M\sim N\Rightarrow \lambda x.M\sim\lambda x.N
    \end{equation*}

    Writing \([M]\) for the \(\sim\)-equivalence class of \(M\), any term \(P\in A\) induces a
    well-defined mapping \([M]\mapsto[PM]\) on \(\Lambda/\sim\). The mappings induced by some \(P\) in this way are
    called *\lambda-definable*

    We may regard \(\Lambda/\sim\) as a total computability model: the sole datatype is \(\Lambda/\sim\) itself, and
    the operations on it are exactly the \lambda-definable mappings. It also has weak products: a
    pair \((M,N)\) may be represented by the term \(pair\;M\;N\) where \(pair=\lambda xyz.zxy\)
    the terms \(fst=\lambda p.p(\lambda xy.x)\) and \(snd=\lambda p.p(\lambda xy.y)\). We can check that
    \(fst(pair\; M\;N)\sim M\) and \(snd(pair\;M\;N)\sim N\)

    We can also obtain a submodel \(\Lambda^0/\sim\) consisting of the equivalence classes of closed terms \(M\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    label:3.1.7
    Let \(B\) be any family of *base sets*, and let \(\la B\ra\) denote the family of sets generated
    from \(B\) by adding the singleton set \(1=\{()\}\) and closing under binary products \(X\times Y\) and
    set-theoretic function spaces \(Y^X\). We shall consider some computability models whose family
    of datatypes is \(\la B\ra\)

    First we may define a computability model \(\sfS(B)\) with \(\abs{\sfS(B)}=\la B\ra\) (often called
    the *full set-theoretic model over* \(B\)) by letting \(\sfS(B)[X,Y]\) consist of all
    set-theoretic functions \(X\to Y\) for \(X,Y\in\la B\ra\); that is, we consider all functions to be
    computable. However this model is of limited interest since it does not represent an interesting
    concept of computability

    To do better we may start by noting that whatever the 'computable' functions between these sets
    are supposed to be, it is reasonable to expect that they will enjoy the following closure
    properties
    1. For any \(X\in\la B\ra\), the unique function \(X\to 1\) is computable
    2. For any \(X,Y\in\la B\ra\), the projections \(X\times Y\to X\), \(X\times Y\to Y\) is computable
    3. For any \(X,Y\in\la B\ra\), the application function \(Y^X\times X\to Y\) is computable
    4. If \(f:Z\to X\) and \(g:Z\to Y\) is computable, so is their pairing \((f,g):Z\to X\times Y\)
    5. If \(f:X\to Y\) and \(g:Y\to Z\) are computable, so is their composition \(g\circ f:X\to Z\)
    6. If \(f:Z\times X\to Y\) is computable, so is its transpose \(\hatf:Z\to Y^X\)


    One possible approach is therefore to start by specifying some set \(C\) of functions between
    out datatypes that we wish to regard as "basic computable operations", and define a
    computability model \(\sfK(B;C)\) over \(\la B\ra\) whose operations are exactly the functions
    generated from \(C\) under the above closure conditions

    Take \(B=\{\N\}\); we shall often denote \(\sfS(\{\N\})\) by \(\sfS\). Let \(C\) consist of the
    following basic operations: the zero function \(\Lambda x.0:\N\to 1\), the successor function \(suc:\N\to\N\);
    and for each \(X\in\la B\ra\), the primitive recursion operator \(rec_X:(X\times X^{X\times\N}\times\N)\to X\) defined by
    \begin{align*}
    &rec_X(x,f,0)=0\\
    &rec_X(x,f,n+1)=f(rec_X(x,f,n),n)
    \end{align*}
    the resulting model \(\sfK(B;C)\) consists of exactly those operations of \(\sfS\) definable in
    Gödel's *System T*
    #+END_examplle
*** Weakly Cartesian Closed Models
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:3.1.8
    Suppose \(\bC\) has weak products and a weak terminal. We say \(\bC\) is *weakly cartesian closed* if
    it is endowed with the following for each \(A,B\in\abs{\bC}\):
    * a choice of datatype \(A\Rightarrow B\in\abs{\bC}\)
    * a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\), external to the structure of \(\bC\)


    s.t. for any partial function \(f:C\times A\rhu B\) the following are equivalent
    1. \(f\) is represented by some \(\barf:\C[C\bowtie A,B]\), in the sense that if \(d\)
       represents \((c,a)\) then \(\barf(d)\simeq f(c,a)\)
    2. \(f\) is represented by some total operation \(\hatf:\bC[C,A\Rightarrow B]\), in the sense that
       \begin{equation*}
       \forall c\in C,a\in A\quad\hatf(c)\cdot_{AB}a\simeq f(c,a)
       \end{equation*}
    #+END_definition

    \(\cdot_{AB}\) is represented by an operation \(app_{AB}\in\C[(A\Rightarrow B)\bowtie A,B]\)

    Crucially, and in contrast to the definition of cartesian closed category, there is no
    requirement that \(f\) is unique. This highlights an important feature of our framework: in many
    models of interest, elements of \(A\Rightarrow B\) will be *intensional* objects (programs or algorithms),
    and there may be many intensional objects giving rise to the same partial function \(A\to B\)

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Consider again the model of Example ref:3.1.5, comprising the partial Turing-computable
    functions \(\N\rhu\N\). Here \(\N\Rightarrow\N\) can only be \(\N\), so we must provide a suitable
    operation \(\cdot:\N\times\N\to\N\). This is done using the concept of a *universal Turing machine*.
    Let \(T_0, T_1,\dots\)  be some sensibly chosen enumeration of all Turing machines for computing
    partial functions \(\N\rhu\N\). Then there is a Turing machine that accepts two inputs \(e,a\) and
    returns the result of applying the machine \(T_e\) to the single input \(a\). We may therefore
    take \(\cdot\) to be the partial function computed by \(U\)

    Clearly the partial functions \(f:\N\times\N\rhu\N\)  representable within the model via the pairing
    operation from Example ref:3.1.5 are just the partial computable ones. We may also see that
    these coincide exactly with those represented by some total computable \(\barf:\N\to\N\), in the
    sense that \(f(c,a)\simeq\tilf(c)\cdot a\).

    \(\Leftarrow\): Given a computable \(\tilf\) the operation \(\Lambda(c,a).\tilf(c)\cdot a\) is clearly computable

    \(\Rightarrow\): \(s\)-\(m\)-\(n\) theorem

    When endowed with this weakly cartisian closed structure, this computability model is known as
    *Kleene's first model* of \(K_1\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    label:3.1.10
    Now consider the model \(\Lambda/\sim\) ; we shall write \(\sfL\) for the set \(\Lambda/\sim\) considered as the
    sole datatype in this model. Set \(\sfL\Rightarrow\sfL=\sfL\bowtie\sfL=\sfL\). We may obtain a weakly cartesian
    closed structure by letting \(\cdot\) be given by application. If \(M\in\Lambda\) induces an operation
    in \([\sfL\bowtie \sfL,\sfL]\) representing some \(f:\sfL\times\sfL\to\sfL\), then \(\lambda x.\lambda y.M(pair\;x\;y)\)
    induces the corresponding operation in \([\sfL,\sfL\Rightarrow\sfL]\); conversely if \(N\) induces an
    operation in \([\sfL,\sfL\Rightarrow\sfL]\) then \(\lambda z.N(fst\;z)(snd\;z)\) induces the corresponding one
    in \([\sfL\bowtie\sfL,\sfL]\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    For models of the form \(\sfK(B;C)\), we naturally define \(X\Rightarrow Y=Y^X\) and take \(\cdot_{XY}\) to be
    ordinary function application. These models are endowed with binary products, and it is
    immediate from closure condition 6 in Example ref:3.1.7 that they are weakly cartesian closed

    Such models show that not every element of \(X\Rightarrow Y\) need represent an operation in \(\bC[X,Y]\),
    or equivalently one in \(\bC[1,X\Rightarrow Y]\). This accords with the idea that our models consist of
    'computable' operations acting on potentially 'non-computable' data: operations in \(\bC[X,Y]\)
    are computable, whereas elements of \(X\) need not be
    #+END_examplle
*** Higher-Order Models
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *higher-order structure* is a computability model \(\bC\) possessing a weak terminal \((I,i)\) and
    endowed with the following for each \(A,B\in\abs{\bC}\)
    * a choice of datatype \(A\Rightarrow B\in\abs{\bC}\)
    * a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\)
    #+END_definition

    We treat \(\Rightarrow\) as right-associative and \(\cdot\) as left-associative

    The significance of the weak terminal \((I,i)\) here is that it allows us to pick out a
    subset \(A^\sharp\) of each \(A\in\abs{\bC}\), namely the set of elements of the form \(f(i)\)
    where \(f\in\bC[I,A]\) and \(f(i)\downarrow\).

    This is independent of the choice of \((I,i)\): if \(a=f(i)\) and \((J,j)\) is another weak
    terminal, then composing \(f\) with \(\Lambda x.i\in\bC[J,I]\) gives \(f'\in\bC[J,A]\) with \(f'(j)=a\).

    Intuitively, we think of \(A^\sharp\) as playing the role of the 'computable' elements of \(A\), and \(i\) as
    some generic computable element.
    On the one hand, if \(a\in A\) were computable, we would expect each
    \(\Lambda x.a\) to be computable so that \(a\in A^\sharp\); on the other hand, the image of a computable element
    under a computable operation should be computable, so that every element of \(A^\sharp\) is
    computable.

    Any weakly cartesian closed model \(\bC\) is a higher-structure.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:3.1.13
    A *higher-order (computability) model* is a higher-order structure \(\bC\) satisfying the following
    conditions for some (or equivalently any) weak terminal \((I,i)\)
    1. A partial function \(f:A\rhu B\) is present in \(\bC[A,B]\) iff there
       exists \(\hatf\in\bC[I,A\Rightarrow B]\) s.t.
       \begin{equation*}
       \hatf(i)\downarrow,\quad\forall a\in A.\hatf(i)\cdot a\simeq f(a)
       \end{equation*}
    2. For any \(A,B\in\abs{\bC}\), there exists \(k_{AB}\in(A\Rightarrow B\Rightarrow A)^\sharp\) s.t.
       \begin{equation*}
       \forall a.k_{AB}\cdot a\downarrow,\quad \forall a,b.k_{AB}\cdot a\cdot b=a
       \end{equation*}
    3. For any \(A,B,C\in\abs{\bC}\) there exits
       \begin{equation*}
       s_{ABC}\in((A\Rightarrow B\Rightarrow C)\Rightarrow(A\Rightarrow B)\Rightarrow(A\Rightarrow C))^\sharp
       \end{equation*}
       s.t.
       \begin{equation*}
       \forall f,g.s_{ABC}\cdot f\cdot g\downarrow,\quad\forall f,g,a.s_{ABC}\cdot f\cdot g\cdot a\simeq(f\cdot a)\cdot(g\cdot a)
       \end{equation*}
    #+END_definition

    The elements \(k\) and \(s\) correspond to combinators from combinatory logic.

    \(k\) allows us to construct *constant* maps in a computable way

    A possible intuition for \(s\) is that it somehow does duty for an application
    operation \((B\Rightarrow C)\times B\rhu C\)
    within \(\bC\) itself, where the application may be performed uniformly in a parameter of type A.p

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.1.14
    Suppose \(\bC\) is a higher-order model
    1. for any \(j<m\), there exists \(\pi_j^m\in(A_0\Rightarrow\cdots\Rightarrow A_{m-1}\Rightarrow A_j)^\sharp\) s.t.
       \begin{equation*}
       \forall a_0,\dots,a_{m-1}.\pi_j^m\cdot a_0\cdot\dots\cdot a_{m-1}=a_j
       \end{equation*}
    2. Suppose \(m,n>0\). Given
       \begin{gather*}
       f_j\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j)^\sharp,\quad(j=0,\dots,n-1),\\
       g\in(B_0\Rightarrow\dots\Rightarrow B_{n-1}\Rightarrow C)^\sharp
       \end{gather*}
       there exists \(h\in (A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow C)^\sharp\) s.t.
       \begin{equation*}
       \forall a_0,\dots,a_{m-1}.h\cdot a_0\cdot\dots\cdot a_{m-1}\simeq g\cdot(f_0\cdot a_0\cdot\dots\cdot a_{m-1})\cdot\dots\cdot(f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
       \end{equation*}
    3. Suppose \(m>0\). For any element \(f\in (A_0\Rightarrow\cdots\Rightarrow A_{m-1}\Rightarrow B)^\sharp\), there
       exists \(f^\dagger\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B)^\sharp\) s.t.
       \begin{gather*}
       \forall a_0,\dots,a_{m-1}.f^\dagger\cdot a_0\cdot\dots\cdot a_{m-1}\simeq f\cdot a_0\cdot\dots\cdot a_{m-1}\\
       \forall k<m.\forall a_0,\dots,a_{k-1}.f^\dagger\cdot a_0\cdot\dots\cdot a_{k-1}\downarrow
       \end{gather*}
    #+END_proposition

    \(i_A=s_{A(A\Rightarrow A)A}\cdot k_{A\Rightarrow A}\cdot k_{AA}\in(A\Rightarrow A)^\sharp\)

    #+BEGIN_proof
    1. consider
       \begin{align*}
       &T[x]\Rightarrow x\\
       &T[(E_1\;E_2)]\Rightarrow(T[E_1]\;T[E_2])\text{if $x$ does not occur free in $E$}\\
       &T[\lambda x.E]\Rightarrow(\bK\;T[E])\\
       &T[\lambda x.x]\Rightarrow\bI\\
       &T[\lambda x.\lambda y.E]\Rightarrow T[\lambda x.T[\lambda y.E]]\text{if $x$ occurs free in $E$}\\
       &T[\lambda x.(E_1\;E_2)]\Rightarrow(\bS\;T[\lambda x.E_1]\;T[\lambda x.E_2])\text{if $x$ occurs free in $E_1$ or $E_2$}
       \end{align*}
       so \(A\Rightarrow B\Rightarrow B\to\lambda x^Ay^B.y^B\to \bK_{B\Rightarrow B,A}\cdot I_B\)
    #+END_proof

    If \(\bC,\bD\) are higher-order structures, we say \(\bC\) is a *full substructure* of \(\bD\) if
    * \(\abs{\bC}\subseteq\abs{\bD}\)
    * \(\bC[A,B]=\bD[A,B]\) for all \(A,B\in\abs{\bC}\)
    * some (or equivalently any) weak terminal in \(\bC\) is also a weak terminal in \(\bD\)
    * the meaning of \(A\Rightarrow B\) and \(\cdot_{AB}\) in \(\bC\) and \(\bD\) coincide


    Note that if \((I,i)\) and \((J,j)\) are weak terminals in \(\bC\) then \(\Lambda x.j\in\bC[I,J]\), so
    if \((I,i)\) is a weak terminal in \(\bD\) then so is \((J,j)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:3.1.15
    A higher-order structure is a higher-order model iff it is a full substructure of a weakly
    cartesian closed model
    #+END_theorem

    #+BEGIN_proof
    Let \(\bC\) be a higher-order structure.

    \(\Leftarrow\): suppose \(\bD\) is weakly cartesian closed and \(\bC\) is a
    full substructure of \(\bD\) with a weak terminal \((I,i)\)
    1. For any \(f\in\bC[A,B]=\bD[A,B]\) we have that \(f\circ\pi_A\in\bD[I\bowtie A,B]\) represents \(\Lambda(x,a).f(a)\),
       which by definition ref:3.1.8 is in turn represented by some total \(\hatf\in\bD[I,A\Rightarrow B]\).

       Conversely, given \(f:A\rhu B\) and \(\hatf\in\bC[I,A\Rightarrow B]\) with \(\hatf(i)\downarrow\)
       and \(\hatf(i)\cdot a\simeq f(a)\) for all \(a\), take \(\hatg=\hatf\circ(\Lambda x.i)\in\bC[I,A\Rightarrow B]=\bD[I,A\Rightarrow B]\) so
       that \(\hatg\) is total and represents \(g=\Lambda(x,a).f(a):I\times A\rhu B\). Now
       let \(\barg\in\bD[I\bowtie A,B]\) also represents \(g\). Then \(\barg\circ\la\Lambda a.i,\id_A\ra\in\bD[A,B]=\bC[A,B]\) and
       it is routine to check that \(\barg\circ\la\Lambda a.i,\id_A\ra=f\)

    2. Suppose \(A,B\in\abs{\bC}\). Let \(k'\in\bD[A,B\Rightarrow A]\) correspond to \(\pi_A\in\bD[A\bowtie B,A]\) as in
       definition ref:3.1.8, then \(k'(a)\cdot b\simeq\pi_A(d)\). Let \(\hatk'\in\bD[I,A\Rightarrow(B\Rightarrow A)]\) correspond
       to \(k'\circ\pi_A'\in\bD[I\bowtie A,B\Rightarrow A]\) where \(\pi_A'\in\bD[I\bowtie A,A]\) and take \(k=\hatk'(i)\)
       \(k\cdot a\cdot b=\hatk'(i)\cdot a\cdot b=(k'\circ\pi_A'(i,a))\cdot b=k'(a)\cdot b=a\)

    3.

    \(\Rightarrow\): Suppose \(\bC\) is a higher-order model, with \((I,i)\) a weak terminal. We build a weakly
    cartesian closed model \(\bC^\times\) into which \(\bC\) embeds fully as follows:
    * Datatypes of \(\bC^\times\) are sets \(A_0\times\dots\times A_{m-1}\), where \(m>0\) and \(A_0,\dots,A_{m-1}\in\abs{\bC}\)
    * If \(D=A_0\times\dots\times A_{m-1}\) and \(E=B_0\times\dots\times B_{n-1}\) where \(m,n>0\) the operations
      in \(\bC^\times[D,E]\) are those partial functions \(f:D\rhu E\) of the form
      \begin{equation*}
      f=\Lambda(a_0,\dots,a_{m-1}).(f_0\cdot a_0\cdot\dots\cdot a_{m-1},\dots,f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
      \end{equation*}
      where \(f_j\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j)^\sharp\) for each \(j\); we say that \(f_0,\dots,f_{n-1}\) *witness*
      the operation \(f\). Note that for \((f_0\cdot a_0\cdot\dots\cdot a_{m-1},\dots,f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})\) to be
      defined, it is necessary that all its components be defined


    It remains to check the relevant properties of \(\bC^\times\). That \(\bC^\times\) is a computability model is
    straightforward: the existence of identities follows from part 1 of Proposition ref:3.1.14
    and composition from part 2. \(\bC^\times\) has standard products and that \((I,i)\) is a weak terminal
    in \(\bC^\times\).

    Now let's show that \(\bC^\times\) is weakly cartesian closed. Given \(D=A_0\times\dots\times A_{m-1}\)
    and \(E=B_0\times\dots\times B_{n-1}\) with \(m,n>0\), take \(C_j=A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j\) for each \(j\), and
    let \(D\Rightarrow E\) be the set of tuples \((f_0,\dots,f_{n-1})\in C_0\times\dots\times C_{n-1}\) witnessing operations
    in \(\bC^\times[D,E]\). The application \(\cdot_{DE}\) is then given by
    \begin{equation*}
    (f_0,\dots,f_{n-1})\cdot_{DE}(a_0,\dots,a_{m-1})\simeq(f_0\cdot a_0\cdot\dots\cdot a_{m-1},\dots,f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
    \end{equation*}

    Next, given an operation \(g\in\bC^\times[G\times D,E]\) witnessed by operations \(g_0,\dots,g_{n-1}\) in \(\bC\),
    take \(g_0^\dagger,\dots,g_{n-1}^\dagger\) as in Proposition ref:3.1.14 (3); then \(g_0^\dagger,\dots,g_{n-1}^\dagger\) witness
    the corresponding total operation \(\hatg\in\bC^\times[G,D\Rightarrow E]\). Conversely, the witnesses for any such
    total \(\hatg\) also witness the corresponding \(g\)
    #+END_proof
*** Typed Partial Combinatory Algebras
    The following definition captures roughly what is left of a higher-order model once the
    operations are discarded

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:3.1.16
    1. A *partial applicative structure* \(\bA\) consists of
       * an inhabited family \(\abs{\bA}\) of datatypes \(A,B,\dots\) (indexed by some set \(T\))
       * a (right-associative) binary operation \(\Rightarrow\) on \(\abs{\bA}\)
       * for each \(A,B\in\abs{\bA}\), a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\)
    2. A *typed partial combinatory algebra* (TPCA) is a partial applicative structure \(\bA\)
       satisfying the following conditions
       1. For any \(A,B\in\abs{\bA}\), there exists \(k_{AB}\in A\Rightarrow B\Rightarrow A\) s.t.
          \begin{equation*}
          \forall a.k\cdot a\downarrow,\quad\forall a,b.k\cdot a\cdot b=a
          \end{equation*}
       2. For any \(A,B,C\in\abs{\bA}\), there exists \(s_{ABC}\in(A\Rightarrow B\Rightarrow C)\Rightarrow(A\Rightarrow B)\Rightarrow(A\Rightarrow C)\) s.t.
          \begin{equation*}
          \forall f,g. s\cdot f\cdot g\downarrow,\quad\forall f,g,a.s\cdot f\cdot g\cdot a\simeq(f\cdot a)\cdot(g\cdot a)
          \end{equation*}


       A TPCA is *total* if all the application operations \(\cdot_{AB}\) are total
    #+END_definition

    Any higher-order model yields an underlying TPCA. However, in passing to this TPCA we lose the
    information that says which element of \(A\Rightarrow B\) are supposed to represent operations.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition

    1. If \(\bA^\circ\) denotes a partial applicative structure, a *partial applicative
       substructure* \(\bA^\sharp\) of \(\bA^\circ\) consists of a subset \(A^\sharp\subseteq A\) for each \(A\in\abs{\bA^\circ}\) s.t.
       * if \(f\in(A\Rightarrow B)^\sharp\), \(a\in A^\sharp\) and \(f\cdot a\downarrow\) in \(\bA^\circ\), then \(f\cdot a\in B^\sharp\)

       such a pair \((\bA^\circ;\bA^\sharp)\) is called a *relative partial applicative structure*

    2. A *relative TPCA* is a relative partial applicative structure \((\bA^\circ,\bA^\sharp)\) s.t. there exist
       elements \(k_{AB}, s_{ABC}\) in \(\bA^\sharp\) witnessing that \(\bA^\circ\) is a TPCA
    #+END_definition

    A relative TPCA \((\bA^\circ,\bA^\sharp)\) is *full* if \(\bA^\sharp=\bA^\circ\). We will use \(\bA\) to range over both
    ordinary TPCAs and relative ones (writing \(\bA^\circ\), \(\bA^\sharp\) for the two components of \(\bA\) in
    the latter case), so that in effect we identify an ordinary TPCA \(\bA\) with the relative
    TPCA \((\bA;\bA)\). Indeed, we may sometimes refer to ordinary TPCAs as 'full TPCAs' . Clearly the
    models \(K_1\) and \(\Lambda/\sim\) are full, while in general \(\sfK(B;C)\) is not: rather, it is a
    relative TPCA \(\bA\) in which \(\bA^\circ\) is a full set-theoretic type structure whilst \(\bA^\sharp\)
    consists of only the \(C\)-computable elements

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:3.1.18
    There is a canonical bijection between higher-order models and relative TPCAs
    #+END_theorem

    #+BEGIN_proof
    First suppose \(\bC\) is a higher-order model, and let \(\bA^\circ\) be its underlying partial
    applicative structure. Take \((I,i)\) a weak terminal in \(\bC\), and for any \(A\in\abs{\bC}\),
    define \(A^\sharp=\{g(i)\mid g\in\bC[I,A],g(i)\downarrow\}\). As noted there, this is independent of the choice
    of \((I,i)\); in fact, it is easy to see that \(a\in A^\sharp\) iff \((A,a)\) is a weak terminal. To
    see that the \(A^\sharp\) form an applicative substructure, suppose \(f\in(A\Rightarrow B)^\sharp\) is witnessed
    by \(f'\in\bC[I,A\Rightarrow B]\) and \(a\in A^\sharp\) is witnessed by \(a'\in\bC[I,A]\), and suppose further
    that \(f\cdot a=b\). Take \(\check{f'}\in\bC[A\Rightarrow B]\) corresponding to \(f'\); then \(\check{f'}(a)=b\)
    and so \(\check{f'}\circ a'\) witnesses \(b\in B^\sharp\)

    Let \(\bA^\sharp\) denote the substructure formed by the sets \(A^\sharp\). It is directly build into
    Definition ref:def3.1.13 that there are elements \(k_{AB}, s_{ABC}\) in \(\bA^\sharp\) with the
    properties required by Definition ref:3.1.16; thus \((\bA^\circ;\bA^\sharp)\) is a relative TPCA

    For the converse, suppose \(\bA\) is a relative TPCA. Take \(\abs{\bC}=\abs{\bA^\circ}\) and
    for \(A,B\in\abs{\bC}\), let \(\bC[A,B]\) consist of all partial functions \(\Lambda a.f\cdot a\)
    for \(f\in(A\Rightarrow B)^\sharp\). To see that \(\bC\) has identities, for any \(A\in\abs{\bC}\), we have
    \begin{equation*}
    i_A=s_{A(A\Rightarrow A)A}\cdot k_{A(A\Rightarrow A)}\cdot k_{AA}\in(A\Rightarrow A)^\sharp
    \end{equation*}
    and clearly \(i_A\) induces \(\id_A\in\bC[A,A]\).  For composition, given
    operations \(f\in\bC[A,B]\), \(g\in\bC[B,C]\) induced by \(f'\in(A\Rightarrow B)^\sharp\), \(g'\in(B\Rightarrow C)^\sharp\), we have
    that \(g\circ f\in\bC[A,C]\) is induced by \(s_{ABC}\cdot(k_{(B\Rightarrow C)}\cdot g)\cdot f\). Thus \(\bC\) is a computability
    model

    For a weak terminal, take any \(U\in\abs{\bC}\) and let \(I=U\Rightarrow U\) and \(i=i_U\) as defined above.
    Then for any \(A\) we have that \(k_{IA}\cdot i\in(A\Rightarrow U\Rightarrow U)^\sharp\) induces \(\Lambda a.i\in\bC[A,I]\)

    To turn \(\bC\) into a higher-order structure, we take \(\Rightarrow\) and \(\cdot\) as in \(\bA^\circ\). We may now
    verify that for any \(A\) we have
    \begin{equation*}
    A^\sharp=\{g(i)\mid g\in\bC[I,A],g(i)\downarrow\}
    \end{equation*}
    so that the present meaning of \(A^\sharp\) coincides with its meaning in Section ref:3.1.4. For
    given \(a\in A^\sharp\) we have \(k_{AI}\cdot a\in(I\Rightarrow A)^\sharp\) inducing an operation \(g\) with \(g(i)=a\).
    Conversely, given \(g\in\bC[I,A]\) with \(g(i)\downarrow\) we have that \(g(i)=g'\cdot i\) for
    some \(g'\in(I\Rightarrow A)^\sharp\) (by definition, \(g\) is of the form \(\Lambda a.f\cdot a\)); but \(i\in I^\sharp\) so \(g(i)\in A^\sharp\)

    By applying the above equation to the type \(A\Rightarrow B\), we see that conditions 1 and 2 of
    Definition ref:3.1.13 are satisfied, and conditions 3 and 4 are immediate from the \(k,s\)
    conditions in Definition ref:3.1.16. Thus \(\bC\) is a higher-order model
    #+END_proof

    In the setting of a relative TPCA \(\bA\), we have a natural *degree structure* on the elements
    of \(\bA^\circ\). Specifically, if \(a\in A\) and \(b\in B\) where \(A,B\in\abs{\bA^\circ}\), let us
    write \(a\gg b\) if there exists \(f\in\bA^\sharp(A\Rightarrow B)\) with \(f\cdot a=b\)

    If \(\abs{\bA}\) consists of just a single datatype, then TPCA is just a single set \(A\) equipped
    with a partial 'application' operation \(\cdot:A\times A\rhu A\) s.t. for some \(k,s\in A\) we have
    \begin{equation*}
    \forall x,y.k\cdot x\cdot y=x,\quad\forall x,y.s\cdot x\cdot y\downarrow,\quad\forall x,y,z.s\cdot x\cdot y\cdot z\simeq(x\cdot z)\cdot(y\cdot z)
    \end{equation*}
    We call such a structure an *partial combinatory algebra* (or PCA)
*** Lax Models
    For simplicity, we have worked so far with a simple definition of computability model in which
    operations are required to be closed under ordinary composition of partial functions. It turns
    out, however, that with a few refinements, practically all the general theory presented in this
    chapter goes through under a somewhat milder assumption.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *lax computability model* \(\bC\)  over a set \(\sfT\) of *type names* consists of
    * an indexed family \(\abs{\bC}=\{\bC(\tau)\mid\tau\in\sfT\}\) of sets, called the *datatypes* of \(\bC\)
    * for each \(\sigma,\tau\in\sfT\), a set \(\bC[\sigma,\tau]\) of partial functions \(f:\bC(\sigma)\to\bC(\tau)\), called the
      *operations* of \(\bC\)


    s.t.
    1. for each \(\tau\in\sfT\), the identity function \(\id:\bC(\tau)\to\bC(\tau)\) is in \(\bC(\tau,\tau)\)
    2. for any \(f\in\bC[\rho,\sigma]\) and \(g\in\bC[\sigma,\tau]\), there exists \(h\in\bC[\rho,\tau]\) with \(h(a)\succeq g(f(a))\) for
       all \(a\in\bC(\rho)\)


    We may refer to \(h\) here as a *supercomposition* of \(f\) and \(g\).
    #+END_definition

    We sometimes refer to our standard computability models as *strict* when we wish to emphasize the
    contrast with lax models. Of course, for total computability models, the distinction
    evaporates completely.

    One possible motivation for the concept of lax model is that it is often natural to think of an
    application \(f(a)\) in terms of some computational agent \(F\) representing \(f\) being placed ‘alongside’
    a representation \(A\) of a to yield a composite system \(F\mid A\), which may then evolve in certain ways
    via interactions between \(F\) and \(A\). If an agent \(G\) representing \(g\) is then placed alongside this to
    yield a system \(G\mid F\mid A\), there is the possibility that \(G\) may interact ‘directly’ with \(F\) rather
    than just with the result obtained from \(F\mid A\); thus, \(G\mid F\) might admit other behaviours not
    accounted for by \(g\circ f\) . (For a precise example of this in process algebra, see Longley
    [183].)

    The notion of a *(relative) lax TPCA* is given by replacing the axioms for \(s_{ABC}\) in
    Definition ref:3.1.16 with
    \begin{equation*}
    \forall f,g.s\cdot f\cdot g\downarrow,\quad\forall f,g,a.s\cdot f\cdot g\cdot a\succeq (f\cdot a)\cdot(g\cdot a)
    \end{equation*}

    The definitions of weak products and weak terminal may be carried over unchanged to the
    setting of lax computability models; note that \(\la f,g\ra\) is still required to be a pairing in the
    ‘strict’ sense that its domain coincides precisely with \(\dom f\cap\dom g\). The definition of weakly
    cartesian closed model is likewise unchanged, although one should note that in the lax
    setting, whether a given model is weakly cartesian closed may be sensitive to the choice of the
    type operator \(\bowtie\).

    For the definition of a lax higher-order model, we simply replace '\(\simeq\)' by '\(\succeq\)' in
    condition 4(?) of Definition ref:3.1.13

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    1. Any lax higher-order model is a full substructure of a lax weakly cartesian closed model
    2. If \(\bD\) is a lax weakly cartesian closed model in which some weak terminal \((I,i)\) is a
       weak unit, any full substructure of \(\bD\) containing \(I\) is a lax higher-order model
    #+END_theorem


*** Type worlds
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. A *type world* is simply a set \(\sfT\) of *type names* \sigma, optionally endowed with any or
       all of the following:
       1. a *fixing map*, assigning a set \(\sfT[\sigma]\) to certain type names \(\sigma\in\sfT\)
       2. a *product structure*, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\times\tau\)
       3. an *arrow structure*, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\to\tau\)
    2. A *computability model over* a type world \(\sfT\) is a computability model \(\bC\) with index
       set \(\sfT\) (so that \(\abs{\bC}=\{\bC(\sigma)\mid\sigma\in\sfT\}\)) subject to the following conventions
       1. If \(\sfT\) has a fixing map, then \(\bC(\sigma)=T[\sigma]\) whenever \(\sfT(\sigma)\) is defined
       2. If \(\sfT\) has a product structure, then \(\bC\) has weak products and for any \(\sigma,\tau\in\sfT\)
          we have \(\bC(\sigma\times\tau)=\bC(\sigma)\bowtie\bC(\tau)\)
       3. If \(\sfT\) has an arrow structure, then \(\bC\) is a higher-order model and for
          any \(\sigma,\tau\in\sfT\) we have \(\bC(\sigma\to\tau)=\bC(\sigma)\Rightarrow\bC(\tau)\)
       4. If \(\sfT\) has both a product and an arrow structure, then \(\bC\) is weakly cartesian closed
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    The one-element type world \(\sfO=\{*\}\) with just the arrow structure \(*\to*=*\). TPCAs over this
    type world are precisely (untyped) PCAs; both \(K_1\) and \(\Lambda/\sim\) are examples
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    If \(\beta_0,\dots,\beta_{n-1}\) are distinct *basic type names* and \(B_0,\dots,B_{n-1}\) are sets, we may define
    the type word \(\sfT^{\to}(\beta_0=B_0,\dots,\beta_{n-1}=B_{n-1})\) to consist of formal type expressions
    freely constructed from \(\beta_0,\dots,\beta_{n-1}\) via \(\to\), fixing the interpretation of each \(\beta_i\)
    at \(B_i\). This type world has a fixing map and an arrow structure, but no product. We may write
    just \(\sfT^{\to}(\beta_0,\dots,\beta_{n-1})\) if we do not wish to constrain the interpretation of the \(\beta_i\)

    A typical example is the type world \(\sfT^\to(\ttN=\N)\). Models over this type would correspond
    to *finite type structures* over \(\N\); the models \(\sfK(B;C)\) are examples

    Type world \(\sfT^{\to}(\ttN=\N_\bot)\) where \(\N_\bot\) is the set of natural numbers together with an
    additional element \(\bot\) representing 'non-termination'. Whereas \(\N\) may be used to model
    actual *results* of computation, we may think of \(\N_\bot\) as representing some computational
    *process* which may or may not return a natural number.
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Similarly, we define \(\sfT^{\to\times}=(\beta_0=B_0,\dots,\beta_{n-1}=B_{n-1})\) to be the type world consisting
    of type expressions freely constructed form \(\beta_0,\dots,\beta_{n-1}\) via \(\to\) and \(\times\), fixing the
    interpretation of each \(\beta_i\) at \(B_i\). If no fixing map is required, we write
    just \(\sfT^{\to\times}(\beta_0,\dots,\beta_{n-1})\)

    Type worlds featuring a *unit type* (denoted by \(\texttt{1}\)) are also useful. We shall
    write \(\sfT^{\to\times\texttt{1}}(\beta_0=B_0,\dots,\beta_{n-1}=B_{n-1})\) for the type world
    \begin{equation*}
    \sfT^{\to\times}(\texttt{1}=\{()\},\beta_0=B_0,\dots,\beta_{n-1}=B_{n-1})
    \end{equation*}
    We will often refer to the type names in a type world simply as *types*, and use \rho, \sigma, \tau to range
    over them. When dealing with formal type expressions, we adopt the usual convention that \(\to\)
    is right-associative, so that \(\rho\to\sigma\to\tau\) means \(\rho\to(\sigma\to\tau)\). For definiteness, we may also declare
    that \(\times\) is right-associative, although in practice we shall not always bother to distinguish
    between \((\rho\times\sigma)\times\tau\) and \(\rho\times(\sigma\times\tau)\). We consider \(\times\) as binding more tightly than \(\to\)

    We shall use the notation \(\sigma_0,\dots,\sigma_{r-1}\to\tau\) as an abbreviation for \(\sigma_0\to\sigma_1\to\dots\to\sigma_{r-1}\to\tau\)
    (allowing this to mean \tau in the sense \(r=0\)). This allows us to express our intention
    regarding which objects are to be thought of as 'arguments' to a given operation: for instance,
    the types \(\ttN,\ttN,\ttN\to\ttN\) and \(\ttN,\ttN\to(\ttN\to\ttN)\) are formally the same, but in
    the first case we are thinking of a three-argument operation returning a natural number, while
    in the second we are thinking of a two-argument operation returning a function \(\N\to\N\). We also
    write \(\sigma^{(r)}\to\tau\) for the type \(\sigma,\dots,\sigma\to\tau\) with \(r\) arguments. The notation \(\sigma^r\) is
    reserved for the \(r\)-fold product type \(\sigma\times\dots\times\sigma\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    Any type \(\sigma\in\sfT^{\to}(\beta_0,\dots,\beta_{n-1})\) may be uniquely written in the form \(\sigma_0,\dots,\sigma_{r-1}\to\beta_i\)
    #+END_proposition

    We shall call this the *argument form* of \sigma. The importance of this is that it provides a useful
    induction principle for types: if a property holds for \(\sigma_0,\dots,\sigma_{r-1}\to\beta_i\) whenever it holds
    for each of \(\sigma_0,\dots,\sigma_{r-1}\), then it holds for all \(\sigma\in\sfT^{\to}(\beta_0,\dots,\beta_{n-1})\). We shall
    refer to this as *argument induction*; it is often preferable as an alternative to the usual
    *structural induction* on types

    Closely associated with argument form is the notion of the *level* of a type \sigma: informally, the
    stage at which \sigma appears in the generation of \(\sfT^\to(\beta_0,\dots,\beta_{n-1})\) via argument induction:
    \begin{align*}
    \lv(\beta_i)&=0\\
    \lv(\sigma_0,\dots,\sigma_{r-1}\to\beta_i)&=1+\max_{i<r}\lv(\sigma_i)\quad(r\ge 1)
    \end{align*}
    When working with \(\sfT^{\to\times}(\beta_0,\dots,\beta_{n-1})\), it is natural to augment this definition with
    \begin{equation*}
    \lv(\sigma\times\tau)=\max(\lv(\sigma),\lv(\tau))
    \end{equation*}
    We may define the *pure type of level \(k\) over \sigma*, written \(\bark[\sigma]\):
    \begin{equation*}
    \bbar{0}[\sigma]=\sigma,\quad\ove{k+1}[\sigma]=\bark[\sigma]\to\sigma
    \end{equation*}
    For type worlds generated by a single base type \beta, we may write simply \(\bark\)
    for \(\bark[\beta]\). For instance, in the type word \(\sfT^{\to}(\N)\) we write \(\bbar{2}\) for the
    type \((\ttN\to\ttN)\to\ttN\).
**  Further Examples of Higher-Order Models
*** Kleene's Second Model
    Whereas \(K_1\) captures a notion of computability for finitary data such as numbers, our next
    example embodies a notion of computability in an /infinitary/ setting.

    When our computation returns a result \(F(g)\in\N\), it must do so after only a finite number of
    'computation steps'

    If \(F:\N^{\N}\to\N\) is computable, the function \(F\) can be completely described by recording, for
    each finite sequence \(m_0,\dots,m_{r-1}\), whether the information '\(g(0)=m_0,\dots,g(r-1)=m-1\)'
    suffices to determine the value of \(F(g)\), and if so, what the value is. We write \(\la\cdots\ra\)for
    standard computable operation \(\N^*\to\N\)
    \begin{align*}
    &f(\la m_0,\dots,m_{r-1}\ra)=m-1&&\text{if }F(g)=m\text{ whenever }g(0)=m_0,\dots,g(r-1)=m_{r-1}\\
    &f(\la m_0,\dots,m_{r-1}\ra)=0&&\text{'}g(0)=m_0,\dots,g(r-1)=m_{r-1}\text{' does not}\\
    &&&\text{suffice to determine }F(g)
    \end{align*}
    We can then compute \(F(g)\) from just \(f\) and \(g\)
    \begin{align*}
    F(g)=(f\mid g):=&f(\la g(0),\dots,g(r-1)\ra)-1\\
    &\text{where }r=\mu r.f(\la g(0),\dots,g(r-1)\ra)>0
    \end{align*}
    Even if \(f\in\N^{\N}\) does not represent some \(F\) in this way, we can regard the above formula
    as defining a /partial/ computable function \((f\mid-):\N^{\N}\rhu\N\)

    A small tweak is to obtain an application operation with codomain \(\N^{\N}\) rather than \(\N\).
    In effect, the computaion now accepts an additional argument \(n\in N\), which can be assumed to
    be known before any queries to \(g\) are made. We may therefore define
    \begin{align*}
    (f\odot g)(n):=&f(\la n,g(0),\dots,g(r-1)\ra)-1\\
    &\text{where }r=\mu r.f(\la n,g(0),\dots,g(r-1)\ra)>0
    \end{align*}
    In general, this will define a *partial* function \(\N\rhu\N\). We shall henceforth
    consider \(f\odot g\) to be 'defined' only if the above formula yields a /total/ function \(\N\to\N\). In
    this way, we obtain a partial application operation
    \begin{equation*}
    \odot:\N^{\N}\times\N^{\N}\rhu\N^{\N}
    \end{equation*}
    The structure \((\N^{\N},\odot)\) is known to be *Kleene's second model*

    We can also restrict \(\odot\) to the set of total /computable/' functions \(\N\to\N\). Since the natural
    candidates for \(k,s\) in \(K_2\) are computable, this gives us both a PCA \(K_2^{\eff}\) and a
    relative PCA \((K_2;K_2^{\eff})\)
*** COMMENT The Partial Continuous Functionals
    The model \(\PC\) consisting of *partial continuous functionals* over the natural numbers over the
    type world \(\sfT=\sfT^{\to\times 1}(\ttN=\N_\bot)\)

    The idea is that we shall construct sets \(\PC(\sigma)\) for each \(\sigma\in\sfT\), where each \(\PC(\sigma\to\tau)\)
    consists of all functions \(f:\PC(\sigma)\to\PC(\tau)\) that are 'continuous' in the sense that any finite
    piece of observable information about an output \(f(x)\) can only rely on a finite amount of
    information about \(x\). To make sense of this, we need to provide, along with each \(\PC(\sigma)\),
    a reasonable notion of 'finite piece of information' for elements of \(\PC(\sigma)\).

    It is natural to identify a 'piece of information' with the set of elements of which that information is true,
    so in the first instance, we shall specify a family \(\calf_\sigma\) consisting of those subsets
    of \(\PC(\sigma)\) which we regard as _representing finitary properties of elements_. (In
    fact, \(\calf_\sigma\) will form a basis for *Scott topology*)

    We construct these data by induction on types. At base type, we take \(\PC(\ttN)=\N_\bot\)
    and \(\calf_{\ttN}=\{\N_\bot\}\cup\{\{n\}\mid n\in\N\}\);  the idea is that each \(n\) corresponds to a finite piece of
    information, while the whole set \(\N_\bot\) represents 'no information'.We also
    take \(\PC(1)=\{()\}_\bot\) and \(\calf_1=\{\{()\}_\bot,\{()\}\}\). For products we take \(\PC(\sigma\times\tau)=\PC(\sigma)\times\PC(\tau)\)
    and let \(\calf_{\sigma\times\tau}\) consists of all sets \(U\times V\) where \(U\in\calf_\sigma\), \(V\in\calf_\tau\). At function types,
    we take \(\PC(\sigma\to\tau)\) to consist of all functions \(f:\PC(\sigma)\to\PC(\tau)\) that are *continuous* in that
    for all \(x\in\PC(\sigma)\) and all \(V\in\calf_\tau\) containing \(f(x)\), there is some \(U\in\calf_\sigma\)
    containing \(x\)with \(f(U)\subseteq V\)

    The continuity of a function \(f\) may be manifested by its /graph/, namely the set of
    pairs \((U,V)\in\calf_\sigma\times\calf_\tau\) with \(f(U)\subseteq V\). Since each pair \((U,V)\) in the graph of \(f\) can be
    reasonably seen as giving finite information about \(f\), it seems natural to identify finite
    pieces of information with finite subsets of this graph. We therefore decree that \(\calf_{\sigma\to\tau}\)
    should contain all finite intersections of sets of the form
    \begin{equation*}
    (U\Rightarrow V):=\{f\in\PC(\sigma\to\tau)\mid\forall x\in U.f(x)\in V\}
    \end{equation*}
    for \(U\in\calf_\sigma\), \(V\in\calf_\tau\)

    For any \(\sigma,\tau\) we have the application operation \((f,x)\mapsto f(x):\PC(\sigma\to\tau)\times\PC(\sigma)\to\PC(\tau)\)
*** Typed \texorpdfstring{\(\lambda\)}{λ}-Calculi

    We work in the type world \(\sfT=\sfT^{\to}(\beta_0,\dots,\beta_{r-1})\) where \(\beta_i\) are base types. We
    assume given some set \(C\) of *constant symbols* \(c\), each with an assigned type \(\tau_c\in\sfT\);
    we also suppose we have an unlimited supply of *variable symbols* \(x^\sigma\) for each \sigma.

    \Xi specifies *basic evaluation contexts* \(K[-]\)

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Let \(C\) consist of the following constants
    \begin{align*}
    \hat{0}&:\ttN\\
    suc&:\ttN\to\ttN\\
    rec_\sigma&:\sigma\to(\sigma\to\ttN\to\sigma)\to\ttN\to\sigma
    \end{align*}
    Let \Delta consist of the \delta-rules
    \begin{gather*}
    rec_\sigma xf\hat{0}\rightsquigarrow x\\
    rec_\sigma xf(suc\; n)\rightsquigarrow f(rec_\sigma xfn)n
    \end{gather*}
    and let \Xi consist of the contexts of the forms
    \begin{equation*}
    [-]N,\quad suc[-],\quad rec_\sigma PQ[-]
    \end{equation*}
    The first means that if \(M\rightsquigarrow M'\) then \(MN\rightsquigarrow MN'\)

    This defines Gödel's *System \(T\)*

    #+END_examplle

    #+ATTR_LATEX: :options [Plotkin's PCF]
    #+BEGIN_examplle
    Let \(C\) consists of the following constants
    \begin{align*}
    \hat{0}&:\ttN\quad\forall n\in\N\\
    suc,pre&:\ttN\to\ttN\\
    ifzero&:\ttN,\ttN,\ttN\to\ttN\\
    Y_\sigma&:(\sigma\to\sigma)\to\sigma\quad\forall\sigma\in\sfT
    \end{align*}
    Let \Delta consist of rules of the forms
    \begin{align*}
    suc\;\hatn&\rightsquigarrow\what{n+1}\\
    pre\;\what{n+1}&\rightsquigarrow\hatn\\
    pre\;\hat{0}&\rightsquigarrow\hat{0}\\
    ifzero\;\hat{0}&\rightsquigarrow\lambda xy.x\\
    ifzero\;\what{n+1}&\rightsquigarrow\lambda xy.y\\
    Y_\sigma f&\rightsquigarrow f(Y_\sigma f)
    \end{align*}
    and let \Xi consist of the contexts of the forms
    \begin{equation*}
    [-]N,\quad suc[-],\quad pre[-],\quad ifzero[-]
    \end{equation*}
    The resulting language is known as Plotkin's PCF (/Programming language for Computable Functions/)

    #+END_examplle

    Given \Delta and \Xi as above, let us define a *one-step reduction* relation \(\rightsquigarrow\) between closed terms
    of the same type by means of the following inductive definition
    1. \((\lambda x^\sigma.M)N\rightsquigarrow M[x^\sigma\mapsto N]\) (*\beta-reduction*)
    2. If \((cM_0\dots M_{r-1}\rightsquigarrow N)\in\Delta\) and \(-^*\) denotes some type-respecting substitution of closed
       terms for the free variables of \(cM_0\dots M_{r-1}\),
       then \((cM_0^*\dots M_{r-1}^*)\rightsquigarrow N^*\)
    3. If \(M\rightsquigarrow M'\) and \(K[-]\in\Xi\), then \(K[M]\rightsquigarrow K[M']\)


    We call the entire system the *typed \lambda-calculus* specified by \(\vec{\beta},C,\Delta,\Xi\)

    Depending on the choice of \Delta and \Xi, the relation \(\rightsquigarrow\) may or may not be *deterministic* in the
    sense that \(M\rightsquigarrow M'\wedge M\rightsquigarrow M''\Rightarrow M'=M''\). Note that both System T and PCF have deterministic
    reduction relations.

    Typically we are interested in the possible values of a closed term \(M\), that is, those
    terms \(M'\) s.t. \(M\rightsquigarrow^*M'\) and \(M'\) can be reduced no further. In System T, every
    closed \(M:\ttN\) reduces to a unique numeral \(suc^k\hat{0}\). In PCF, there are terms such
    as \(Y_{\ttN}(\lambda x^{\ttN}.x)\)  that can never be reduced to a value. Thus System T is in essence
    a language for *total* functions, whilst PCF is a language for *partial* ones


    Let \(=_{op}\) be the *operational equivalence* relation on closed terms generated by
    \begin{equation*}
    M\rightsquigarrow M'\Rightarrow M=_{op}M',\quad M=_{op}M'\Rightarrow MN=_{op}M'N\wedge PM=_{op}PM'
    \end{equation*}

** COMMENT Computational Structure in Higher-Order Models
*** Combinatory Completeness
    Combinatory completeness can be seen as a syntactic counterpart to the notion of weakly
    cartesian closed model. In essence, combinatory completeness asserts that any operation
    definable by means of a formal expression over A (constructed using application) is
    representable by an element of A itself.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    label:3.1.16
    1. A *partial applicative structure* \(\bA\) consists of
       * an inhabited family \(\abs{\bA}\) of datatypes \(A,B,\dots\) (indexed by some set \(T\))
       * a (right-associative) binary operation \(\Rightarrow\) on \(\abs{\bA}\)
       * for each \(A,B\in\abs{\bA}\), a partial function \(\cdot_{AB}:(A\Rightarrow B)\times A\rhu B\)
    2. A *typed partial combinatory algebra* (TPCA) is a partial applicative structure \(\bA\)
       satisfying the following conditions
       1. For any \(A,B\in\abs{\bA}\), there exists \(k_{AB}\in A\Rightarrow B\Rightarrow A\) s.t.
          \begin{equation*}
          \forall a.k\cdot a\downarrow,\quad\forall a,b.k\cdot a\cdot b=a
          \end{equation*}
       2. For any \(A,B,C\in\abs{\bA}\), there exists \(s_{ABC}\in(A\Rightarrow B\Rightarrow C)\Rightarrow(A\Rightarrow B)\Rightarrow(A\Rightarrow C)\) s.t.
          \begin{equation*}
          \forall f,g. s\cdot f\cdot g\downarrow,\quad\forall f,g,a.s\cdot f\cdot g\cdot a\simeq(f\cdot a)\cdot(g\cdot a)
          \end{equation*}
           A *lax TPCA* is obtained from a TPCA change '\(\simeq\)' to '\(\succeq\)' in the axiom \(s\)
    3. If \(\bA^\circ\) denotes a partial applicative structure, a *partial applicative
            substructure* \(\bA^\sharp\) of \(\bA^\circ\) consists of a subset \(A^\sharp\subseteq A\) for each \(A\in\abs{\bA^\circ}\) s.t.
       * if \(f\in(A\Rightarrow B)^\sharp\), \(a\in A^\sharp\) and \(f\cdot a\downarrow\) in \(\bA^\circ\), then \(f\cdot a\in B^\sharp\)

       such a pair \((\bA^\circ;\bA^\sharp)\) is called a *relative partial applicative structure*
    4. A *relative TPCA* is a relative partial applicative structure \((\bA^\circ,\bA^\sharp)\) s.t. there exist
       elements \(k_{AB}, s_{ABC}\) in \(\bA^\sharp\) witnessing that \(\bA^\circ\) is a TPCA
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Suppose \(\bA\) is a relative partial applicative structure over \(\sfT\)
    1. The set of well-typed *applicative expressions* \(e:\sigma\) over \(\bA\) is defined inductively as
       follows
       * for each \(\sigma\in\sfT\), we have an unlimited supply of variables \(x^\sigma:\sigma\)
       * for each \(\sigma\in\sfT\) and \(a\in\bA^\sharp(\sigma)\), we have a *constant* symbol \(c_a:\sigma\) (we shall often
         write \(c_a\) simply as \(a\))
       * If \(e:\sigma\to\tau\) and \(e':\sigma\) are applicative expressions, then \(ee'\) is an applicative
         expression of type \tau.

       We write \(V(e)\) for the set of variables appearing in \(e\)

    2. A *valuation* in \(\bA\) is a function \(v\) assigning to certain variables \(x^\sigma\) an
       element \(v(x^\sigma)\in\bA^\circ(\sigma)\). Given an applicative expression \(e\) and a valuation \(v\)
       covering \(V(e)\), the value \(\llb{e}_v\), when defined, is given inductively by
       \begin{equation*}
       \llb{x^\sigma}_v=v(x),\quad\llb{c_a}_v=a,\quad\llb{ee'}_\nu\simeq\llb{e}_v\cdot\llb{e'}_v
       \end{equation*}
       Note that if \(e:\tau\) and \(\llb{e}_v\) is defined then \(\llb{e}_v\in\bA^\circ(\tau)\).
    #+END_definition

    Note that for any \(v\) with \(\ran(v)\in\bA^\sharp\), we can prove \(\llb{e:\tau}_v\in\bA^\sharp(\tau)\) by induction:
    1. If \(e\) is of the form \(x^\tau\)
    2. If \(e\) is of the form \(c_a\) where \(a\in\bA^\sharp(\tau)\)
    3. If \(e\) is of the form \(e'e''\) where \(e':\sigma\to\tau\) and \(e'':\sigma\).

       \(\llb{e}_v=\llb{e'}_v\cdot\llb{e''}_v\) where \(\llb{e'}_v\in\bA^\sharp(\sigma\to\tau)\) and \(\llb{e''}_v\in\bA^\sharp(\sigma)\).
       Since \(\bA^\sharp\) is a substructure of \(\bA^\circ\), if \(\llb{e'}_v\cdot\llb{e''}_v\downarrow\), then \(\llb{e}\in\bA^\sharp(\tau)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(\bA\) be a relative partial applicative structure. We say \(\bA\) is *lax combinatory complete*
    if for every applicative expression \(e:\tau\) over \(\bA\) and every variable \(x^\sigma\), there is an
    applicative expression \(\lambda^*x^\sigma.e\) with \(V(\lambda^*x^\sigma.e)=V(e)-\{x^\sigma\}\) s.t. for any valuation \(v\)
    covering \(V(\lambda^*x^\sigma.e)\) and any \(a\in\bA^\circ(\sigma)\) we have
    \begin{equation*}
    \llb{\lambda^*x^\sigma.e}_v\downarrow,\quad\llb{\lambda^*x^\sigma.e}_v\cdot a\succeq\llb{e}_{v,x\mapsto a}
    \end{equation*}
    We say \(\bA\) is *strictly combinatory complete* if this holds with '\(\simeq\)' in place of '\(\succeq\)'
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:3.3.3
    A (relative) partial applicative structure \(\bA\) is a lax (relative) TPCA iff it is lax
    combinatory complete
    #+END_theorem

    #+BEGIN_proof
    If \(\bA\) is lax combinatory complete, then for any \rho, \sigma, \tau we may define
    \begin{align*}
    k_{\sigma\tau}&=\llb{\lambda^*x^\sigma.(\lambda^*y^\tau.x)}_\emptyset\\
    s_{\rho\sigma\tau}&=\llb{\lambda^*x^{\rho\to\sigma\to\tau}.(\lambda^*y^{\rho\to\sigma}.(\lambda^*z^\rho.xz(yz)))}_\emptyset
    \end{align*}

    Conversely, if \(\bA\) is a lax TPCA, then given any suitable choice of elements \(k\) and \(s\)
    for \(\bA\), we may define \(\lambda^*x^\sigma.e\) by induction on the structure of \(e\):
    \begin{align*}
    \lambda^*x^\sigma.x&=s_{\sigma(\sigma\to\sigma)}k_{\sigma(\sigma\to\sigma)}k_{\sigma\sigma}&&\\
    \lambda^*x^\sigma.a&=k_{\tau\sigma}a&&\text{for each }a\in\bA^\sharp(\tau)\\
    \lambda^*x^\sigma.ee'&=s_{\sigma\tau\tau'}(\lambda^*x^\sigma.e)(\lambda^*x^\sigma.e')&&\text{if }e:\tau\to\tau',e':\tau\text{ and }ee'\text{ contains }x
    \end{align*}
    #+END_proof

    The same argument shows that \(\bA\) is a strict TPCA iff it is strictly combinatory complete

    we often tacitly suppose that a TPCA \(\bA\) comes equipped with some choice of k and s drawn from A♯,
    and in this case we shall use the notation \(\lambda^*x.e\) for the applicative expression given by the
    above proof. Since all the constants appearing in e are drawn from \(A^\sharp\), the same will be true for
    \(\lambda^*x.e\).


    In TPCAs constructed as syntactic models for untyped or typed \lambda-calculi (as in Example 3.1.6 or
    Section 3.2.3), the value of \(\lambda^*x.e\) coincides with \(\lambda x.e\). However, the notational distinction is worth
    retaining, since the term \(\lambda^*x.e\) as defined above is not syntactically identical
    to \(\lambda x.e\).

    More generally, we may consider terms of the \lambda-calculus as *meta-expressions* for applicative
    expressions. Specifically any such \lambda-term \(M\) can be regarded as denoting an applicative
    expression \(M^\dagger\) as follows:
    \begin{equation*}
    x^\dag=x,\quad c_a^\dag=c_a,\quad (MN)^\dag=M^\dag N^\dag,\quad(\lambda x.M)^\dag=\lambda^*x.(M^\dag)
    \end{equation*}

    Some caution is needed here, however, because \beta-equivalent meta-expressions
    do not always have the same meaning
    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Consider the two meta-expressions \((\lambda x.(\lambda y.y)x)\) and \(\lambda x.x\). Although these are
    \beta-equivalent, the first expands to \(s(ki)i\) and the second to \(i\), where \(i\equiv skk\).
    #+END_examplle

    The moral here is that \beta-reductions are not valid underneath \(\lambda^*\)-abstractions: in this case,
    the reduction \((\lambda^*y.y)x\rightsquigarrow x\) is not valid underneath \(\lambda^*\). However at
    least for the definition of \(\lambda^*\) given above, \beta-reductions at top level are valid.

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.5.5
    1. If \(M\) is a meta-expression, \(x\) is a variable and \(a\) is a constant or variable,
       then \(\llb{((\lambda x.M)a)^\dag}_v\succeq\llb{M[x\mapsto a]^\dag}\)
    2. If \(M,N\) are meta-expressions, \(x\notin FV(N)\), no free occurrence of \(x\) in \(M\) occurs
       under a \lambda, and \(\llb{N^\dag}_v\downarrow\), then \(\llb{((\lambda x.M)N)^\dag}_v\succeq\llb{M[x\mapsto N]^\dag}_v\)
    #+END_proposition

    #+BEGIN_proof
    Longley's PhD thesis
    #+END_proof

    From now on, we will not need to distinguish formally between meta-expressions and the
    applicative expressions they denote. For the remainder of this chapter we shall use the \(\lambda^*\)
    notation for such (meta-)expressions, retaining the asterisk as a reminder that the usual rules
    of \lambda-calculus are not always valid.
*** Pairing
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. A *type world* is simply a set \(\sfT\) of *type names* \sigma, optionally endowed with any or
       all of the following:
       1. a *fixing map*, assigning a set \(\sfT[\sigma]\) to certain type names \(\sigma\in\sfT\)
       2. a *product structure*, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\times\tau\)
       3. an *arrow structure*, consisting of a total binary operation \((\sigma,\tau)\mapsto\sigma\to\tau\)
    2. A *computability model over* a type world \(\sfT\) is a computability model \(\bC\) with index
       set \(\sfT\) (so that \(\abs{\bC}=\{\bC(\sigma)\mid\sigma\in\sfT\}\)) subject to the following conventions
       1. If \(\sfT\) has a fixing map, then \(\bC(\sigma)=T[\sigma]\) whenever \(\sfT(\sigma)\) is defined
       2. If \(\sfT\) has a product structure, then \(\bC\) has weak products and for any \(\sigma,\tau\in\sfT\)
          we have \(\bC(\sigma\times\tau)=\bC(\sigma)\bowtie\bC(\tau)\)
       3. If \(\sfT\) has an arrow structure, then \(\bC\) is a higher-order model and for
          any \(\sigma,\tau\in\sfT\) we have \(\bC(\sigma\to\tau)=\bC(\sigma)\Rightarrow\bC(\tau)\)
       4. If \(\sfT\) has both a product and an arrow structure, then \(\bC\) is weakly cartesian closed
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    There is a canonical bijection between higher-order models and relative TPCAs
    #+END_theorem

    Let \(\bA\) be a relative TPCA (which is combinatory complete) over a type world \(\sfT\) with arrow structure, and suppose
    that \(\bA\) (considered as a higher-order model) has weak products, inducing a product
    structure \(\times\) on \(\sfT\). This means that for any \(\sigma,\tau\in\sfT\) there are elements
    \begin{equation*}
    fst\in\bA^\sharp((\sigma\times\tau)\to\sigma),\quad snd\in\bA^\sharp((\sigma\times\tau)\to\tau)
    \end{equation*}
    And for each \(\sigma,\tau\in\sfT\) a *paring* operation
    \begin{equation*}
    pair\in\bA^\sharp(\sigma\to\tau\to(\sigma\times\tau))
    \end{equation*}
    s.t.
    \begin{equation*}
    \forall a\in\bA^\circ(\sigma),b\in\bA^\circ(\tau).\;fst\cdot(pair\cdot a\cdot b)=a\wedge snd\cdot(pair\cdot a\cdot b)=b
    \end{equation*}

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    A higher-order model with weak products has pairing iff it is weakly cartesian closed
    #+END_proposition

    #+ATTR_LATEX: :options [\ref{3.1.14}]
    #+BEGIN_lemma
    Suppose \(m,n>0\). Given
       \begin{gather*}
       f_j\in(A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow B_j)^\sharp,\quad(j=0,\dots,n-1),\\
       g\in(B_0\Rightarrow\dots\Rightarrow B_{n-1}\Rightarrow C)^\sharp
       \end{gather*}
       there exists \(h\in (A_0\Rightarrow\dots\Rightarrow A_{m-1}\Rightarrow C)^\sharp\) s.t.
       \begin{equation*}
       \forall a_0,\dots,a_{m-1}.h\cdot a_0\cdot\dots\cdot a_{m-1}\simeq g\cdot(f_0\cdot a_0\cdot\dots\cdot a_{m-1})\cdot\dots\cdot(f_{n-1}\cdot a_0\cdot\dots\cdot a_{m-1})
       \end{equation*}
    #+END_lemma

    #+BEGIN_proof
    The binary partial functions representable in \(\bA^\sharp((\rho\times\sigma)\to\tau)\) are exactly those representable
    in \(\bA^\sharp(\rho\to\sigma\to\tau)\)

    Given \(f\in\bA^\sharp((\rho\times\sigma)\to\tau)\), by Proposition ref:3.1.14, we have \(h\in\bA^\sharp(\rho\to\sigma\to\tau)\) where
    \begin{equation*}
    \forall a,b.\; h\cdot a\cdot b\simeq f\cdot(pair\;\cdot a\cdot b)
    \end{equation*}

    Given \(f\in\bA^\sharp(\rho\to\sigma\to\tau)\), by the same Proposition, we have \(h\in\bA^\sharp((\rho\times\sigma)\to\tau)\) where
    \begin{equation*}
    \forall a,b.\; h\cdot c\simeq f\cdot(fst\cdot c)\cdot(snd\cdot c)
    \end{equation*}
    #+END_proof

     Henceforth we shall generally work with pair in preference to the ‘external’ pairing of
     operations, and will write \(pair\cdot a\cdot b\) when there is no
     danger of confusion.

     In untyped models, pairing is automatic
     \begin{equation*}
    pair=\lambda^*xyz.zxy,\quad fst=\lambda^*p.p(\lambda^*xy.x),\quad snd=\lambda^*p.p(\lambda^*xy.y)
     \end{equation*}
*** Booleans
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A model \(\bA\) has *booleans* if for some type \(\ttB\) there exist elements
    \begin{align*}
    \TT,\FF&\in\bA^\sharp(\ttB)\\
    \IF_\sigma&\in\bA(\ttB,\sigma,\sigma\to\sigma)\text{ for each }\sigma
    \end{align*}
    s.t. for all \(x,y\in\bA^\circ(\sigma)\) we have
    \begin{equation*}
    \IF_\sigma\cdot\TT\cdot x\cdot y=x,\quad\IF_\sigma\cdot\FF\cdot x\cdot y=y
    \end{equation*}
    Note that \(\TT,\FF\) need not be the sole element of \(\bA^\sharp(\bB)\)
    #+END_definition

    Alternatively, we may define a notion of having booleans in the setting of computability
    model \(\bC\) with weak products: replace \(\IF_\sigma\) with \(\IF'_\sigma\in\bC[\B\times\sigma\times\sigma,\sigma]\). In a TPCA with
    products and pairing the two definitions coincide

    In untyped models, the existence of booleans is automatic: \(\TT=\lambda^*xy.x\), \(\FF=\lambda^*xy.y\)
    and \(\IF=\lambda^*zxy.zxy\)

    Obviously, the value of an expression \(\IF_\sigma\cdot b\cdot e\cdot e'\) cannot be defined unless the values of
    both \(e\) and \(e'\) are defined. However, there is a useful trick that allows us to build conditional
    expressions whose definedness requires only that the chosen branch of the conditional is
    defined. This trick is specific to the higher-order setting, and is known as *strong definition
    by cases*:

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    Suppose \(\bA\) has booleans as above. Given applicative expressions \(e,e':\sigma\) there is an
    applicative expression \((e\mid e'):\ttB\to\sigma\) s.t. for any valuation \(v\) covering \(V(e)\)
    and \(V(e')\) we have
    \begin{equation*}
    \llb{(e\mid e')}_v\downarrow,\quad\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v,\quad
    \llb{(e\mid e')\cdot\FF}_v\succeq\llb{e'}_v
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    Let \rho be any type s.t. \(\bA^\circ(\rho)\) is inhabited by some element \(a\), and define
    \begin{equation*}
    (e\mid e')=\lambda^*z^{\ttB}\cdot(\IF_\sigma z(\lambda^*r^\rho.e)(\lambda^*r^\rho.e')c_a)
    \end{equation*}
    where \(z,r\) are fresh variables

    \(\llb{(e\mid e')}_v\downarrow\)  since by lax combinatory completeness

    \(\llb{(e\mid e')\cdot\TT}_v\succeq\llb{e}_v\) by ref:3.5.5
    #+END_proof

    The expressions \(\lambda^*r.e\), \(\lambda^*r.e'\) in the above proof are known as *suspensions* or *thunks*: the idea is
    that \(\llb{\lambda^*r.e}_v\) is guaranteed to be defined, but the actual evaluation of \(e_v\) (which may be
    undefined) is ‘suspended’ until the argument \(c_a\) is supplied.
*** Numerals
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A model \(\bA\) has *numerals* if for some type \(\ttN\) there exist
    \begin{align*}
    \hat{0},\hat{1},\hat{2},\dots&\in\bA^\sharp(\ttN)\\
    suc&\in\bA^\sharp(\ttN\to\ttN)
    \end{align*}
    and for any \(x\in\bA^\sharp(\sigma)\) and \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) an element
    \begin{equation*}
    Rec_\sigma(x,f)\in\bA^\sharp(\ttN\to\sigma)
    \end{equation*}
    s.t. for all \(x\in\bA^\sharp(\sigma)\), \(f\in\bA^\sharp(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
    \begin{align*}
    suc\cdot\hatn&=\what{n+1}\\
    Rec_\sigma(x,f)\cdot\hat{0}&=x\\
    Rec_\sigma(x,f)\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(Rec_\sigma(x,f)\cdot\hatn)
    \end{align*}
    #+END_definition

    The above definition has the advantage that it naturally adapts to the setting of a
    computability model C with products: just replace the types of \(f\) and \(Rec_\sigma(x,f)\) above
    with \(\bC[\ttN\times\sigma,\sigma]\) and \(\bC[\ttN,\sigma]\) respectively.

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    A model \(\bA\) has numerals iff it has elements \(\hatn\), \(suc\) as above and
    \begin{equation*}
    rec_\sigma\in\bA^\sharp(\sigma\to(\ttN\to\sigma\to\sigma)\to\ttN\to\sigma)\quad\text{for each }\sigma
    \end{equation*}
    s.t. for all \(x\in\bA^\circ(\sigma)\), \(f\in\bA^\circ(\ttN\to\sigma\to\sigma)\) and \(n\in\N\) we have
    \begin{align*}
    suc\cdot\hatn&=\what{n+1}\\
    rec_\sigma\cdot x\cdot f\cdot\hat{0}&=x\\
    rec_\sigma\cdot x\cdot f\cdot\what{n+1}&\succeq f\cdot\hatn\cdot(rec_\sigma\cdot x\cdot f\cdot\hatn)
    \end{align*}
    #+END_proposition

    #+BEGIN_proof
    \(\Leftarrow\): Let \(Rec_\sigma(x,f)=rec_\sigma\cdot x\cdot f\)

    \(\Rightarrow\): define
    \begin{equation*}
    rec_\sigma=Rec_{\sigma\to(\ttN\to\sigma\to\sigma)\to\sigma}(\lambda^*xf.x,\lambda^*nr.\lambda^*xf.fn(rxf))
    \end{equation*}
    ?
    #+END_proof

    #+BEGIN_exercise
    Show that \(\bA\) has numerals, then \(\bA\) has booleans
    #+END_exercise

    #+BEGIN_proof
    \(Rec_\sigma(x,f)=x\), where \(x=\lambda xy.y\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.3.13
    Every untyped model has numerals
    #+END_proposition

    #+BEGIN_proof
    Using the encodings for pairings and booleans given above, we may define the *Curry
    numerals* \(\hatn\) in any untyped models as follows:
    \begin{equation*}
    \hat{0}=\la\TT,\TT\ra,\quad\what{n+1}=\la\FF,\hatn\ra
    \end{equation*}
    and \(suc=\lambda^*x.\la\FF,x\ra\). We also have elements for the zero testing and predecessor operations:
    take \(iszero=fst\) and \(pre=\lambda^*x.\IF(iszero\;x)\hat{0}(snd\;x)\)
    #+END_proof

    In any model with numerals, a rich class of functions \(\N^r\to\N\) is representable. For example, the
    (first-order) primitive recursive functions on \(\N\)

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.3.14
    For any primitive recursive \(f:\N^r\to\N\) there is an applicative expression \(e_f:\N^{(r)}\to\N\)
    (involving constants 0, \(suc\), \(rec_{\ttN}\)) s.t. in any model \((\bA^\circ;\bA^\sharp)\) with numerals
    we have \(\llb{e_f}_v\in\bA^\sharp\) (where \(v\) is the obvious valuation of the constants) and
    \begin{equation*}
    \forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\hatn_{r-1}=\hatm
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof

    #+END_proof
*** Recursion and Minimization
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. A total model \(\bA\) *has general recursion*, or *has fixed points*, if for every
       element \(f\in\bA^\sharp(\rho\to\rho)\) there is an element \(Fix_\rho(f)\in\bA^\sharp(\rho)\) s.t. \(Fix_\rho(f)=f\cdot Fix_\rho(f)\)
    2. An arbitrary model \(\bA\) *has guarded recursion*, or *guarded fixed points*, if for every
       element \(f\in\bA^\sharp(\rho\to\rho)\) where \(\rho=\sigma\to\tau\) there is an element \(GFix_\rho(f)\in\bA^\sharp(\rho)\)
       s.t. \(GFix_\rho(f)\cdot x\succeq f\cdot GFix_\rho(f)\cdot x\) for all \(x\in\bA^\circ(\sigma)\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    1. A total model \(\bA\) has general recursion iff for every type \rho there is an
       element \(Y_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) we have
       \begin{equation*}
       Y_\rho\cdot f=f\cdot(Y_\rho\cdot f)
       \end{equation*}
    2. \(\bA\) has guarded recursion iff for every type \(\rho=\sigma\to\tau\) there is an
       element \(Z_\rho\in\bA^\sharp((\rho\to\rho)\to\rho)\) s.t. for all \(f\in\bA^\circ(\rho\to\rho)\) and \(x\in\bA^\circ(\sigma)\) we have
       \begin{equation*}
       Z_\rho\cdot f\downarrow,\quad Z_\rho\cdot f\cdot x\succeq f\cdot(Z_\rho\cdot f)\cdot x
       \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    Define
    \begin{equation*}
    Y_\rho=Fix_{(\rho\to\rho)\to\rho}(\lambda^*y.\lambda^*f.f(yf)),\quad Z_\rho=GFix_{(\rho\to\rho)\to\rho}(\lambda^*z.\lambda^*fx.f(zf)x)
    \end{equation*}
    #+END_proof

    Not all models of interest possess such recursion operators. Clearly, if \(\bA\) is a *total* model
    with \(\bA(\ttN)=\N\) a type of numerals as above, then \(\bA\) cannot have general or even guarded
    recursion: if \(\rho=\ttN\to\ttN\)  and \(f=\lambda^*gx.suc(gx)\) then we would
    have \(Z\cdot f\cdot\hatn=suc\cdot Z\cdot f\cdot\hatn\), which is impossible. However, many models
    with \(\bA(\ttN)=\N_\bot\) will have general recursion

    Any *untyped* total model has general recursion, since we may take
    \begin{equation*}
    W=\lambda^*wf.f(wwf),\quad Y=WW
    \end{equation*}
    (This element \(Y\) is known as the *Turing fixed point combinator*). Likewise, every untyped
    model, total or not, has guarded recursion, since we may take
    \begin{equation*}
    V=\lambda^*vfx.f(vvf)x,\quad Z=VV
    \end{equation*}

    Note in passing that Kleene’s *second recursion theorem* from classical computability theory is
    tantamount to the existence of a guarded recursion operator in \(K_1\)

    We can now prove ref:3.3.13. In any untyped model, let \(Z\) be a guarded recursion operator,
    define
    \begin{equation*}
    R=\lambda^*rxfm.\IF(iszero\;m)(kx)(\lambda^*y.f(pre\;m))(rxf(pre\; m)\hat{0})
    \end{equation*}
    and take \(rec=\lambda^*xfm.(ZR)xfmi\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A model \(\bA\) with numerals *has minimization* if it contains an
    element \(min\in\bA^\sharp((\ttN\to\ttN)\to\ttN)\) s.t. whenever \(\hatg\in\bA^\circ(\ttN\to\ttN)\) represents some
    total \(g:\N\to\N\) and \(m\) is the least number s.t. \(g(m)=0\), we have \(min\cdot\hatg=\hatm\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.3.19
    There is an applicative expression Min involving constants \(\hat{0}\), suc, iszero, if
    and \(Z\) s.t. in any model with numerals and guarded recursion, \(\llb{Min}_v\) is a
    minimization operator
    #+END_proposition

    #+BEGIN_proof
    Take \(Min=Z(\lambda^*M.\lambda^*g.\IF(iszero(g\;\hat{0}))\hat{0}(M(\lambda^*n.g(suc\;n))))\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    label:3.3.20
    For any partial computable \(f:\N^r\rhu\N\) there is an applicative
    expression \(e_f:\ttN^{(r)}\to\ttN\) (involving constants 0, suc, \(rec_{\ttN}\), min) s.t. in any
    model \(\bA\) with numerals and minimization we have \(\llb{e_f}_v\in\bA^\sharp\) (with the obvious
    valuation \(v\)) and
    \begin{equation*}
    \forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\dots\cdot\hatn_{r-1}=\hatm
    \end{equation*}
    #+END_proposition

    #+BEGIN_proof
    Since our definition of minimization refers only to total functions \(g:\N\to\N\), we appeal to the
    /Kleene normal form/ theorem: there are primitive recursive functions \(T:\N^{r+2}\to\N\) and \(U:\N\to\N\)
    such that any partial computable \(f\) has an ‘index’ \(e\in\N\) such
    that \(f(\barn)\simeq U(\mu y.T(e,\barn,y)=0)\)
    for all \(\barn\). Using this, the result follows easily from Propositions ref:3.3.14 and ref:3.3.19.
    #+END_proof
*** The Category of Assemblies
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(\bC\) be a lax computability model over \(T\). The *category of assemblies over* \(\bC\),
    written \(\Asm(\bC)\) is defined as follows:
    * Objects \(X\) are triples \((\abs{X},\rho_X,\Vdash_X)\) where \(\abs{X}\) is a set, \(\rho_X\in T\)
      names some type, and \(\Vdash_X\subseteq\bC(\rho_X)\times\abs{X}\) is a relation
      s.t. \(\forall x\in\abs{X}.\exists a\in\bC(\rho_X).a\Vdash_Xx\) (The formula \(a\Vdash_Xx\) may be read as '\(a\)
      *realizes* \(x\)')
    * A morphism \(f:X\to Y\) is a function \(f:\abs{X}\to\abs{Y}\) that is *tracked* by
      some \(\barf\in\bC[\rho_X,\rho_Y]\), in the sense that for any \(x\in\abs{X}\) and \(a\in\bC(\rho_X)\) we have
      \begin{equation*}
      a\Vdash_Xx\Rightarrow\barf(a)\Vdash_Yf(x)
      \end{equation*}


    An assembly \(X\) is called *modest* if \(a\Vdash_Xx\wedge a\Vdash_Xx'\) implies \(x=x'\). We
    write \(\nMod(\bC)\) for the full subcategory of \(\Asm(\bC)\) consisting of modest assemblies
    #+END_definition

    Intuitively, we regard an assembly \(X\) as an "abstract datatype" for which we have a concrete
    implementation on the "machine" \(\bC\). The underlying set \(\abs{X}\) is the set of values of
    the abstract type, and for each \(x\in\abs{X}\), the elements \(a\Vdash_Xx\) are the possible
    machine representations of this abstract value. (Note that an abstract value \(x\) may have many
    possible machine representations \(a\).) The morphisms \(f:X\to Y\) may then be regarded as the
    "computable mappings" between such datatypes

    In the case that \(\bC\) is a lax TPCA \(\bA\), we may also denote the above
    categories \(\Asm(\bA)\), \(\nMod(\bA)\), or by \(\Asm(\bA^\circ;\bA^\sharp)\), \(\nMod(\bA^\circ;\bA^\sharp)\). Note that
    realizers for elements \(x\in\abs{X}\) may be arbitrary elements of \(\bA^\circ(\rho_X)\), whereas a
    morphism \(f:X\to Y\) must be tracked by an element of \(\bA^\sharp(\rho_X\to\rho_Y)\)

    Viewed in this way, all the datatypes we shall typically wish to consider in fact live in the
    subcategory \(\nMod(\bC)\): an abstract data value is uniquely determined by any of its machine
    representations. Note also that if \(Y\) is modest, a morphism \(f:X\to Y\) is completely determined by
    any \(\barf\) that tracks it.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let the category \(\bC\) have binary products. An *exponential* of objects \(B\) and \(C\) consists
    of an object \(C^B\) and an arrow \(\epsilon:C^B\times B\to C\) s.t. for any object \(A\) and
    arrow \(f:A\times B\to C\) there is a unique arrow \(\tilf:A\to C^B\) s.t. \(\epsilon\circ(\tilf\times 1_B)=f\)
    \begin{center}\begin{tikzcd}
    C^B\\
    A\ar[u,"\tilf"']
    \end{tikzcd}\hspace{1cm}\begin{tikzcd}
    C^B\times B\ar[r,"\epsilon"]&C\\
    A\times B\ar[u,"\tilf\times 1_B"]\ar[ur,"f"']
    \end{tikzcd}\end{center}
    #+END_definition


    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    label:3.3.22
    Let \(\bC\) be a lax computability model
    1. If \(\bC\) has a weak terminal, then \(\Asm(\bC)\) has a terminal object 1
    2. If \(\bC\) has weak products, then \(\Asm(\bC)\) has binary cartesian products
    3. If \(\bC\) weakly cartesian closed, then \(\Asm(\bC)\) is cartesian closed
    4. If \(\bC\) has a weak terminal and booleans, \(\Asm(\bC)\) has the co product \(1+1\)
    5. If \(\bC\) has a weak terminal and numerals, \(\Asm(\bC)\) has a natural number object
    #+END_theorem

    #+BEGIN_proof
    1. If \((I,i)\) is a weak terminal, define \(1=(\{i\},I,\Vdash_1=\{(i,i)\})\). Then for any \(X\in\Asm(\bC)\),
       \(f=\Lambda x.i\) is the unique morphism where \(\barf=\Lambda x.i\).
    2. [@2] If \(X\) and \(Y\) are assemblies and \rho is a weak product of \(\rho_X\) and \(\rho_Y\), define
       the assembly \(X\times Y\) by
       \begin{equation*}
       \abs{X\times Y}=\abs{X}\times\abs{Y},\quad\rho_{X\times Y}=\rho,\quad a\Vdash_{X\times Y}(x,y)\text{ iff }
       \pi_X(a)\Vdash_Xx\wedge\pi_Y(a)\Vdash_Yy
       \end{equation*}
    3. If \(X\) and \(Y\) are assemblies, let us say an element \(t\in\bC(\rho_X\to\rho_Y)\) *tracks* a
       function \(f:\abs{X}\to\abs{Y}\) if
       \begin{equation*}
       \forall x\in\abs{X},a\in\bC(\rho_X).\;a\Vdash_Xx\Rightarrow t\cdot_{XY}a\Vdash_Yf(x)
       \end{equation*}
       Now define the assembly \(Y^X\) as follows:
       \begin{align*}
       \abs{Y^X}&=\{f:\abs{X}\to\abs{Y}\mid f\text{ is tracked by some }t\in\bC(\rho_X\to\rho_Y)\}\\
       \rho_{Y^X}&=\rho_X\to\rho_Y\\
       t\Vdash_{Y^X}f&\Leftrightarrow t\text{ tracks }f
       \end{align*}
    #+END_proof

    Theorem ref:3.2.22 also holds with \(\nMod(\bC)\), and the
    inclusion \(\nMod(\bC)\hookrightarrow\Asm(\bC)\) preserves all the relevant structure
** Simulations Between Computability Models
*** Simulations and Transformations
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(\bC\) and \(\bD\) be lax computability models over type worlds \(T,U\) respectively. A
    *simulation* \gamma of \(\bC\) in \(\bD\) (written in \(\gamma:\bC\lrarhd\bD\))
    consist of
    * a mapping \(\sigma\mapsto\gamma\sigma:T\to U\)
    * for each \(\sigma\in T\), a relation \(\Vdash_\sigma^\gamma\subseteq\bD(\gamma\sigma)\times\bC(\sigma)\)
    satisfying the following
    1. For all \(a\in\bC(\sigma)\) there exists \(a'\in\bD(\gamma\sigma)\) s.t. \(a'\Vdash_\sigma^\gamma a\)
    2. Every operation \(f\in\bC[\sigma,\tau]\) is *tracked* by some \(f'\in\bD[\gamma\sigma,\gamma\tau]\), in the sense that
       whenever \(f(a)\downarrow\) and \(a'\Vdash_\sigma^\gamma a\), we have \(f'(a)\Vdash_\tau^\gamma f(a)\)
    #+END_definition

    For any \(\bC\) we have the *identity* simulation \(\id_{\bC}:\bC\lrarhd\bC\) given by \(\id_{\bC}\sigma=\sigma\)
    and \(a'\Vdash_{\sigma}^{\id_{\bC}}a\) iff \(a'=a\)

    Given simulations \(\gamma:\bC\lrarhd\bD\) and \(\delta:\bD\lrarhd\bE\) we have the composite
    simulation \(\delta\circ\gamma:\bC\lrarhd\gamma\bE\) defined by \((\delta\circ\gamma)\sigma=\delta(\gamma\sigma)\) and \(a'\Vdash_\sigma^{\delta\circ\gamma}a\)  iff there
    exists \(a''\in\bD(\gamma\sigma)\) with \(a''\Vdash_\sigma^\gamma a\) and \(a'\Vdash_{\gamma\sigma}^\delta a''\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(\bC\), \(\bD\) be lax computability models and suppose \(\gamma,\delta:\bC\lrarhd\bD\) are simulations. We
    say \gamma is *transformable* to \delta, and write \(\gamma\preceq\delta\), if for each \(\sigma\in\abs{\bC}\) there is an
    operation \(t\in\bD[\gamma\sigma,\delta\sigma]\) s.t.
    \begin{equation*}
    \forall a\in\bC(\sigma),a'\in\bD(\gamma\sigma).a'\Vdash_\sigma^\gamma a\Rightarrow t(a')\Vdash_\sigma^\delta a
    \end{equation*}
    We write \(\gamma\sim\delta\) if both \(\gamma\preceq\delta\) and \(\delta\preceq\gamma\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Models \(\bC,\bD\) are *equivalent* (\(\bC\simeq\bD\)) if there exist simulations \(\gamma:\bC\lrarhd\bD\)
    and \(\delta:\bD\lrarhd\bC\) s.t. \(\delta\circ\gamma\sim\id_{\bC}\) and \(\gamma\circ\delta\sim\id_{\bD}\)
    #+END_definition

    A model is *essentially untyped* if it is equivalent to a model over the singleton type world \(\sfO\)

    #+BEGIN_exercise
    Show that a model \(\bC\) is essentially untyped iff it contains a *universal type*: that is, a
    datatype \(U\) s.t. for each \(A\in\abs{\bC}\) there exists operations \(e\in\bC[A,U]\), \(r\in\bC[U,A]\)
    with \(r(e(a))=a\) for all \(a\in A\)
    #+END_exercise

    #+BEGIN_proof
    \(\Leftarrow\): Let \(\sfO=\{U\}\). For each \(f\in\bC[A,B]\), \(\bD\) contains \(\barf\in\bD[U,U]\) s.t. \(\barf()\)
    Let
    \begin{equation*}
    \bD[U,U]=\{\barf:e[A]\to e[B]:f\in\bC[A,B]\}
    \end{equation*}
    where \(\barf(e(a))=e(f(a))\)

    each \(A\in\abs{\bC}\), let \(\gamma(A)=U\) and define \(a'\Vdash_A^\gamma a\) iff \(a'=e(a)\)
    #+END_proof

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Suppose \(\bC,\bD\) are lax models with weak products and weak terminals \((I,i)\), \((J,j)\)
    respectively. A simulation \(\gamma:\bC\lrarhd\bD\) is *cartesian* if
    1. for each \(\sigma,\tau\in\abs{\bC}\) there exists \(t\in\bD[\gamma\sigma\bowtie\gamma\tau,\gamma(\sigma\bowtie\tau)]\) s.t.
       \begin{gather*}
       \pi_{\gamma\sigma}(d)\Vdash_\sigma^\gamma a\wedge\pi_{\gamma\tau}(d)\Vdash_\tau^\gamma b\Rightarrow\\
       \exists c\in\bC(\sigma\bowtie\tau).\pi_\sigma(c)=a\wedge\pi_\tau(c)=b\wedge t(d)\Vdash_{\sigma\bowtie\tau}^\gamma c
       \end{gather*}
    2. there exists \(u\in\bD[J,\gamma I]\) s.t. \(u(j)\Vdash_I^\gamma i\)

    #+END_definition


    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Let \(\bA\) and \(\bB\) be lax relative TPCAs over the type worlds \(\sfT,\sfU\) respectively. An
    *applicative simulation* \(\gamma:\bA\lrarhd\bB\) consists of
    * a mapping \(\sigma\mapsto\gamma\sigma:\sfT\to\sfU\)
    * for each \(\sigma\in\sfT\), a relation \(\Vdash_\sigma^\gamma\subseteq\bB^\circ(\gamma\sigma)\times\bA^\circ(\sigma)\)
    satisfying the following
    1. For all \(a\in\bA^\circ(\sigma)\) there exists \(b\in\bB^\circ(\gamma\sigma)\) with \(b\Vdash_\sigma^\gamma a\)
    2. For all \(a\in\bA^\sharp(\sigma)\) there exists \(b\in\bB^\sharp(\gamma\sigma)\) with \(b\Vdash_\sigma^\gamma a\)
    3. 'Application in \(\bA\) is effective in \(\bB\)': that is, for each \(\sigma,\tau\in\sfT\), there exists
       some \(r\in\bB^\sharp(\gamma(\sigma\to\tau)\to\gamma\sigma\to\gamma\tau)\), called a *realizer for \gamma at \sigma,\tau*, s.t. for
       all \(f\in\bA^\circ(\sigma\to\tau)\), \(f'\in\bB^\circ(\gamma(\sigma\to\tau))\), \(a\in\bA^\circ(\sigma)\) and \(a'\in\bB^\circ(\gamma\sigma)\) we have
       \begin{equation*}
       f'\Vdash_{\sigma\to\tau}f\wedge a'\Vdash_\sigma a\wedge f\cdot a\downarrow\Rightarrow r\cdot f'\cdot a'\Vdash_\tau f\cdot a
       \end{equation*}
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    Suppose \(\bC\) and \(\bD\) are (lax) weakly cartesian closed models, and suppose \(\bA\) and \(\bB\)
    are the corresponding (lax) relative TPCAs with pairing via the correspondence of Theorem
    ref:3.1.18. Then cartesian simulations \(\bC\lrarhd\bD\) correspond precisely to applicative
    simulations \(\bA\lrarhd\bB\)
    #+END_theorem

    #+BEGIN_proof
    Suppose first that \(\gamma:\bC\lrarhd\bD\) is a cartesian simulation
    1. Definition
    2. Suppose \(a\in\bA^\sharp(\sigma)\) where \(\bA^\circ(\sigma)=A\). Then we may
       find \(g\in\bC[I,A]\) with \(g(i)=a\), where \((I,i)\) is a weak terminal in \(\bC\).
       Take \(g'\in\bD[\gamma I,\gamma A]\) tracking \(g\), and compose it with \(u\in\bD[J,\gamma I]\), we
       obtain \(g''\in\bD[J,\gamma A]\). Then \(g''(j)\in\bB^\sharp(\gamma\sigma)\), and it is easy to see
       that \(g''(j)\Vdash_\sigma^\gamma a\)
    3. Let \(\sigma,\tau\) be any types; then by the definition of weakly cartesian closedness, we
       have \(app_{\sigma\tau}\in\bC[(\sigma\to\tau)\times\sigma,\tau]\) tracked by some \(app_{\sigma\tau}'\in\bD[\gamma((\sigma\to\tau)\times\sigma),\gamma\tau]\). By definition
       of cartesian simulation, we have \(t\in\bD[\gamma(\sigma\to\tau)\times\gamma\sigma,\gamma((\sigma\to\tau)\times\sigma)]\), we have an operation
       \(\bD[\gamma(\sigma\to\tau)\times\gamma\sigma,\gamma\tau]\), and hence an operation \(\bD[\gamma(\sigma\to\tau),\gamma\sigma\to\gamma\tau]\), and then
       an operation \(\bD[J, \gamma(\sigma\to\tau)\to\gamma\sigma\to\gamma\tau]\), and hence
       realizer \(r\in\bB^\sharp(\gamma(\sigma\to\tau)\to\gamma\sigma\to\gamma\tau)\) with the required properties:
       for all \(f\in\bA^\circ(\sigma\to\tau)\), \(f'\in\bB^\circ(\gamma(\sigma\to\tau))\), \(a\in\bA^\circ(\sigma)\), \(a'\in\bB^\circ(\gamma\sigma)\),
       and \(f'\Vdash_{\sigma\to\tau}f\), \(a'\Vdash_\sigma a\), \(f\cdot a\downarrow\), we
       have \(t(f',a')\Vdash_{(\sigma\to\tau)\times\sigma}(f,a)\).
       Then \(app'_{\sigma\tau}(t(f',a'))\Vdash_{\tau}^\gamma app_{\sigma\tau}(f,a)\)


    Conversely, suppose \(\gamma:\bA\lrarhd\bB\) is an applicative simulation. To see that \gamma is a
    simulation \(\bC\lrarhd\bD\), it suffices to show that every operation in \(\bC\) is tracked by one
    in \(\bD\). But given \(f\in\bC[\sigma,\tau]\), we may find a corresponding element \(a\in\bA^\sharp(\sigma\to\tau)\), whence
    some \(a'\in\bB^\sharp(\gamma(\sigma\to\tau))\) with \(a'\Vdash^\gamma_{\sigma\to\tau}a\); by using a realizer \(r\in\bB^\sharp\) for \gamma at \sigma,\tau,
    we have an element \(a''\in\bB^\sharp(\gamma\sigma\to\gamma\tau)\)  and so a corresponding operation \(f'\in\bD[\gamma\sigma,\gamma\tau]\).

    It remains to show that \gamma is cartesian. For any types \sigma,\tau, we have by assumption an element
    \(pair_{\sigma\tau}\in\bA^\sharp(\sigma\to\tau\to\sigma\times\tau)\), yielding some \(p\in\bC[\sigma,\tau\to\sigma\times\tau]\). Since \gamma is a simulation, this is
    tracked by some \(p'\in\bD[\gamma\sigma,\gamma(\tau\to\sigma\times\tau)]\). From the weak product structure in \(\bD\) we may thence
    obtain an operation
    \begin{equation*}
    p''\in\bD[\gamma\sigma\times\gamma\tau,\gamma(\tau\to\sigma\times\tau)\times\gamma\tau]
    \end{equation*}
    and together with a realizer for \gamma at \tau and \(\sigma\times\tau\), this yields an
    operation \(t\in\bD[\gamma\sigma\times\gamma\tau,\gamma(\sigma\times\tau)]\) with the required properties.

    \(i\in\bA^\sharp(I)\), hence there is \(b\in\bB^\sharp(\gamma I)\) with \(b\Vdash_I^\gamma i\). But \(b=u(j)\) for
    some \(u\in\bD[J,\gamma I]\)
    #+END_proof

    The notion of a transformation between simulations carries across immediately to the relative
    TPCA setting: an applicative simulation \(\gamma:\bA\lrarhd\bB\) is transformable to \delta if for each type
    \sigma there exists \(t\in\bB^\sharp(\gamma\sigma\to\delta\sigma)\) s.t. \(a'\Vdash_\sigma^\gamma a\) implies \(t\cdot a'\Vdash_\sigma^\delta a\)

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    Suppose \(\bA\) and \(\bB\) are (lax) relative TPCAs over \(\sfT\) and \(\sfU\) respectively, and
    suppose \(\gamma:\bA\lrarhd\bB\) is an applicative simulation
    1. \gamma is *discrete* if \(b\Vdash^\gamma a\) and \(b\Vdash^\gamma a'\) imply \(a=a'\)
    2. \gamma is *single-valued* if for all \(a\in\bA\) there is exactly one \(b\in\bB\) with \(b\Vdash^\gamma a\). \gamma is
       *projective* if \(\gamma\sim\gamma'\) for some single-valued \(\gamma'\)
    3. If \(\bA\) and \(\bB\) have booleans \(\TT_{\bA}\), \(\FF_{\bA}\) and \(\TT_{\bB}\), \(\FF_{\bB}\)
       respectively, \gamma *respects booleans* if there exists \(q\in\bB^\sharp\) s.t.
       \begin{equation*}
       b\Vdash^\gamma\TT_{\bA}\Rightarrow q\cdot b=\TT_{\bB},\quad b\Vdash^\gamma\FF_{\bA}\Rightarrow q\cdot b=\FF_{\bB}
       \end{equation*}
    4. If \(\bA\) and \(\bB\) have numerals \(\hatn\) and \(\tiln\) respectively, \gamma *respects numerals* if
       there exists \(q\in\bB^\sharp\) s.t. for all \(n\in\N\)
       \begin{equation*}
       b\Vdash^\gamma\hatn\Rightarrow q\cdot b=\tiln
       \end{equation*}
    5. If \(\sfT=\sfU\), we say \gamma is *type-respecting* if \gamma is the identity on types, and moreover:
       * \(\Vdash_\sigma^\gamma=\id_{\sfT[\sigma]}\) whenever \(\sfT\) fixes the interpretation of \sigma
       * Application is itself a realizer for \gamma at each \(\sigma,\tau\): that is,
         \begin{equation*}
         f'\Vdash_{\sigma\to\tau}^\gamma f\wedge a'\Vdash_\sigma^\gamma a\wedge f\cdot a\downarrow\Rightarrow f'\cdot a'\Vdash_\tau^\gamma f\cdot a
         \end{equation*}
       * If \(\sfT\) has product structure, then \(\bA,\bB\) have pairing and
         \begin{align*}
         a'\Vdash_\sigma^\gamma a\wedge b'\Vdash_\tau^\gamma b&\Rightarrow pair\cdot a'\cdot b'\Vdash_{\sigma\times\tau}^\gamma pair\cdot a\cdot b\\
         d'\Vdash_{\sigma\times\tau}^\gamma d&\Rightarrow fst\cdot d'\Vdash_\sigma^\gamma fst\cdot d\wedge snd\cdot d'\Vdash_\sigma^\gamma snd\cdot d
         \end{align*}
    #+END_definition

    #+BEGIN_remark
    Show that if \gamma respects numerals then \gamma respects booleans
    #+END_remark

*** Simulations and Assemblies
    A simulation \(\gamma:\bC\lrarhd\bD\) naturally induces a functor \(\gamma_*:\Asm(\bC)\to\Asm(\bD)\) , capturing the
    evident idea that any datatypes implementable within \(\bC\) must also be implementable in \(\bD\)
    * On objects \(X\), define \(\gamma_*(X)\) by \(\abs{\gamma_*(X)}=\abs{X}\), \(\rho_{\gamma_*(X)}=\gamma\rho_X\)
      and \(b\Vdash_{\gamma_*(X)}x\) iff \(\exists a\in\bC(\rho_X)\), \(a\Vdash_Xx\wedge b\Vdash_{\rho_X}^\gamma a\)
    * On morphisms \(f:X\to Y\), define \(\gamma_*(f)=f\). Note that if \(r\in\bC[\rho_X,\rho_Y]\) tracks \(f\) as a
      morphism in \(\Asm(\bC)\), and \(r'\in\bD[\gamma\rho_X,\gamma\rho_Y]\) tracks \(r\) w.r.t. \gamma, then \(r'\)
      tracks \(f\) as a morphism in \(\Asm(\bC)\)


    Moreover, a transformation \(\xi:\gamma\to\delta\) yields a natural transformation \(\xi_*:\gamma_*\to\delta_*\): just
    take \(\xi_{*X}=\id_{\abs{X}}:\gamma_*(X)\to\delta_*​ (X)\), and note that if \(t\) witnesses \(\gamma\preceq\delta\) at \(X\),
    then \(t\) tracks \(\xi_{*​X}\).

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    1. \gamma respects numerals iff \(\gamma_*\) preserves the natural number object
    #+END_definition

** Examples of Simulations and Transformations
    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Suppose \(\bC\) is any (lax) computability model with weak products, and consider the following
    variation on the 'product completion' construction described in the proof of Theorem ref:3.1.15.
    Let \(\bC^\times\) be the computability model whose datatypes are sets \(A_0\times\dots\times A_{m-1}\)
    where \(A_i\in\abs{\bC}\), and whose operations \(f\in\bC^\times[A_0\times\dots\times A_{m-1},B_0\times\dots\times B_{n-1}]\) are those
    partial functions represented by some operation in \(\bC[A_0\bowtie\dots\bowtie A_{m-1},B_0\bowtie\dots\bowtie B_{n-1}]\). Clearly
    the inclusion \(\bC\hookrightarrow\bC^\times\) and \(\bC^\times\to\bC\) sending \(A_0\times\dots A_{m-1}\) to \(A_0\bowtie\dots\bowtie A_{m-1}\) are
    simulations. Moreover, they constitute an equivalence \(\bC\simeq\bC^\times\). This shows that every strict
    (lax) computability model with weak products is equivalent to one with standard products
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_proposition
    For any partial computable \(f:\N^r\rhu\N\) there is an applicative
    expression \(e_f:\ttN^{(r)}\to\ttN\) (involving constants 0, suc, \(rec_{\ttN}\), min) s.t. in any
    model \(\bA\) with numerals and minimization we have \(\llb{e_f}_v\in\bA^\sharp\) (with the obvious
    valuation \(v\)) and
    \begin{equation*}
    \forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\dots\cdot\hatn_{r-1}=\hatm
    \end{equation*}
    #+END_proposition

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    Let \(\bA\) be any untyped (lax relative) PCA, or more generally any model with
    numerals \(\bar{0},\bar{1},\dots\) and minimization. We may then define a single-valued applicative
    simulation \(\kappa:K_1\lrarhd\bA\) by taking \(a\Vdash^\kappa n\) iff \(a=\hat{n}\). Condition 3 is
    satisfied because the application operation \(\cdot:\N\times\N\rhu\N\) of \(K_1\) is representable by an
    element of \(\bA^\sharp\)

    Model with single datatype \(\N\) and whose operations \(\N\rightharpoonup\N\) are precisely the
    Turing-computable partial functions. \(K_1\)is weakly cartesian closed.

    For any partial computable \(f:\N^r\rhu\N\) there is an applicative
    expression \(e_f:\ttN^{(r)}\to\ttN\) (involving constants 0, suc, \(rec_{\ttN}\), min) s.t. in any
    model \(\bA\) with numerals and minimization we have \(\llb{e_f}_v\in\bA^\sharp\) (with the obvious
    valuation \(v\)) and
    \begin{equation*}
    \forall n_0,\dots,n_{r-1},m. f(n_0,\dots,n_{r-1})=m\Rightarrow\llb{e_f}_v\cdot\hatn_0\cdot\dots\cdot\hatn_{r-1}=\hatm
    \end{equation*}

    In particular models, many choices of numerals may be available. For instance, if \(\bA=\bA^\sharp=\Lambda/\sim\),
    then besides the /Curry numerals/, we also have the *Church numerals* \(\tiln=\lambda f.\lambda x.f^nx\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    The model \(\Lambda^0/=\beta\) consisting of closed \lambda-terms modulo \beta-equivalence. Let \(\ceil{-}\) be
    any effective *Gödel numbering* of \lambda-terms as natural numbers, and define \(\gamma:\Lambda^0/=_\beta\lrarhd K_1\) by
    \begin{equation*}
    m\Vdash^\gamma[M]\quad\text{ iff }\quad m=\ceil{M'}\text{ for some }M'=_\beta M
    \end{equation*}
    Justaposition of \lambda-terms is tracked by a computable function \((\ceil{M},\ceil{N})\mapsto\ceil{MN}\)
    at the level of Gödel numbers. Thus \gamma is applicative

    We have transformations \(\id_{K_1}\preceq\gamma\circ\kappa\) and \(\gamma\circ\kappa\preceq\id_{K_1}\); these correspond to the
    observation that the 'encoding' and 'decoding' mappings \(n\mapsto\ceil{\hatn}\)
    and \(\ceil{\hatn}\mapsto n\)
    are computable. Also there is a term \(P\in\Lambda^0\) s.t. \(P(\what{\ceil{M}})=_\beta M\) for any \(M\in\Lambda^0\) by
    Kleene's enumeration theorem, therefore \(\kappa\circ\gamma\preceq\id_{\Lambda^0/=_\beta}\)

    However we don't have \(\id_{\Lambda^0/=_\beta}\preceq\kappa\circ\gamma\)

    It can be easily shown that \(K_1\) is not equivalent to \(\Lambda^0/=_\beta\). Let us say a relative
    PCA \(\bA\) has *decidable equality* if there is an element \(q\in\bA^\sharp\) s.t.
    \begin{equation*}
    q\cdot x\cdot y=
    \begin{cases}
    \TT&x=y\\
    \FF&\text{otherwise}
    \end{cases}
    \end{equation*}
    Clearly \(K_1\) has decidable equality, and it is easy t see that if \(\bA\simeq\bB\) then \(\bA\) has
    decidable equality iff \(\bB\) does. However, if a total relative PCA \(\bA\) were to contain such
    an element, we could define \(v=Y(q\;\FF)\) so that \(v=q\;\FF\;v\) which would yield a
    contradiction

    Here \(Y\;f=f(Y\; f)\)
    #+END_examplle



    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    We may translate System T terms \(M\) to PCF terms \(M^\theta\) simply by replacing all
    constants \(rec_\sigma\) by suitable implementations of these recursors in PCF

    In any untyped model, let \(Z\) be a guarded recursion operator,
    define
    \begin{equation*}
    R=\lambda rxfm.\IF(iszero\;m)(kx)(\lambda y.f(pre\;m))(rxf(pre\; m)\hat{0})
    \end{equation*}
    and take \(rec=\lambda xfm.(ZR)xfmi\).

    Such a translation induces a type-respecting applicative
    simulation \(\theta:\tT^0/=_{op}\lrarhd \PCF^0/=_{op}\). This simulation is single-valued
    as \(M=_{op}M'\Rightarrow M^\theta=_{op}M'^\theta\). It is easy to see that \theta respects numerals
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    We may also translate PCF into the untyped \lambda-calculus. One such translation \phi may be defined on
    constants as follows. We write \(\la M,N\ra\) for \(pair\;M\;N\) and
    define \(\hat{0}=\la\lambda xy.x,\lambda xy.x\) and \(\what{n+1}=\la\lambda xy.y,\hatn\ra\)
    \begin{align*}
    \hatn^\phi&=\hatn\\
    suc^\phi&=\lambda z.\la\lambda xy.y,z\ra\\
    pre^\phi&=\lambda z.(fst\;z)\hat{0}(snd\;z)\\
    ifzero^\phi&=fst\\
    Y_\sigma^\phi&=(\lambda xy.y(xxy))(\lambda xy.y(xxy))
    \end{align*}
    This induces an applicative simulation \(\phi:\PCF^0/=_{op}\lrarhd\Lambda^0/=_\beta\) respecting numerals.
    Moreover if \(M=_{op}M'\) then \(M^\phi=_\beta M'^\phi\)
    #+END_examplle

    #+ATTR_LATEX: :options [Interpretations of System \(T\)]
    #+BEGIN_examplle
    Let \(\bA\) be any total relative TPCA with numerals \(\hat{0},\hat{1},\dots\) of type \(\ttN\), and
    associated operations \(suc\), \(rec_\sigma\). To any closed term \(M:\sigma\) in Gödel's System \(T\), we
    may associate an element \(\llb{M}\in\bA^\sharp(\sigma)\) as follows: replace each occurrence of \lambda by \(\lambda^*\)
    to obtain a meta-expression \(M^*\), then expand \(M^*\) to an applicative expression \(M^\dag\)
    and evaluate it in \(\bA\), interpreting the constants \(\hat{0}\), \(suc\), \(rec_\sigma\) in the
    obvious way

    Clearly \(\llb{MN}=\llb{M}\cdot\llb{N}\) and if \(M\rightsquigarrow M'\) then \(\llb{M}=\llb{M'}\). We therefore
    obtain a type-respecting simulation \(\llb{-}:T^0/=_{op}\lrarhd\bA\)

    Now suppose \(\gamma:\bA\lrarhd\bB\) is a type- and numeral-respecting applicative simulation between
    total models with numerals. By the above, we have applicative simulations
    \(\llb{-}_{\bA}:\tT^0/=_{op}\lrarhd\bA\) and \(\llb{-}_{\bB}:\tT^0/=_{op}\lrarhd\bB\), but it nee not in
    general be the case that \(\gamma\circ\llb{-}_{\bA}\sim\llb{-}_{\bB}\). This shows that a model \(\bB\) may in
    general admit several inequivalent applicative simulations of \(\tT^0/=_{op}\)
    #+END_examplle

    #+ATTR_LATEX: :options [Interpretations of PCF]
    #+BEGIN_examplle
    Let \(\bA\) be any strict relative TPCA with numerals and general recursion. Since \(\bA\) contains
    elements playing playing the role of the PCF constants \(\hatn\), \(suc\), \(pre\), \(ifzero\)
    and \(Y_\sigma\), we may translate closed PCF terms \(M:\sigma\) into expressions \(\tilM:\sigma\) over \(A\)
    by simply replacing \lambda with \(\lambda^*\) and expanding. Note that \(M=_{op}M'\)
    implies \(\llb{\tilM}\simeq\llb{\tilM'}\) in \(\bA\). This does not itself give us an applicative
    simulation \(\PCF^0/=_{op}\lrarhd\bA\) since \(\llb{\tilM}\) may sometimes be undefined. However,
    we may obtain such a simulation \(\theta_{\bA}\) via a suspension trick: let \(\theta_{\bA}\sigma=\N\to\sigma\) for each \sigma,
    and take \(a\Vdash_\sigma^{\theta_{\bA}}[M]\) iff \(a\cdot\hat{0}\simeq\llb{\tilM}\). (For example, we
    have \(\llb{\lambda^*u.\tilM}\Vdash[M]\) for any \(M\)) \(\theta_{\bA}\) is an applicative morphism, being
    realized at each \sigma, \tau by \(\lambda^*fxu.(fu)(xu)\)
    #+END_examplle
*** Effective and Continuous Models
    It is natural to want to identify a class of computability models that are genuinely
    ‘effective’, in the sense that their data can be represented in some reasonable finitary way
    and their operations are ultimately implementable on a Turing machine.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    An *effective (relative) TPCA* is a (relative) TPCA \(\bA\) with numerals equipped with a
    numeral-respecting applicative simulation \(\gamma:\bA\lrarhd K_1\)
    #+END_definition

    Syntactic models in general, such as \(\Lambda^0/\sim\) is effective TPCAs: The simulation \gamma is given by a
    Gödel numbering of syntactic terms.

    We may define \(\gamma:K_2^{\eff}\lrarhd K_1\) by setting \(m\Vdash^\gamma f\) iff \(\forall n.m\cdot n=f(n)\)

    #+ATTR_LATEX: :options []
    #+BEGIN_examplle
    The following shows what can happen if the numeral-respecting condition in definition is
    omitted. Let \(f:\N\to\N\) be some fixed non-computable function. The definition of \(K_1\) may be
    relativized to \(f\) as follows: let \(T_0',T_1',\dots\) be a sensibly chosen enumeration of all
    Turing machines equipped with an /oracle/ for \(f\), so that a computation may ask for the value
    of some \(f(m)\) as a single step. Now take \(e\cdot^fn\) to be the result of applying \(T_e'\) to the
    input \(n\), and let \(K_1^f=(\N,\cdot^f)\). The proof that \(K_1\) is a PCA readily carries over
    to \(K_1^f\)

    There is an applicative simulation \(\gamma:K_1^f\lrarhd K_1\): we may take \(m\Vdash^\gamma n\) iff \(m\cdot^f0=n\)
    #+END_examplle

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *continuous (relative) TPCA* is a (relative) TPCA \(\bA\) with numerals equipped with a
    numeral-respecting applicative simulation \(\gamma:\bA\lrarhd K_2\)
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A continuous TPCA \((\bA,\gamma)\) is *full continuous* if the following hold:
    1. For every \(f:\N\to\N\) there is some \(a\in\bA(\ttN\to\ttN)\) that represents \(f\)
    2. Moreover, a realizer for some such \(a\) may be computed from \(f\) within \(K_2\) - that is,
       there exists \(h\in K_2\) s.t. for all \(f\in\N^{\N}\) we have
    #+END_definition
