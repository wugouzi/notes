#+title: Algorithms for Concurrent Systems

#+AUTHOR: Rachid Geurraoui & Petr Kuznetsov
#+EXPORT_FILE_NAME: ../latex/AlgorithmsForConcurrentSystems/AlgorithmsForConcurrentSystems.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \makeindex
* Linearizability
** Introduction
    Linearizability is a correctness metric for shared object implementations. The notion of /correctness/, as
    captured by linearizability, is defined with respect to how the object is expected to
    react when accessed sequentially, i.e., the object’s *sequential specification*.
** The Players
*** Processes
    We consider a system that consists of a finite set of \(n\) processes,
    denoted \(p_1,\dots,p_n\). Besides accessing local variables, processes can
    execute operations on *shared objects*. Through these objects, the processes
    synchronize their computations.

    The execution of an operation *op* on an object \(X\) by a process \(p_i\) is
    modeled by two events, specifically, the event
    denoted \(inv[X.op\text{ by }p_i]\) that occurs when \(p_i\) invokes the
    operation (*invocation event*), and the event
    denoted \(resp[X.op.res\text{ by }p_i]\) that occurss when the operation
    terminates (*response event*).

    Each interaction between a process and an object is represented by a
    /visible event/.
*** Objects
    An object has a unique *identity* and a *type*.

    We define an object type by
    1. the set of possible states the objects of that type can take, including the /initial/ type.
    2. a set of operations through which the state of the objects of that type can be manipulated
    3. a *sequential specification* that describes, for each operation of the type and every state, the effect
       this operation produces when it is applied to the object in that state
*** Histories
    The interaction between processes and objects is modeled as a totally ordered set of events \(H\), and is
    called a *history*. The total order relation on \(H\), denoted \(<_H\), abstracts out the real-time order in
    which the events actually occur.

    A *local* history of \(p_i\), denoted \(H|_{p_i}\) is a projection of \(H\) on process \(p_i\): the
    subsequence \(H\) consisting of the events generated by \(p_i\). Two histories \(H\) and \(H'\) are
    *equivalent* if they have the same local histories.

    As we consider sequential process, we focus on histories \(H\) s.t. for each process \(p_i\), \(H|_{p_i}\)
    is sequential: The history starts with an invocation, followed by a matching response, followed by another
    invocation, etc. We say in this case that the global history \(H\) is *well-formed*.

    An operation is *complete* in a history if the history includes both the event corresponding to the
    invocation of the operation and its response. If the history contains only the invocation of an operation
    but no matching response, we say that the operation is *pending* in that history. A history without pending
    operations is said to be *complete*.

    Let \(op=X.op1()\) by \(p_i\) and \(op'=Y.op1()\) by \(p_j\) be two operations. Define
    \begin{equation*}
    (op\to_Hop'):=(resp[op]<_Hinv[op'])
    \end{equation*}
    Two operations \(op\) and \(op'\) are said to *overlap* in a history \(H\) is
    neither \(resp[op]<_Hinv[op']\) nor \(resp[op']<_Hinv[op]\).
*** Sequential Histories
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *sequential history* is one of which the first event is an invocation, then
    1. each invocation event, except possibly the last, is immediately followed by the matching response event
    2. each response event, except possibly the last, is immediately followed by an invocation event.
    #+END_definition
*** Legal Histories
    Given a sequential history \(H\) and an object \(X\), \(H|X\) denotes the subsequence of \(H\) made up of
    all the events involving only object \(X\). We say that \(H\) is *legal* if, for each object \(X\) involved
    in \(H\), \(H|X\) belongs to the sequential specification of \(X\).
** Linearizability
*** Complete Histories
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A complete history \(H\) is *linearizable* if there is a history \(L\) s.t.
    1. \(L\) and \(H\) are equivalent
    2. \(L\) is sequential
    3. \(L\) is legal
    4. \(\to_H\subseteq\to_L\)
    #+END_definition

    Such a sequential history \(L\) is called a *linearization* of \(H\) or a *sequential witness* of \(H\).
*** Incomplete Histories and Completeness
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *completion* of a history \(H\) is a complete history obtained from \(H\) as follows: every invocation
    of a pending operation is either removed or completed with a response put at the end of the history. The
    remaining events of \(H\) are left in exactly the same order.
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A history \(H\) is *linearizable* if it has a linearizable completion.
    #+END_definition
*** Linearizability is Non-Blocking
    An interesting feature of linearizability is that it is *non-blocking*. Every pending operation in a
    history \(H\) can be completed, without having to wait for any other operation complete or sacrificing the
    linearizability of the resulting history.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    Let \(H\) be any finite linearizable history and \(inv[op]\) any pending operation invocation in \(H\).
    There is a response \(r=resp[op]\) s.t. \(H\cdot r\) is linearizable
    #+END_theorem

    #+BEGIN_proof
    As \(H\) is incomplete and linearizable, there is a completion of \(H\), \(H'\) that is linearizable,
    i.e., that has a linearization \(L\) of \(H\). If \(L\) contains \(inv[op]\) and its matching
    response \(r\), then \(L\) is also a linearization of \(H\cdot r\). If \(L\) contains neither \(inv[op]\)
    nor \(r\), then \(L'=L\cdot inv[op]\cdot r\) is a linearization of \(H'\cdot inv[op]\cdot r\), which means
    that \(H\) is linearizable.
    #+END_proof
*** Composition
    A property \(P\) is said to be *compositional* (also called *local*) if whenever it holds for each of the
    objects of a set, it holds for the entire set.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A history \(H\) is linearizable iff for each object \(X\) involved in \(H\), \(H|X\) is linearizable
    #+END_definition

    #+BEGIN_proof
    Consider a history \(H\), where for each object \(X\), \(H|X\) has a linearization, denoted \(S_X\),
    let \(\to_X\) denote the total order in \(S_X\) of the operation on \(X\) in \(H\). We show that the
    relation \(\to=\bigcup_X\{\to_X\}\cup\{\to_H\}\) does not induce any cycle. This means that its transitive
    closure is a partial order, and its linear extention \(S\) is a linearization of \(H\).

    Suppose \(\to\) contains a cycle. Since every operation concerns exactly one object, the cycle cannot
    contain fragments of the form \(op_1\to_Xop_2\to_Yop_3\) for \(X\neq Y\). Hence the cycle alternate edges
    of the form \(\to_X\) with edges \(\to_H\).

    Now consider the fragment \(op_1\to_Hop_2\to_Xop_3\to_Hop_4\). Recall that \(\to_X\) is the order of
    operations in \(S_X\), a linearization of \(H|X\). Since \(S_X\) respect real time, we
    have \(op_3\nrightarrow_Xop_2\), i.e., the invocation of \(op_2\) precedes the response of \(op_3\)
    in \(H|X\) and thus in \(H\). Therefore \(op_1\to_Hop_4\), i.e., we can shorten the fragment to one
    edge \(\to_H\). Therefore we get a cycle in \(\to_H\).
    #+END_proof
** The Importance of (Real) Time
    Sequential consistency is a relaxation of linearizability. It only requires that the real-time order is
    preserved if the operations are invoked by the same process. This relaxation of the real-time order is
    called *process-order*.

    Formally, a history \(H\) is *sequentially consistent* if there is a history \(S\) s.t.:
    1. \(H\) and \(S\) are equivalent
    2. \(S\) is sequential and legal.


    A major drawback of sequential consistency is that it is not compositional. Consider
    #+ATTR_LATEX: :width .8\textwidth :float nil
    #+NAME:
    #+CAPTION:Sequential consistency is not compositional
    [[../images/AfCS/1.png]]
** Safety
    A *property* is a set of (finite or infinite) histories. A property \(P\) is a *safety property* if:
    * \(P\) is *prefix-closed*: if \(H\in P\), then for every prefix \(H'\) of \(H\), \(H'\in P\)
    * \(P\) is *limit-closed*: for every infinite sequence \(H_0,H_1,\dots\) of hisotries, where each \(H_i\) is
      a prefix of \(H_{i+1}\) and each \(H_i\in P\), the limit history \(H=\lim_{i\to\infty}H_i\) is in \(P\).

    #+ATTR_LATEX: :options [Kőnig's Lemma]
    #+BEGIN_lemma
    Let \(G\) be an infinite directed graph s.t.
    1. each node of \(G\) has finite outdegree
    2. each vertex of \(G\) reachable from some root vertex of \(G\)
    3. \(G\) has only finitely many roots
    Then \(G\) has an infinite path with no repeated nodes starting from some root.
    #+END_lemma

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    Linearizability is a safety property
    #+END_theorem

    #+BEGIN_proof
    We consider only objects with finite non-determinism: an operation applied to a given object state can
    return only finitely many responses and cause only a finite number of state transitions.

    *Prefix-closedness*: Consider a linearizable history \(H\). Since linearizability is compositional, we can
    assume that \(H\) is a history of operations on a single object \(X\). We show first that any \(H'\),
    prefix of \(H\), is also linearizable w.r.t. \(X\).

    Let \(S\) be any linearization of \(H\). Now we construct a sequential history \(S'\) as follows: we take
    the shorted prefix of \(S\) that contains all complete operations of \(H'\). Since \(S\) contains all
    complete operations of \(H'\), such a prefix of \(S\) exists.

    We claim that \(S'\) is a linearization of \(H'\). We complete \(H'\) by removing operations that do not
    appear in \(S'\) and adding responses to incomplete operations in \(H'\) that are present in \(S'\).
    Let \(\bbar{H'}\) denote the resulting complete history.

    First, complete histories \(S'\) and \(\bbar{H'}\) consist of the same set of operations. By construction,
    every operation in \(\bbar{H'}\) appears in \(S'\). Now suppose, by contradiction, that \(S'\) contains an
    operation \(op\) that does not appear in \(\bbar{H'}\), \(op\) does not appear in \(H'\) either.
    Since \(S'\) is the shortest prefix of \(S\) that contains all complete operations of \(H\), \(op\) cannot
    be the last operation appearing in \(S'\). Otherwise, we could find a shorter prefix of \(S\).
    Furthermore, the last operation in \(S'\) must be complete in \(H'\), we denote this operation by \(op'\).
    Since \(op\) does not appear in \(H'\) and \(op'\) is complete in \(H'\), we have \(op'<_Hop\).
    But \(op<_Sop'\). Hence \(S\) violates the real-time order of \(H\), a contradiction.

    Since \(S'\) is a prefix of a legal history, it is also legal. Also, \(S'\) respect the real-time order
    in \(\bbar{H'}\).

    Consider any local history \(\bbar{H'}|_p\). Recall that we only assume well-formed histories,
    hence \(\bbar{H'}|_p\) is sequential. Since \(S'\) and \(\bbar{H'}\) contain the same set of operations
    and \(S'\) respects the real-time order of \(\bbar{H'}\), we have \(S'|_p=\bbar{H'}|_p\)

    *Limit-closedness*: Consider an infinite sequence of ever-extending linearizable histories \(H_0,H_1,\dots\)
     Our goal is to show that \(H=\lim_{i\to\infty}H_i\) is linearizable. We assume that \(H_0\) is the empty
     history and that each \(H_{i+1}\) is a one-event extension of \(H_i\). Now we construct a directed
     graph \(G=(V,E)\) as follows. Vertices of \(G\) are all tuples \((H_i,S, Q)\),
     where \(i=0,1,\dots,\abs{H}\), \(S\) is any linearization of \(H_i\) that ends with a /complete/ operation
     present in \(H_i\), and \(Q\) is any sequence of object stats that /witness the legality of/ \(S\). Now
     there is a directed edge \((H_i,S,Q),(H_j,S',Q')\) in \(G\) iff \(j=i+1\), \(S\) is a prefix of \(S'\)
     and \(Q\) is a prefix of \(Q'\).

    We use Kőnig's lemma to show that the resulting graph \(G\) contains an infinite
    path \((H_0,S_0),(H_1,S_1),\dots\) and the limit \(\lim_{i\to\infty}S_i\) is a linearization of the
    infinite limit history \(H\).

    First we observe that each non-empty vertex \((H_{i+1},S',Q')\) is connected to some \((H_i,S,Q)\). There
    are two cases to consider:
    * The last operation \(op\) of \(S'\) is a complete operation in \(H_i\). In this case, \(S'\) is also a
      linearization of \(H_i\). Indeed, even if the last event of \(H_{i+1}\) is the invocation of a new
      operation \(op'\), this operation cannot appear in \(S'\): it can only appear before \(op\) in \(S'\)
      violating the real-time order in \(H_{i+1}\). Thus \((H_i,S',Q')\) is a vertex in \(G\).
    * The last operation \(op\) of \(S'\) is not a complete operation in \(H_i\). Recall that \(S'\) ends with
      an operation \(op\) that is complete in \(H_{i+1}\) and \(H_{i+1}\) extends \(H_i\) with one event only.
      Thus the last event of \(H_{i+1}\) is the response of \(op\). Thus \(H_i\) and \(H_{i+1}\) contain the
      same set of operations, except that \(op\) is imcomplete in \(H_i\). Let \(S\) be the longest prefix
      of \(S'\) that ends with a complete operation in \(H_i\). Since \(S'\) is legal, \(S\) is also legal. By
      construction, every complete operation in \(H_i\) appears in \(S\) and no operation appears in \(S\) if
      it does not appear in \(H_i\). Thus, \(S\) is a linearization of \(H_i\) and \((H_i,S,Q)\), where \(Q\)
      is the prefix of \(Q'\) that witnesses the legality of \(S\), is a vertex in \(G\).
    #+END_proof
* Progress
** Implementation
*** High-Level and Low-Level Objects
    *Low-level objects* are also called *base* objects and the operations they export are called *primitives*.
*** Zooming into Histories
** Progress Properties
    Informally, we say that an implementation is *lock-based* if it permits a situation in which some process
    running in isolation after some finite execution is never able to complete its operation. Taking a
    negation of this property, we state that an implementation *does not employ locks* if by starting after any
    finite execution, every process can complete its operation in a finite number of its own steps.

    Several progress properties preclude the use of locks:
    * *Obstruction-freedom* (*solo termination*): An implementation (of a shared object) is obstruction-free, if
      every operation by a correct process that eventually runs without concurrency returns a response.

      An operation on an object invoked by a process \(p\) is said to *eventually run without concurrency* if
      there is a time after which \(p\) is the only process to take *steps* involving the object.
    * *Non-blockingness* (*partial termination*): at least one of correct processes that execute operations on the
      same object terminates its operation.
    * *Wait-freedom* (*global termination*): every operation executed by a correct process eventually returns a
      response.


    *Liveness* property ensures that the implementation eventually reaches some desired state. We say that \(P\)
    is a liveness property if /any/ finite execution has an extension in \(P\). To show that an implementation
    satisfies a liveness property \(P\), we should show that all its /infinite/ executions are in \(P\).
** Linearizability and Wait-Freedom
