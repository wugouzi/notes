#+title: Algorithms for Concurrent Systems

#+AUTHOR: Rachid Geurraoui & Petr Kuznetsov
#+EXPORT_FILE_NAME: ../latex/AlgorithmsForConcurrentSystems/AlgorithmsForConcurrentSystems.tex
#+LATEX_HEADER: \graphicspath{{../../books/}}
#+LATEX_HEADER: \input{../preamble.tex}
#+LATEX_HEADER: \makeindex
* Linearizability
** Introduction
    Linearizability is a correctness metric for shared object implementations. The notion of /correctness/, as
    captured by linearizability, is defined with respect to how the object is expected to
    react when accessed sequentially, i.e., the objectâ€™s *sequential specification*.
** The Players
*** Processes
    We consider a system that consists of a finite set of \(n\) processes,
    denoted \(p_1,\dots,p_n\). Besides accessing local variables, processes can
    execute operations on *shared objects*. Through these objects, the processes
    synchronize their computations.

    The execution of an operation *op* on an object \(X\) by a process \(p_i\) is
    modeled by two events, specifically, the event
    denoted \(inv[X.op\text{ by }p_i]\) that occurs when \(p_i\) invokes the
    operation (*invocation event*), and the event
    denoted \(resp[X.op.res\text{ by }p_i\) that occurss when the operation
    terminates (*response event*).

    Each interaction between a process and an object is represented by a
    /visible event/.
*** Objects
    An object has a unique *identity* and a *type*.

    We define an object type by
    1. the set of possible states the objects of that type can take, including the /initial/ type.
    2. a set of operations through which the state of the objects of that type can be manipulated
    3. a *sequential specification* that describes, for each operation of the type and every state, the effect
       this operation produces when it is applied to the object in that state
*** Histories
    The interaction between processes and objects is modeled as a totally ordered set of events \(H\), and is
    called a *history*. The total order relation on \(H\), denoted \(<_H\), abstracts out the real-time order in
    which the events actually occur.

    A *local* history of \(p_i\), denoted \(H|_{p_i}\) is a projection of \(H\) on process \(p_i\): the
    subsequence \(H\) consisting of the events generated by \(p_i\). Two histories \(H\) and \(H'\) are
    *equivalent* if they have the same local histories.

    As we consider sequential process, we focus on histories \(H\) s.t. for each process \(p_i\), \(H|_{p_i}\)
    is sequential: The history starts with an invocation, followed by a matching response, followed by another
    invocation, etc. We say in this case that the global history \(H\) is *well-formed*.

    An operation is *complete* in a history if the history includes both the event corresponding to the
    invocation of the operation and its response. If the history contains only the invocation of an operation
    but no matching response, we say that the operation is *pending* in that history. A history without pending
    operations is said to be *complete*.

    Let \(op=X.op1()\) by \(p_i\) and \(op'=Y.op1()\) by \(p_j\) be two operations. Define
    \begin{equation*}
    (op\to_Hop'):=(resp[op]<_Hinv[op'])
    \end{equation*}
    Two operations \(op\) and \(op'\) are said to *overlap* in a history \(H\) is
    neither \(resp[op]<_Hinv[op']\) nor \(resp[op']<_Hinv[op]\).
*** Sequential Histories
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *sequential history* is one of which the first event is an invocation, then
    1. each invocation event, except possibly the last, is immediately followed by the matching response event
    2. each response event, except possibly the last, is immediately followed by an invocation event.
    #+END_definition
*** Legal Histories
    Given a sequential history \(H\) and an object \(X\), \(H|X\) denotes the subsequence of \(H\) made up of
    all the events involving only object \(X\). We say that \(H\) is *legal* if, for each object \(X\) involved
    in \(H\), \(H|X\) belongs to the sequential specification of \(X\).
** Linearizability
*** Complete Histories
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A complete history \(H\) is *linearizable* if there is a history \(L\) s.t.
    1. \(L\) and \(H\) are equivalent
    2. \(L\) is sequential
    3. \(L\) is legal
    4. \(\to_H\subseteq\to_L\)
    #+END_definition

    Such a sequential history \(L\) is called a *linearization* of \(H\) or a *sequential witness* of \(H\).
*** Incomplete Histories and Completeness
    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A *completion* of a history \(H\) is a complete history obtained from \(H\) as follows: every invocation
    of a pending operation is either removed or completed with a response put at the end of the history. The
    remaining events of \(H\) are left in exactly the same order.
    #+END_definition

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A history \(H\) is *linearizable* if it has a linearizable completion.
    #+END_definition
*** Linearizability is Non-Blocking
    An interesting feature of linearizability is that it is *non-blocking*. Every pending operation in a
    history \(H\) can be completed, without having to wait for any other operation complete or sacrificing the
    linearizability of the resulting history.

    #+ATTR_LATEX: :options []
    #+BEGIN_theorem
    Let \(H\) be any finite linearizable history and \(inv[op]\) any pending operation invocation in \(H\).
    There is a response \(r=resp[op]\) s.t. \(H\cdot r\) is linearizable
    #+END_theorem

    #+BEGIN_proof
    As \(H\) is incomplete and linearizable, there is a completion of \(H\), \(H'\) that is linearizable,
    i.e., that has a linearization \(L\) of \(H\). If \(L\) contains \(inv[op]\) and its matching
    response \(r\), then \(L\) is also a linearization of \(H\cdot r\). If \(L\) contains neither \(inv[op]\)
    nor \(r\), then \(L'=L\cdot inv[op]\cdot r\) is a linearization of \(H'\cdot inv[op]\cdot r\), which means
    that \(H\) is linearizable.
    #+END_proof
*** Composition
    A property \(P\) is said to be *compositional* (also called *local*) if whenever it holds for each of the
    objects of a set, it holds for the entire set.

    #+ATTR_LATEX: :options []
    #+BEGIN_definition
    A history \(H\) is linearizable iff for each object \(X\) involved in \(H\), \(H|X\) is linearizable
    #+END_definition

    #+BEGIN_proof
    Consider a history \(H\), where for each object \(X\), \(H|X\) has a linearization, denoted \(S_X\),
    let \(\to_X\) denote the total order in \(S_X\) of the operation on \(X\) in \(H\). We show that the
    relation \(\to=\bigcup_X\{\to_X\}\cup\{\to_H\}\) does not induce any cycle. This means that its transitive
    closure is a partial order, and its linear extention \(S\) is a linearization of \(H\).

    Suppose \(\to\) contains a cycle. Since every operation concerns exactly one object, the cycle cannot
    contain fragments of the form \(op_1\to_Xop_2\to_Yop_3\) for \(X\neq Y\). Hence the cycle alternate edges
    of the form \(\to_X\) with edges \(\to_H\).

    Now consider the fragment \(op_1\to_Hop_2\to_Xop_3\to_Hop_4\). Recall that \(\to_X\) is the order of
    operations in \(S_X\), a linearization of \(H|X\). Since \(S_X\) respect real time, we
    have \(op_3\nrightarrow_Xop_2\), i.e., the invocation of \(op_2\) precedes the response of \(op_3\)
    in \(H|X\) and thus in \(H\). Therefore \(op_1\to_Hop_4\), i.e., we can shorten the fragment to one
    edge \(\to_H\). Therefore we get a cycle in \(\to_H\).
    #+END_proof
** The Importance of (Real) Time
