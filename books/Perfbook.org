#+title: Is Parallel Programming Hard, And, If So, @@latex:\\@@What Can You Do About It?

#+AUTHOR: Paul E. McKenny
* Appendices :ignore:
#+LATEX: \appendix
** Why Memory Barriers
*** Cache Structure
    #+ATTR_LATEX: :width .7\textwidth :float nil
    #+NAME:
    #+CAPTION: Modern Computer System Cache Structure
    [[../images/perfbook/1.png]]

    Data flows among the CPUs’ caches and memory in fixed-length blocks called “cache lines”, which
    are normally a power of two in size, ranging from 16 to 256 bytes. When a given data item is
    first accessed by a given CPU, it will be absent from that CPU’s cache, meaning that a “cache
    miss” (or, more specifically, a “startup” or “warmup” cache miss) has occurred. The cache miss
    means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is
    fetched from memory. However, the item will be loaded into that CPU’s cache, so that subsequent
    accesses will find it in the cache and therefore run at full speed.

    #+ATTR_LATEX: :width .8\textwidth :float nil
    #+NAME:
    #+CAPTION: CPU Cache Structure
    [[../images/perfbook/2.png]]

    This cache has sixteen “sets” and two “ways” for a total of 32 “lines”, each entry containing a
    single 256-byte “cache line”, which is a 256-byte-aligned block of memory.

    Each box corresponds to a cache entry, which can contain a 256-byte cache line. Since the cache
    lines must be 256-byte aligned, the low eight bits of each address are zero, and the choice of
    hardware hash function means that the next-higher four bits match the hash line number.

    What happens when it does a write? Because it is important that all CPUs agree on the value of a
    given data item, before a given CPU writes to that data item, it must first cause it to be
    removed, or “invalidated”, from other CPUs’ caches. Once this invalidation has completed, the
    CPU may safely modify the data item. If the data item was present in this CPU’s cache, but was
    read-only, this process is termed a “write miss”. Once a given CPU has completed invalidating a
    given data item from other CPUs’ caches, that CPU may repeatedly write (and read) that data
    item.

    Later, if one of the other CPUs attempts to access the data item, it will incur a cache miss,
    this time because the first CPU invalidated the item in order to write to it. This type of cache
    miss is termed a “communication miss”, since it is usually due to several CPUs using the data
    items to communicate (for example, a lock is a data item that is used to communicate among CPUs
    using a mutual-exclusion algorithm).

    Clearly, much care must be taken to ensure that all CPUs maintain a coherent view of the data.
    With all this fetching, invalidating, and writing, it is easy to imagine data being lost or
    (perhaps worse) different CPUs having conflicting values for the same data item in their
    respective caches.
*** Cache-Coherence Protocols
**** MESI States
    MESI stands for "modified", "exclusive", "shared", and "invalid", the four states a given cache
    line can take on using this protocol.
