#+TITLE: Week5

#+AUTHOR: 陈淇奥@@latex:\\@@21210160025
#+OPTIONS: toc:nil
#+LATEX_HEADER: \input{../../../preamble-lite.tex}
#+LATEX_HEADER: \usepackage[UTF8]{ctex}
#+LATEX_HEADER: \DeclareMathOperator*{\bplus}{\scalerel*{+}{\textstyle\sum}}

#+BEGIN_exercise
令\(\calb\)为任意布尔代数，\(a,b,c\in B\)，证明
\begin{equation*}
-(-a+(-b)+c)+(-(-a+b))+-a+c=1
\end{equation*}
#+END_exercise

#+BEGIN_proof
用\(\barx\)表示\(-x\)，则
\begin{align*}
-(\bara+\barb+c)+(-(\bara+b))+\bara+c&=ab\barc+a\barb+\bara+c\\
&=ab\barc+a\barb(c+\barc)+\bara+c\\
&=a\barc+\bara+c+a\barb c\\
&=c+a\barc+\bara=ca+c\bara+a\barc+\bara\\
&=a+\bara=1
\end{align*}
#+END_proof

#+BEGIN_exercise
在Lindenbaum代数\(\calb(\emptyset)\)中，如果\([\alpha]\)是原子，则对任意公式\(\beta\)，\(\vdash\alpha\to\beta\)或者\(\vdash\alpha\to\neg\beta\)
#+END_exercise

#+BEGIN_proof
因为\([\alpha]\)是原子，由引理1.1.25，对任意\([\beta]\neq 0\)，\([\alpha]\le[\beta]\)或者\([\alpha]\le-[\beta]\)，于是由练习1.1.19，
\(\vdash\alpha\to\beta\)或者\(\vdash\alpha\to\neg\beta\)
#+END_proof

#+BEGIN_exercise
对任意布尔代数\(\cala,\calb\)，定义它们的积\(\calc\)为
1. \(C=A\times B\)
2. \((a_1,b_1)+(a_2,b_2)=(a_1+a_2,b_1+b_2)\)
3. \((a_1,b_1)\cdot(a_2,b_2)=(a_1a_2,b_1b_2)\)
4. \(-(a,b)=(-a,-b)\)
5. \(0=(0,0)\), \(1=(1,1)\)


证明\(\calc\)是一个布尔代数
#+END_exercise

#+BEGIN_proof
1. \((a_1,b_1)+((a_2,b_2)+(a_3,b_3))=(a_1,b_1)+(a_2+a_3,b_2+b_3)=((a_1+a_2)+a_3,(b_1+b_2)+b_3)=((a_1,b_1)+(a_2,b_2))+(a_3,b_3)\)

   \((a_1,b_1)\cdot((a_2,b_2)\cdot(a_3,b_3))=(a_1a_2a_3,b_1b_2b_3)=((a_1,b_1)(a_2,b_2))(a_3,b_3)\)

2. \((a_1,b_1)+(a_2,b_2)=(a_1+a_2,b_1+b_2)=(a_2+a_1,b_2+b_1)=(a_2,b_2)+(a_1,b_1)\)

   \((a_1,b_1)(a_2,b_2)=(a_2a_1,b_2b_1)=(a_2,b_2)(a_1,b_1)\)

3. \((a_1,b_1)+(a_1,b_1)(a_2,b_2)=(a_1+a_1a_2,b_1+b_1b_2)=(a_1,b_1)\)

   \((a_1,b_1)((a_1,b_1)+(a_2,b_2))=(a_1(a_1+a_2),b_1(b_1+b_2))=(a_1,b_1)\)
4. \((a_1,b_1)((a_2,b_2)+(a_3,b_3))=(a_1(a_2+a_3),b_1(b_2+b_3))=(a_1a_2+a_1a_3,b_1b_2+b_1b_3)=(a_1,b_1)(a_2,b_2)+(a_1,b_1)(a_3,b_3)\)

   \((a_1,b_1)+(a_2,b_2)(a_3,b_3)=(a_1+a_2a_3,b_1+b_2b_3)=((a_1,b_1)+(a_2,b_2))((a_1,b_1)+(a_3,b_3))\)
5. \((a_1,b_1)+(-a_1,-b_1)=(a_1+-a_1,b_1+-b_1)=(1,1)\)

   \((a_1,b_1)(-a_1,-b_1)=(a_1(-a_1),b_1(-b_1))=(0,0)\)
#+END_proof

#+BEGIN_exercise
对任意布尔代数\(\calb\)，如果\(a\in B\)且\(a>0\)，令\(B\uhr a=\{b\in B\mid b\le a\}\)，令\(\calb\uhr a\)中的运
算\(+,\cdot,0\)保持与\(\calb\)中一致，而1和\(-b\)分别为\(a\)和\(a\cdot(-b)\)
1. 证明\(\calb\uhr a\)是一个布尔代数
2. 对任意\(a\in B\),\(B\cong(\calb\uhr a)\times(\calb\uhr -a)\)
#+END_exercise

#+BEGIN_proof
1. 不难验证
2. 定义\(f:\calb\to(\calb\uhr a)\times(\calb\uhr -a)\)为\(f(b)=(b\cdot a,b\cdot(-a))\)，于是
   1. \(f(0)=(0,0)\), \(f(1)=(a,-a)\)
   2. \(f(b_1+b_2)=(b_1a+b_2a,b_1(-a)+b_2(-a))=(b_1a,b_1(-a))+(b_2a,b_2(-a))=f(b_1)+f(b_2)\)
      同理
      \(f(b_1\cdot b_2)=f(b_1)\cdot f(b_2)\)
   3. 若\(f(b_1)=f(b_2)\)，则\(b_1a=b_2a\)且\(b_1(-a)=b_2(-a)\)，于是\(b_1(a+(-a))=b_2(a+(-a))\)，因此\(b_1=b_2\)
   4. 对于任意\(b\in\calb\uhr a\),\(c\in \calb\)，则\(b\le a\)，\(c\le-a\)，于是\(ca\le a(-a)=0\)，\(b(-a)\le a(-a)=0\)，
      因此\(ca=b(-a)=0\)，因此\(f(b+c)=(b,c)\)
#+END_proof

#+BEGIN_exercise
令\(h:\cala\to\calb\)为同态，\(D\subseteq A\)且\(\sum D\)存在，称\(h\) *保持* \(\sum D\)，如果\(\sum h[D]\)存在
且\(h(\sum D)=\sum h[D]\)

证明：\(\calb\)上的超滤\(U\)保持\(\sum D\)当且仅当\(U\)确定的同态\(f:\calb\to\{0,1\}\)保持\(\sum D\)
#+END_exercise

#+BEGIN_proof
\(\Rightarrow\): 因为\(U\)保持\(\sum D\)，存在\(d\in D\)使得\(d\in U\)，于是\(f(d)=1\)，因此\(\sum f(d)=1\)，\(\sum h[D]=1\)，于
是\(h(\sum D)=1=\sum h[D]\)

\(\Leftarrow\): 若\(\sum D\in U\)，则\(f(\sum D)=1=\sum f[D]\)，若对于所有\(d\in D\)，\(f(d)=0\)，则\(\sum f[D]=0\)，因此存
在\(d\in D\)使得\(f(d)=1\)，因此\(d\in U\)
#+END_proof

#+BEGIN_exercise
令\(\calb\)为布尔代数，\(h:\calb\to\calp(Ult(\calb))\)为Stone映射，对任意\(b\in B\)，称\(h(b)\)为\(S(\calb)\)的 *基本开集* ，
如果集合\(X\subseteq Ult(\calb)\)能表示称基本开集的并集，就称 \(X\) 为 *开集* ，开集的补集为 *闭集*
#+END_exercise

#+BEGIN_proof
1. 证明\(h(d)\)既是开集，也是闭集
2. 对任意\(U,V\in Ult(\calb)\)，如果\(U\neq V\)，则存在一个开闭集包含\(U\)，但不包含\(V\)
#+END_proof

#+BEGIN_proof
1. \(h(d)\)显然是开集，而\(h(-d)\)也是开集，而\(h(d)\cap h(-d)=\emptyset\)且\(h(d)\cup h(-d)=Ult(\calb)\)，因
   此\(h(d)\)为闭集

2. 取\(b\in U\setminus V\)，于是\(-b\in V\)，因此\(V\notin h(b)\)
#+END_proof

#+BEGIN_exercise
如果\(C\subseteq\calp(Ult(\calb))\)是开集的族，且\(\bigcup C=Ult(\calb)\)，就成\(X\)是 *开覆盖* 。证明：如果\(C\)是开覆盖，则存
在有穷的\(C_0\subseteq C\)，\(\bigcup C_0=Ult(\calb)\)
#+END_exercise

#+BEGIN_proof
令\(h:\calb\to\calp(Ult(\calb))\)为Stone映射，令\([b]\)表示\(h(b)\)。
因为每个开集都是基础开集的并，则\(\bigcup C=\bigcup_{b\in D}[b]\)，即\(\bigcap_{b\in D}[-b]=\calp(Ult(\calb))-\bigcup C\)。

若对于任何有穷的\(C_0\subseteq C\)，\(\bigcup C_0\neq Ult(\calb)\)，则
基础开集族\(\{[-b]:b\in D\}\)有
穷交性质，因此\(\{-b:b\in D\}\)有有穷交性质，因此存在
超滤\(U\supseteq\{-b:b\in D\}\)，因此\(U\notin\bigcup C\)，于是\(\bigcup C\neq Ult(\calb)\)，矛盾
#+END_proof

#+BEGIN_exercise
对任意布尔代数\(\calb\)，\(D\subseteq B\)且\(\sum D\)存在，证明：Stone映射保持\(\sum D\)当且仅当存在有
穷\(D_0\subseteq D\)且\(\sum D=\sum D_0\)
#+END_exercise

#+BEGIN_proof
令\(h\)为Stone映射。

\(\Rightarrow\): \(h(\sum D)=\sum h[D]=\bigcup h[D]\)，于是存在有穷\(D_0\subseteq D\)使得\(h(\sum D)=\bigcup h[D_0]=h(\sum D_0)\),因为\(h\)是
单射，\(\sum D_0=\sum D\)

\(\Leftarrow\): 断言：对于有穷集合\(D_0=\{d_1,\dots,d_n\}\subseteq B\),\(\sum D_0=d_1+\dots+d_n\)

对于任何\(\sum D_0\le e\), \(d_1\le e,\dots,d_n\le e\)，于是\(d_1+e=e,\dots,d_n+e=e\)，于是\(d_1+\dots+d_n+e=e\),因此
\(d_1+\dots+d_n\le e\)

于是\(h(\sum D)=h(\sum D_0)=+_{d\in D_0}h(d)=\bigcup_{d\in D_0}h(d)=\sum \{h(d):d\in D_0\}=\sum h[D_0]\)

\(\sum h[D_0]\le\sum h[D]\)，存在有穷\(D_1\subseteq D\)使得\(\sum h[D_1]=\sum h[D]\)，因此\(\sum D_0\le\sum(D_0\cup D_1)\le\sum D\)，因
此\(\sum(D_0\cup D_1)=\sum D\)且\(h(\sum D)=h(\sum (D_0\cup D_1))=\sum h[D_0\cup D_1]=\sum h[D]\)
#+END_proof
