#+title: Seeing is Believing: A Client-Centric Specification of Database Isolation
#+AUTHOR:
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+EXPORT_FILE_NAME: ../../latex/papers/transaction/client-centric_specification_of_database_isolation.tex
#+LATEX_HEADER: \graphicspath{{../../../paper/transaction/}}
#+LATEX_HEADER: \DeclareMathOperator{\RS}{\calr\cals}
#+LATEX_HEADER: \DeclareMathOperator{\preread}{\textsc{preread}}
#+LATEX_HEADER: \DeclareMathOperator{\complete}{\textsc{complete}}
#+OPTIONS: toc:nil
#+STARTUP: shrink
* Introduction
        We propose a new model that, for the first time, expresses isolation guarantees exclusively as
        properties of states that applications can observe
* A State-Based Model
        More formally, we define a storage system \(S\) with respect to a set \(K\) of keys and \(V\)of
        values; a system state \(s\) is a unique mapping from keys to values produced by writes from aborted or
        committed transactions. For simplicity, we assume that each value is uniquely identifiable. There can
        thus be no ambiguity, when reading an object, as to which transaction wrote its content. In the
        initial system state, all keys have value \(\bot\); later states similarly include every key, possibly
        mapped to \(\bot\). As is common in database systems, we assume that applications modify the storage
        system’s state using transactions. A *transaction* \(T\) is a tuple \((\Sigma_T,\xrightarrow{to})\),
        where \(\Sigma_T\) is the set of *operations* in \(T\), and \(\xrightarrow{to}\) is a total order on
        \(\Sigma_T\). Operations can be either reads or writes. *Read* operation \(r(k,v)\) retrieves value
        \(v\) by reading key \(k\); write operation \(w(k,v)\) updates \(k\) to its new value \(v\). The *read
        set* of \(T\) comprises the keys read by \(T:\calr_T=\{k\mid r(k,v)\in\Sigma_T\}\). Similarly, the
        write set of \(T\) comprises the keys that \(T\) updates: \(\calw_T=\{k\mid w(k,v)\in\Sigma_T\}\). For
        simplicity of exposition, we assume that a transaction only writes a key once. Finally, we assume the
        existence of a time oracle \(O\) that assigns distinct real-time start and commit timestamps
        (\(T.start\) and \(T.commit\)) to every transaction \(T\in\calt\) . A transaction \(T_1\)
        time-precedes T2 (we write \(T_1<_sT_2\)) if \(T_1.commit<T_2.start\). Applying a transaction \(T\) to
        a state \(s\) transitions the system to a state \(s'\) that is identical to \(s\) in every key except
        those written by \(T\). Formally,
        #+ATTR_LATEX: :options []
        #+BEGIN_definition
\begin{align*}
s\xrightarrow{T}s'\equiv&\left( [(k,v)\in s'\wedge(k,v)\notin s]\Rightarrow k\in\calw_T \right)\wedge\\
&(w(k,v)\in\Sigma_T\Rightarrow(k,v)\in s')
\end{align*}
        #+END_definition
        We refer to \(s\) as the *parent state* of \(T\) (denoted as \(s_{p,T}\)); to the transaction that
        generated \(s\) as \(T_s\) ; and to the set of keys in which \(s\) and \(s'\) differ as
        \(\Delta(s,s')\). An execution \(e\) for a set of transactions \(\calt\) is a totally ordered set
        defined by the pair \((\cals_e,\xrightarrow{T\in\calt})\), where \(\cals_e\) is the set of states
        generated by applying, starting from the system's initial state, a permutation of all the transactions
        in \(\calt\). We write \(s\xrightarrow{*}s'\) (respectively, \(s\xrightarrow{+}s'\)) to denote a
        sequence of zero (respectively, one) or more state transitions from \(s\) to \(s'\) in \(e\).

        Note that while \(e\) identifies the state transitions produced by each transaction \(T\in\calt\), it
        does not specify from which states in \(\cals_e\) each operation in \(T\) reads. In particular, reading a key in replicated
        distributed systems will not necessarily return the value produced by the latest write to that key, as
        writes may become visible in different orders at different replicas. In general, multiple states in
        \(\cals_e\) may be compatible with the value returned by any given operation. We call this subset the
        operation’s *read states*. To prevent operations from reading from the future, we restrict the valid
        read states for the operations in \(T\) to be no later than \(s_p\) . Further, once an operation in
        \(T\) writes \(v\) to \(k\), we require all subsequent operations in \(T\) that read \(k\) to return
        \(v\): in this case, their set of read states by convention includes all states in \(\cals_e\) up to and
        including \(s_p\)

        #+ATTR_LATEX: :options []
        #+BEGIN_definition
        Given an execution \(e\) for a set of transactions \(\calt\), let \(T\in\calt\) and let \(s_p\) denote
        \(T\)'s parent state. The read states for a read operation \(o=r(k,v)\in\Sigma_T\) define the set of
        states
        \begin{align*}
        \RS_e(o)=\{&s\in\cals_e\mid s\xrightarrow{*}s_p\wedge\\
        &((k,v)\in s\vee(\exists w(k,v)\in\Sigma_T:w(k,v)\xrightarrow{to}r(k,v)))\}
        \end{align*}
        #+END_definition

        #+ATTR_LATEX: :width .8\textwidth :float nil
        #+NAME: f2
        #+CAPTION: Read States and execution
        [[../../images/papers/223.png]]

        Figure ref:f2 illustrates the notion of read states for the operations executed by transaction
        \(T_b\). Since \(r_2\) returns \(y_1\) , its only possible read state is \(s_2\), i.e., the only state
        containing \(y_1\). When it comes to \(r_3\) , however, \(z_0\) could have been read from any of
        \(s_0\), \(s_1\) or \(s_2\): from the perspective of the client executing \(T_b\), these read states
        are indistinguishable. By convention, write operations have read states too: for a write operation in
        \(T\), they include all states in \(\cals_e\) up to and including \(T\)’s parent state. It is easy to
        prove that the read states of any operation \(o\) define a subsequence of contiguous states in the
        total order that \(e\) defines on \(\cals_e\) . We refer to the first state in that sequence as
        \(sf_o\) and to the last state as \(sl_o\) . For instance, in Figure ref:f2, \(sf_{r_3}\) is \(s_0\)
        (the first state that contains \(z_0\)) and \(sl_{r_3}\) is \(s_2\) (\(z_0\) is overwritten in
        \(s_3\)). When the predicate \(\preread_e(\calt)\) holds, then such states exist for all transactions
        in \(\calt\):

        #+ATTR_LATEX: :options []
        #+BEGIN_definition
        Let \(\preread_e(T)\equiv\forall o\in\Sigma_T:\RS_e(o)\neq\emptyset\).
        Then \(\preread_e(\calt)\equiv\forall T\in\calt:\preread_e(T)\)
        #+END_definition
        We say that a state \(s\) is *complete* for \(T\) in \(e\) if every operation in \(T\) can read from
        \(s\). We write:
        #+ATTR_LATEX: :options []
        #+BEGIN_definition
        \(\complete_{e,T}(s)\equiv s\in\bigcap_{o\in\Sigma_T}\RS_e(o)\)
        #+END_definition




* Problems


* References
<<bibliographystyle link>>
bibliographystyle:alpha

\bibliography{/Users/wu/notes/notes/references.bib}
