#+title: Top Down Method For Performance Analysis And Counters Architecture

#+AUTHOR:
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+EXPORT_FILE_NAME: ../../latex/papers/engineering/top_down_method_for_performance_analysis_and_counters_architecture.tex
#+LATEX_HEADER: \graphicspath{{../../../paper/engineering/}}
#+OPTIONS: toc:nil
#+STARTUP: shrink

* Background
        From a bird’s eye view, the pipeline of modern out-of-order CPU has two main portions: a frontend and a backend.
        * The frontend is responsible for fetching instructions from memory and translating them into
          micro-operations (uops). These uops are fed to the backend portion.
        * The backend is responsible to schedule, execute and commit (retire) these uops per original
          program’s order.
        So as to keep the machine balanced, delivered uops are typically buffered in some “ready-uops-queue”
        once ready for consumption by the backend. An example block diagram for the Ivy Bridge
        microarchitecture, with underlying functional units is depicted in Figure ref:f1.

        #+ATTR_LATEX: :width .5\textwidth :float nil
        #+NAME: f1
        #+CAPTION:
        [[../../images/papers/225.png]]

        Traditional methods [4][5] do simple estimations of stalls.
        E.g. the numbers of misses of some cache are multiplied by a
pre-defined latency:
Stall_Cycles = Σ Penaltyi * MissEvent


* Problems


* References
<<bibliographystyle link>>
bibliographystyle:alpha

\bibliography{/Users/wu/notes/notes/references.bib}
