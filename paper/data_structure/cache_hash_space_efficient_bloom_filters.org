#+title: Cache-, Hash- and Space-Efficient Bloom Filters

#+AUTHOR:
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+EXPORT_FILE_NAME: ../../latex/papers/data_structure/bloom_filter.tex
#+LATEX_HEADER: \graphicspath{{../../../paper/data_structure/}}
#+LATEX_HEADER: \DeclareMathOperator{\std}{\textsf{std}}
#+LATEX_HEADER: \DeclareMathOperator{\blo}{\textsf{blo}}
#+LATEX_HEADER: \DeclareMathOperator{\pat}{\textsf{pat}}
#+OPTIONS: toc:nil
#+STARTUP: shrink

* Standard Bloom Filters with Variants
        The original Bloom filter for representing a set of at most \(n\) elements consists of a bit vector of
        length \(m\). Let \(c:=m/n\) be the bits-per-element rate. Initially, all bits are set to 0. For
        inserting an element \(e\) into the filter, \(k\) bits are set in the Bloom filter according to the
        evaluations of \(k\) independent hash functions \(h_1(e), \dots, h_k(e)\).

        For a fixed number of contained elements, the FPR is lowest if the probability of a bit being set is
        as close as possible to 0.5. Therefore the optimal \(k\) is \(\ln2 \cdot c\).

        The probability that a bit has remained 0 after inserting \(n\) elements is
        \begin{equation}
        \label{1}
        p':=\left(1-\frac{1}{m}\right)^{kn}\approx_{i=kn}\lim_{i\to\infty}\left(1-\frac{kn}{mi}\right)^i=e^{-kn/m}
        \end{equation}
        The false positive rate for a standard Bloom filter (\(\std\)) is
        \begin{equation}
        \label{2}
        f_{\std}(m,n,k)=(1-p')^k=\left(1-\left(1-\frac{1}{m}\right)^{kn}\right)^k
        \approx\left(1-e^{-kn/m}\right)^k\approx\frac{1}{2^k}
        \end{equation}
        for the optimal \(k\).

* Blocked Bloom Filters
        We will now analyze the cache eﬃciency of a standard Bloom ﬁlter, which we assume to be much larger
        than the cache. For negative queries, only less than two cache misses are generated, on the average,
        as each bit is set with probability \(q=1/2\).

        Standard Bloom ﬁlters are /cache-inefficient/ since k cache misses are generated by every input
        operation and (false or true) positive membership query.

        In this section, we present a cache-eﬃcient variant called blocked Bloom ﬁlter (\(\blo\)).
        It consists of a sequence of \(b\) comparatively small standard Bloom ﬁlters (Bloom ﬁlter blocks),
        each of which ﬁts into one cache-line. Nowadays, a common cache line size is 64 bytes = 512 bits. For
        best performance, those small ﬁlters are stored cache-line-aligned. For each potential element, the
        ﬁrst hash value selects the Bloom ﬁlter block to be used. Additional hash values are then used to set
        or test bits as usual, but only inside this one block. A blocked Bloom ﬁlter therefore only needs one
        cache miss for every operation.

        Let primed identiﬁers refer to the "local" parameters of the Bloom ﬁlter block. On the ﬁrst glance,
        blocked Bloom ﬁlters should have the same FPR as standard Bloom ﬁlters of the same size since the FPR
        in Equation [[ref:2]] only depends on \(k\) and \(n/m\), since \(k=k'\) and since the expected value of
        \(n'/m'\) is \(n/m\). However, we are dealing with small values of \(m\) so that the approximation is not perfect.

        More importantly, \(n'\) is a random variable that ﬂuctuates from block to block. Some blocks will be
        overloaded and others will be underloaded. The net eﬀect is not clear on the ﬁrst glance. The
        occupancies of the blocks follow a binomial distribution \(B(n, 1/b)\) that can be closely approximated by
        a Poisson distribution with parameter \(n/b = B/c\) since n is usually large, and \(B/c\) is a small constant.

        For the blocked Bloom ﬁlters, we still have to set or test k bits in for every insertion or positive
        query. On the other hand, modern processors have one or two SIMD units which can handle up to 128 bits
        in a single instruction. Hence, a complete cache-line can be handled in only two steps.

        To beneﬁt from this functionality, we propose to implement blocked Bloom ﬁlters using precomputed bit
        patterns. Instead of setting \(k\) bits through the evaluation of \(k\) hash functions, a single hash
        function chooses a precomputed pattern from a table of random \(k\)-bit pattern of width \(B\). With this
        solution, only one small (in terms of bits) hash value is needed, and the operation can be implemented
        using few SIMD instructions. When transferring the Bloom ﬁlter, the table need not be included
        explicitly in the data, but can be reconstructed using the seed value.

        The main disadvantage of the bit pattern approach is that two elements may cause a /table collision/
        when they are hashed to the same pattern. This leads to an increased FPR. If \(l\) is the number of table entries, the collision probability
        in an \(n\) element Bloom ﬁlter block is \(p_{coll}(n,l):=1-(1-\frac{1}{l})^n\). Hence we can bound
        the FPR for one block by
        \begin{equation}
        \label{4}
        f_{\pat}(m,n,k,l)\le p_{coll}(l)+(1-p_{coll}(l))f_{\std}(m,n,k)
        \end{equation}


* Problems


* References
<<bibliographystyle link>>
bibliographystyle:alpha

<<bibliography link>>
bibliography:/Users/wu/notes/references.bib
