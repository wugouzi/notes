#+title: Plan Stitch: Harnessing the Best of Many Plans
#+AUTHOR:
#+LATEX_HEADER: \input{/Users/wu/notes/preamble.tex}
#+EXPORT_FILE_NAME: ../../latex/papers/query_optimization/plan_stitch.tex
#+LATEX_HEADER: \graphicspath{{../../../paper/query_optimization/}}
#+OPTIONS: toc:nil
#+STARTUP: shrink

        #+LATEX: \wu{
        Our problem: the actual cost may be wrong.
        #+LATEX: }
* Introduction
        The query optimizer often makes good use of the newly-created indexes and statistics, and the
        resulting new query plan improves in execution cost. At times, however, the latest query plan chosen
        by the optimizer has significantly higher execution cost compared to previously-executed plans, i.e.,
        a *plan regresses*

        When a plan regresses due to plan changes, previously-executed plans of the same query are often still
        *valid*, i.e., the plans are still executable in current configuration. In such cases, reverting to a
        cheaper previously-executed plan will resolve the regression.

        APC (*Automatic plan correction*) continuously monitors aggregated execution statistics of plans. Once a
        plan completes execution and has statisticall-significant worse execution cost compared to earlier
        plans of the same query observed in recent history, the server automatically forces the optimizer to
        execute the query with the cheaper older plan which is still valid. When database sizes and data
        distributions have not changed significantly from the time when previous plans in recent history were
        executed, reverting to the cheaper previously-executed plan corrects the regression. Similar features
        are available in other commercial DMBS products as well

        This *reversion-based plan correction* (RBPC) is attractive in a production setting due to its low risk,
        since the decision is based on *observed execution cost*. However, RBPC also restricts itself to choose
        one overall cheapest plan from the set of previously-executed plans. With operator-level execution
        cost statistics, we can further identify efficient subplans from other plan in the set, even if the
        overall plan is not the cheapest. Ignoring these sub-plans can leave significant opportunities of
        further plan improvement with low risk.

        We propose *Plan Stitch*, a fully-automated solution that opportunistically constructs a query plan from
        previously-executed plans of the same query.
* Overview
        *Problem statement*. Given a query instance \(q\), the set of indexes \(\{I_k\}\) available in the
         current database configuration \(C\), and a set \(P\) of distinct query plans \(\{p_i\}\) of \(q\)
         which have per-operator execution costs recorded from past executions, *Plan Stitch* constructs a plan
         \(p\) for query \(q\) that has cheapest execution cost with the constraint that each operator in
         \(p\) can be found in some plan \(p_i\in P\).

         We refer to the operation of constructing \(p\) using operators from different plans in \(p_i\) as *stitching*,
         and the resulting plan \(p\) as the *stitched plan*.

         #+ATTR_LATEX: :width .8\textwidth :float nil
         #+NAME: 2
         #+CAPTION: The architecture of the database engine with feedback collection and Plan Stitch
         [[../../images/papers/190.png]]

         Figure [[ref:2]] shows the logical architecture of how Plan Stitch integrates with a DBMS, how it obtains
         its inputs \(\la q,P,C\ra\), and how it influences the optimizer’s plan choice with its output \(p\).
         Logically, Plan Stitch executes outside of the critical path of the query optimization and execution,
         either as an external client component or a background thread in the DBMS. The optimizer selects a
         plan for a given query and the current configuration (obtained from database metadata), which is then
         executed, and its execution statistics are recorded in a repository. The execution statistics
         includes the plan structure and its operator-level execution cost. Over time, the repository
         passively collects a history of plans, including different plans executed for the same query.

         Whenever multiple plans for the query q have executed and its execution statistics are available in
         the repository, we can trigger Plan Stitch to search for alternative stitched plans which could
         reduce the execution cost compared to the plan currently chosen by the optimizer. Once triggered,
         Plan Stitch obtains its input plans \(P\) from the execution data repository and reads the current
         index configuration \(C\) from the database metadata. The final stitched plan \(p\) generated by Plan
         Stitch is then passed to the optimizer so that it can be used for future executions of query \(q\).

         Plan Stitch influences the optimizer to use \(p\) as \(q\)’s execution plan using a widely-supported plan
         forcing API which allows specifying a plan hint for a query

         The repository needs to age out execution feedback to ensure the accuracy of Plan Stitch’s cost
         estimate when data changes.
* Plan Stitch
        Plan Stitch has two major components:
        1. using the set of previously-executed distinct plans \(P\) of the same query to identify and encode
           a constrained search space; and
        2. using per-operator execution cost from plan pi to construct the stitched plan with minimum total
           execution cost in the constrained search space.
** Constrained Search Space
        Plan Stitch starts by constraining its plan search space to operators that have appeared in some
        \(p_i\). The major challenges in generating this constrained search space are:
        1. identifying equivalent subplans from different plans \(p_i\) ; and
        2. compactly encoding these equivalent subplans in a structure to allow efficient search.

        *Identifying equivalent subplans*. Every node in a query plan represents a logical expression with the
        required physical properties (such as *interesting orders*), e.g., \(A\bowtie B\bowtie C\) without a
        sort order. Two subplans are *equivalent* if they have the same logical expression and the required
        physical properties. A group of equivalent subplans is referred to as an *equivalent subplan group*.

        To find equivalent subplans across plans in \(p_i\), we need to decide the equivalence of the logical
        expressions for these subplans, which is known to be undecidable. Previous work has proposed tests and
        greedy algorithms to match equivalent logical expressions to enable the query optimizer to match views
        and detect duplicate expressions. Conceptually, such techniques can be used to identify equivalent
        expressions. In our implementation, we use similar heuristics that provide a reasonable balance
        between ease of implementation, overhead, and accuracy of matches, and use the optimizer to ensure the
        correctness of a stitched plan as a side-effect of plan forcing.

        *Encoding the constrained search space*. We represent the constrained search space of allowed
        alternative plans using an ~AND~-~OR~ graph. The graph consists of ~AND~ and ~OR~ nodes where each node
        represents whether the respective subplans should be used simultaneously (~AND~) or are mutually
        exclusive (~OR~). Each ~AND~ node corresponds to a physical operator in a plan, e.g., Hash Join. Every ~OR~
        node represents a logical expression with the required physical properties. The children of an ~AND~
        node are ~OR~ nodes, representing logical expressions and required physical properties of the ~AND~
        node’s child subplans. The children of an ~OR~ node are ~AND~ nodes, representing the root physical
        operators of alternative subplans of the ~OR~ node.

        To construct an ~AND~-~OR~ graph, for every subplan rooted at a physical operator in \(p_i\) , we find all
        the equivalent subplans from \(p_j\in P\) . With these equivalent subplans, we create an ~OR~ node
        representing the logical expression and the required physical properties for an equivalent subplan
        group. The root physical operator of each subplan in the group corresponds to a child ~AND~ node of the
        ~OR~ node.
* Problems


* References
<<bibliographystyle link>>
bibliographystyle:alpha

\bibliography{/Users/wu/notes/notes/references.bib}
